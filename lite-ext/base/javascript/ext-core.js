/*
 * Ext JS Library 2.3.0
 * Copyright(c) 2006-2009, Ext JS, LLC.
 * licensing@extjs.com
 *
 * http://extjs.com/license
 */

Ext = { version: '2.3.0' };

// for old browsers
window['undefined'] = window['undefined'];

/**
 * @class Ext
 * Ext core utilities and functions.
 * @singleton
 */

/**
 * Copies all the properties of config to obj.
 * @param {Object} obj The receiver of the properties
 * @param {Object} config The source of the properties
 * @param {Object} defaults A different object that will also be applied for default values
 * @return {Object} returns obj
 * @member Ext apply
 */
Ext.apply = function (o, c, defaults) {
  if (defaults) {
    // no "this" reference for friendly out of scope calls
    Ext.apply(o, defaults);
  }
  if (o && c && typeof c == 'object') {
    for (var p in c) {
      o[p] = c[p];
    }
  }
  return o;
};

(function () {
  var idSeed = 0;
  var ua = navigator.userAgent.toLowerCase(),
    check = function (r) {
      return r.test(ua);
    },
    isStrict = document.compatMode == 'CSS1Compat',
    isOpera = check(/opera/),
    isChrome = check(/chrome/),
    isWebKit = check(/webkit/),
    isSafari = !isChrome && check(/safari/),
    isSafari2 = isSafari && check(/applewebkit\/4/), // unique to Safari 2
    isSafari3 = isSafari && check(/version\/3/),
    isSafari4 = isSafari && check(/version\/4/),
    isIE = !isOpera && check(/msie/),
    isIE7 = isIE && check(/msie 7/),
    isIE8 = isIE && check(/msie 8/),
    isIE6 = isIE && !isIE7 && !isIE8,
    isGecko = !isWebKit && check(/gecko/),
    isGecko2 = isGecko && check(/rv:1\.8/),
    isGecko3 = isGecko && check(/rv:1\.9/),
    isBorderBox = isIE && !isStrict,
    isWindows = check(/windows|win32/),
    isMac = check(/macintosh|mac os x/),
    isAir = check(/adobeair/),
    isLinux = check(/linux/),
    isSecure = /^https/i.test(window.location.protocol);

  // remove css image flicker
  if (isIE6) {
    try {
      document.execCommand('BackgroundImageCache', false, true);
    } catch (e) {}
  }

  Ext.apply(Ext, {
    /**
     * True if the browser is in strict (standards-compliant) mode, as opposed to quirks mode
     * @type Boolean
     */
    isStrict: isStrict,
    /**
     * True if the page is running over SSL
     * @type Boolean
     */
    isSecure: isSecure,
    /**
     * True when the document is fully initialized and ready for action
     * @type Boolean
     */
    isReady: false,

    /**
     * True to automatically uncache orphaned Ext.Elements periodically (defaults to true)
     * @type Boolean
     */
    enableGarbageCollector: true,

    /**
     * True to automatically purge event listeners after uncaching an element (defaults to false).
     * Note: this only happens if enableGarbageCollector is true.
     * @type Boolean
     */
    enableListenerCollection: false,

    /**
     * URL to a blank file used by Ext when in secure mode for iframe src and onReady src to prevent
     * the IE insecure content warning (defaults to javascript:false).
     * @type String
     */
    SSL_SECURE_URL: 'javascript:false',

    /**
     * URL to a 1x1 transparent gif image used by Ext to create inline icons with CSS background images. (Defaults to
     * "http://extjs.com/s.gif" and you should change this to a URL on your server).
     * @type String
     */
    BLANK_IMAGE_URL: 'http:/' + '/extjs.com/s.gif',

    /**
     * A reusable empty function
     * @property
     * @type Function
     */
    emptyFn: function () {},

    /**
     * Copies all the properties of config to obj if they don't already exist.
     * @param {Object} obj The receiver of the properties
     * @param {Object} config The source of the properties
     * @return {Object} returns obj
     */
    applyIf: function (o, c) {
      if (o && c) {
        for (var p in c) {
          if (typeof o[p] == 'undefined') {
            o[p] = c[p];
          }
        }
      }
      return o;
    },

    /**
         * Applies event listeners to elements by selectors when the document is ready.
         * The event name is specified with an @ suffix.
<pre><code>
Ext.addBehaviors({
   // add a listener for click on all anchors in element with id foo
   '#foo a@click' : function(e, t){
       // do something
   },

   // add the same listener to multiple selectors (separated by comma BEFORE the @)
   '#foo a, #bar span.some-class@mouseover' : function(){
       // do something
   }
});
</code></pre>
         * @param {Object} obj The list of behaviors to apply
         */
    addBehaviors: function (o) {
      if (!Ext.isReady) {
        Ext.onReady(function () {
          Ext.addBehaviors(o);
        });
        return;
      }
      var cache = {}; // simple cache for applying multiple behaviors to same selector does query multiple times
      for (var b in o) {
        var parts = b.split('@');
        if (parts[1]) {
          // for Object prototype breakers
          var s = parts[0];
          if (!cache[s]) {
            cache[s] = Ext.select(s);
          }
          cache[s].on(parts[1], o[b]);
        }
      }
      cache = null;
    },

    /**
     * Generates unique ids. If the element already has an id, it is unchanged
     * @param {Mixed} el (optional) The element to generate an id for
     * @param {String} prefix (optional) Id prefix (defaults "ext-gen")
     * @return {String} The generated Id.
     */
    id: function (el, prefix) {
      prefix = prefix || 'ext-gen';
      el = Ext.getDom(el);
      var id = prefix + ++idSeed;
      return el ? (el.id ? el.id : (el.id = id)) : id;
    },

    /**
         * Extends one class with another class and optionally overrides members with the passed literal. This class
         * also adds the function "override()" to the class that can be used to override
         * members on an instance.
         * * <p>
         * This function also supports a 2-argument call in which the subclass's constructor is
         * not passed as an argument. In this form, the parameters are as follows:</p><p>
         * <div class="mdetail-params"><ul>
         * <li><code>superclass</code>
         * <div class="sub-desc">The class being extended</div></li>
         * <li><code>overrides</code>
         * <div class="sub-desc">A literal with members which are copied into the subclass's
         * prototype, and are therefore shared among all instances of the new class.<p>
         * This may contain a special member named <tt><b>constructor</b></tt>. This is used
         * to define the constructor of the new class, and is returned. If this property is
         * <i>not</i> specified, a constructor is generated and returned which just calls the
         * superclass's constructor passing on its parameters.</p></div></li>
         * </ul></div></p><p>
         * For example, to create a subclass of the Ext GridPanel:
         * <pre><code>
    MyGridPanel = Ext.extend(Ext.grid.GridPanel, {
        constructor: function(config) {
            // Your preprocessing here
            MyGridPanel.superclass.constructor.apply(this, arguments);
            // Your postprocessing here
        },

        yourMethod: function() {
            // etc.
        }
    });
</code></pre>
         * </p>
         * @param {Function} subclass The class inheriting the functionality
         * @param {Function} superclass The class being extended
         * @param {Object} overrides (optional) A literal with members which are copied into the subclass's
         * prototype, and are therefore shared between all instances of the new class.
         * @return {Function} The subclass constructor.
         * @method extend
         */
    extend: (function () {
      // inline overrides
      var io = function (o) {
        for (var m in o) {
          this[m] = o[m];
        }
      };
      var oc = Object.prototype.constructor;

      return function (sb, sp, overrides) {
        if (typeof sp == 'object') {
          overrides = sp;
          sp = sb;
          sb =
            overrides.constructor != oc
              ? overrides.constructor
              : function () {
                  sp.apply(this, arguments);
                };
        }
        var F = function () {},
          sbp,
          spp = sp.prototype;
        F.prototype = spp;
        sbp = sb.prototype = new F();
        sbp.constructor = sb;
        sb.superclass = spp;
        if (spp.constructor == oc) {
          spp.constructor = sp;
        }
        sb.override = function (o) {
          Ext.override(sb, o);
        };
        sbp.override = io;
        Ext.override(sb, overrides);
        sb.extend = function (o) {
          Ext.extend(sb, o);
        };
        return sb;
      };
    })(),

    /**
         * Adds a list of functions to the prototype of an existing class, overwriting any existing methods with the same name.
         * Usage:<pre><code>
Ext.override(MyClass, {
    newMethod1: function(){
        // etc.
    },
    newMethod2: function(foo){
        // etc.
    }
});
 </code></pre>
         * @param {Object} origclass The class to override
         * @param {Object} overrides The list of functions to add to origClass.  This should be specified as an object literal
         * containing one or more methods.
         * @method override
         */
    override: function (origclass, overrides) {
      if (overrides) {
        var p = origclass.prototype;
        for (var method in overrides) {
          p[method] = overrides[method];
        }
        if (Ext.isIE && overrides.toString != origclass.toString) {
          p.toString = overrides.toString;
        }
      }
    },

    /**
         * Creates namespaces to be used for scoping variables and classes so that they are not global.  Usage:
         * <pre><code>
Ext.namespace('Company', 'Company.data');
Company.Widget = function() { ... }
Company.data.CustomStore = function(config) { ... }
</code></pre>
         * @param {String} namespace1
         * @param {String} namespace2
         * @param {String} etc
         * @method namespace
         */
    namespace: function () {
      var a = arguments,
        o = null,
        i,
        j,
        d,
        rt;
      for (i = 0; i < a.length; ++i) {
        d = a[i].split('.');
        rt = d[0];
        eval(
          'if (typeof ' +
            rt +
            ' == "undefined"){' +
            rt +
            ' = {};} o = ' +
            rt +
            ';',
        );
        for (j = 1; j < d.length; ++j) {
          o[d[j]] = o[d[j]] || {};
          o = o[d[j]];
        }
      }
    },

    /**
     * Takes an object and converts it to an encoded URL. e.g. Ext.urlEncode({foo: 1, bar: 2}); would return "foo=1&bar=2".  Optionally, property values can be arrays, instead of keys and the resulting string that's returned will contain a name/value pair for each array value.
     * @param {Object} o
     * @return {String}
     */
    urlEncode: function (o) {
      if (!o) {
        return '';
      }
      var buf = [];
      for (var key in o) {
        var ov = o[key],
          k = encodeURIComponent(key);
        var type = typeof ov;
        if (type == 'undefined') {
          buf.push(k, '=&');
        } else if (type != 'function' && type != 'object') {
          buf.push(k, '=', encodeURIComponent(ov), '&');
        } else if (Ext.isDate(ov)) {
          var s = Ext.encode(ov).replace(/"/g, '');
          buf.push(k, '=', s, '&');
        } else if (Ext.isArray(ov)) {
          if (ov.length) {
            for (var i = 0, len = ov.length; i < len; i++) {
              buf.push(
                k,
                '=',
                encodeURIComponent(ov[i] === undefined ? '' : ov[i]),
                '&',
              );
            }
          } else {
            buf.push(k, '=&');
          }
        }
      }
      buf.pop();
      return buf.join('');
    },

    /**
         * Takes an encoded URL and and converts it to an object. Example: <pre><code>
Ext.urlDecode("foo=1&bar=2"); // returns {foo: "1", bar: "2"}
Ext.urlDecode("foo=1&bar=2&bar=3&bar=4", false); // returns {foo: "1", bar: ["2", "3", "4"]}
         * </code></pre>
         * @param {String} string
         * @param {Boolean} overwrite (optional) Items of the same name will overwrite previous values instead of creating an an array (Defaults to false).
         * @return {Object} A literal with members
         */
    urlDecode: function (string, overwrite) {
      if (!string || !string.length) {
        return {};
      }
      var obj = {};
      var pairs = string.split('&');
      var pair, name, value;
      for (var i = 0, len = pairs.length; i < len; i++) {
        pair = pairs[i].split('=');
        name = decodeURIComponent(pair[0]);
        value = decodeURIComponent(pair[1]);
        if (overwrite !== true) {
          if (typeof obj[name] == 'undefined') {
            obj[name] = value;
          } else if (typeof obj[name] == 'string') {
            obj[name] = [obj[name]];
            obj[name].push(value);
          } else {
            obj[name].push(value);
          }
        } else {
          obj[name] = value;
        }
      }
      return obj;
    },

    /**
     * Iterates an array calling the passed function with each item, stopping if your function returns false. If the
     * passed array is not really an array, your function is called once with it.
     * The supplied function is called with (Object item, Number index, Array allItems).
     * @param {Array/NodeList/Mixed} array
     * @param {Function} fn
     * @param {Object} scope
     */
    each: function (array, fn, scope) {
      if (typeof array.length == 'undefined' || typeof array == 'string') {
        array = [array];
      }
      for (var i = 0, len = array.length; i < len; i++) {
        if (fn.call(scope || array[i], array[i], i, array) === false) {
          return i;
        }
      }
    },

    // deprecated
    combine: function () {
      var as = arguments,
        l = as.length,
        r = [];
      for (var i = 0; i < l; i++) {
        var a = as[i];
        if (Ext.isArray(a)) {
          r = r.concat(a);
        } else if (a.length !== undefined && !a.substr) {
          r = r.concat(Array.prototype.slice.call(a, 0));
        } else {
          r.push(a);
        }
      }
      return r;
    },

    /**
     * Escapes the passed string for use in a regular expression
     * @param {String} str
     * @return {String}
     */
    escapeRe: function (s) {
      return s.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
    },

    // internal
    callback: function (cb, scope, args, delay) {
      if (typeof cb == 'function') {
        if (delay) {
          cb.defer(delay, scope, args || []);
        } else {
          cb.apply(scope, args || []);
        }
      }
    },

    /**
     * Return the dom node for the passed string (id), dom node, or Ext.Element
     * @param {Mixed} el
     * @return HTMLElement
     */
    getDom: function (el) {
      if (!el || !document) {
        return null;
      }
      return el.dom
        ? el.dom
        : typeof el == 'string'
        ? document.getElementById(el)
        : el;
    },

    /**
     * Returns the current HTML document object as an {@link Ext.Element}.
     * @return Ext.Element The document
     */
    getDoc: function () {
      return Ext.get(document);
    },

    /**
     * Returns the current document body as an {@link Ext.Element}.
     * @return Ext.Element The document body
     */
    getBody: function () {
      return Ext.get(document.body || document.documentElement);
    },

    /**
     * Shorthand for {@link Ext.ComponentMgr#get}
     * @param {String} id
     * @return Ext.Component
     */
    getCmp: function (id) {
      return Ext.ComponentMgr.get(id);
    },

    /**
     * Utility method for validating that a value is numeric, returning the specified default value if it is not.
     * @param {Mixed} value Should be a number, but any type will be handled appropriately
     * @param {Number} defaultValue The value to return if the original value is non-numeric
     * @return {Number} Value, if numeric, else defaultValue
     */
    num: function (v, defaultValue) {
      v = Number(v == null || typeof v == 'boolean' ? NaN : v);
      return isNaN(v) ? defaultValue : v;
    },

    /**
     * Attempts to destroy any objects passed to it by removing all event listeners, removing them from the
     * DOM (if applicable) and calling their destroy functions (if available).  This method is primarily
     * intended for arguments of type {@link Ext.Element} and {@link Ext.Component}, but any subclass of
     * {@link Ext.util.Observable} can be passed in.  Any number of elements and/or components can be
     * passed into this function in a single call as separate arguments.
     * @param {Mixed} arg1 An {@link Ext.Element} or {@link Ext.Component} to destroy
     * @param {Mixed} arg2 (optional)
     * @param {Mixed} etc... (optional)
     */
    destroy: function () {
      for (var i = 0, a = arguments, len = a.length; i < len; i++) {
        var as = a[i];
        if (as) {
          if (typeof as.destroy == 'function') {
            as.destroy();
          } else if (as.dom) {
            as.removeAllListeners();
            as.remove();
          }
        }
      }
    },

    /**
     * Removes a DOM node from the document.  The body node will be ignored if passed in.
     * @param {HTMLElement} node The node to remove
     */
    removeNode: isIE
      ? (function () {
          var d;
          return function (n) {
            if (n && n.tagName != 'BODY') {
              d = d || document.createElement('div');
              d.appendChild(n);
              d.innerHTML = '';
            }
          };
        })()
      : function (n) {
          if (n && n.parentNode && n.tagName != 'BODY') {
            n.parentNode.removeChild(n);
          }
        },

    // inpired by a similar function in mootools library
    /**
     * Returns the type of object that is passed in. If the object passed in is null or undefined it
     * return false otherwise it returns one of the following values:<ul>
     * <li><b>string</b>: If the object passed is a string</li>
     * <li><b>number</b>: If the object passed is a number</li>
     * <li><b>boolean</b>: If the object passed is a boolean value</li>
     * <li><b>date</b>: If the object passed is a Date object</li>
     * <li><b>function</b>: If the object passed is a function reference</li>
     * <li><b>object</b>: If the object passed is an object</li>
     * <li><b>array</b>: If the object passed is an array</li>
     * <li><b>regexp</b>: If the object passed is a regular expression</li>
     * <li><b>element</b>: If the object passed is a DOM Element</li>
     * <li><b>nodelist</b>: If the object passed is a DOM NodeList</li>
     * <li><b>textnode</b>: If the object passed is a DOM text node and contains something other than whitespace</li>
     * <li><b>whitespace</b>: If the object passed is a DOM text node and contains only whitespace</li>
     * @param {Mixed} object
     * @return {String}
     */
    type: function (o) {
      if (o === undefined || o === null) {
        return false;
      }
      if (o.htmlElement) {
        return 'element';
      }
      var t = typeof o;
      if (t == 'object' && o.nodeName) {
        switch (o.nodeType) {
          case 1:
            return 'element';
          case 3:
            return /\S/.test(o.nodeValue) ? 'textnode' : 'whitespace';
        }
      }
      if (t == 'object' || t == 'function') {
        switch (o.constructor) {
          case Array:
            return 'array';
          case RegExp:
            return 'regexp';
          case Date:
            return 'date';
        }
        if (typeof o.length == 'number' && typeof o.item == 'function') {
          return 'nodelist';
        }
      }
      return t;
    },

    /**
     * Returns true if the passed value is null, undefined or an empty string.
     * @param {Mixed} value The value to test
     * @param {Boolean} allowBlank (optional) true to allow empty strings (defaults to false)
     * @return {Boolean}
     */
    isEmpty: function (v, allowBlank) {
      return v === null || v === undefined || (!allowBlank ? v === '' : false);
    },

    /**
     * Utility method for validating that a value is non-empty (i.e. i) not null, ii) not undefined, and iii) not an empty string),
     * returning the specified default value if it is.
     * @param {Mixed} value The value to test
     * @param {Mixed} defaultValue The value to return if the original value is empty
     * @param {Boolean} allowBlank (optional) true to allow empty strings (defaults to false)
     * @return {Mixed} value, if non-empty, else defaultValue
     */
    value: function (v, defaultValue, allowBlank) {
      return Ext.isEmpty(v, allowBlank) ? defaultValue : v;
    },

    /**
     * Returns true if the passed object is a JavaScript array, otherwise false.
     * @param {Object} object The object to test
     * @return {Boolean}
     */
    isArray: function (v) {
      return v && typeof v.length == 'number' && typeof v.splice == 'function';
    },

    /**
     * Returns true if the passed object is a JavaScript date object, otherwise false.
     * @param {Object} object The object to test
     * @return {Boolean}
     */
    isDate: function (v) {
      return v && typeof v.getFullYear == 'function';
    },

    /**
     * True if the detected browser is Opera.
     * @type Boolean
     */
    isOpera: isOpera,
    /**
     * True if the detected browser uses WebKit.
     * @type Boolean
     */
    isWebKit: isWebKit,
    /**
     * True if the detected browser is Chrome.
     * @type Boolean
     */
    isChrome: isChrome,
    /**
     * True if the detected browser is Safari.
     * @type Boolean
     */
    isSafari: isSafari,
    /**
     * True if the detected browser is Safari 4.x.
     * @type Boolean
     */
    isSafari4: isSafari4,
    /**
     * True if the detected browser is Safari 3.x.
     * @type Boolean
     */
    isSafari3: isSafari3,
    /**
     * True if the detected browser is Safari 2.x.
     * @type Boolean
     */
    isSafari2: isSafari2,
    /**
     * True if the detected browser is Internet Explorer.
     * @type Boolean
     */
    isIE: isIE,
    /**
     * True if the detected browser is Internet Explorer 6.x.
     * @type Boolean
     */
    isIE6: isIE6,
    /**
     * True if the detected browser is Internet Explorer 7.x.
     * @type Boolean
     */
    isIE7: isIE7,
    /**
     * True if the detected browser is Internet Explorer 8.x.
     * @type Boolean
     */
    isIE8: isIE8,
    /**
     * True if the detected browser uses the Gecko layout engine (e.g. Mozilla, Firefox).
     * @type Boolean
     */
    isGecko: isGecko,
    /**
     * True if the detected browser uses a pre-Gecko 1.9 layout engine (e.g. Firefox 2.x).
     * @type Boolean
     */
    isGecko2: isGecko2,
    /**
     * True if the detected browser uses a Gecko 1.9+ layout engine (e.g. Firefox 3.x).
     * @type Boolean
     */
    isGecko3: isGecko3,
    /**
     * True if the detected browser is Internet Explorer running in non-strict mode.
     * @type Boolean
     */
    isBorderBox: isBorderBox,
    /**
     * True if the detected platform is Linux.
     * @type Boolean
     */
    isLinux: isLinux,
    /**
     * True if the detected platform is Windows.
     * @type Boolean
     */
    isWindows: isWindows,
    /**
     * True if the detected platform is Mac OS.
     * @type Boolean
     */
    isMac: isMac,
    /**
     * True if the detected platform is Adobe Air.
     * @type Boolean
     */
    isAir: isAir,

    /**
     * By default, Ext intelligently decides whether floating elements should be shimmed. If you are using flash,
     * you may want to set this to true.
     * @type Boolean
     */
    useShims: (isIE && !(isIE7 || isIE8)) || (isMac && isGecko && !isGecko3),
  });

  // in intellij using keyword "namespace" causes parsing errors
  Ext.ns = Ext.namespace;
})();

Ext.ns(
  'Ext',
  'Ext.util',
  'Ext.grid',
  'Ext.dd',
  'Ext.tree',
  'Ext.data',
  'Ext.form',
  'Ext.menu',
  'Ext.state',
  'Ext.lib',
  'Ext.layout',
  'Ext.app',
  'Ext.ux',
);

/**
 * @class Function
 * These functions are available on every Function object (any JavaScript function).
 */
Ext.apply(Function.prototype, {
  /**
     * Creates a callback that passes arguments[0], arguments[1], arguments[2], ...
     * Call directly on any function. Example: <code>myFunction.createCallback(arg1, arg2)</code>
     * Will create a function that is bound to those 2 args. <b>If a specific scope is required in the
     * callback, use {@link #createDelegate} instead.</b> The function returned by createCallback always
     * executes in the window scope.
     * <p>This method is required when you want to pass arguments to a callback function.  If no arguments
     * are needed, you can simply pass a reference to the function as a callback (e.g., callback: myFn).
     * However, if you tried to pass a function with arguments (e.g., callback: myFn(arg1, arg2)) the function
     * would simply execute immediately when the code is parsed. Example usage:
     * <pre><code>
var sayHi = function(name){
    alert('Hi, ' + name);
}

// clicking the button alerts "Hi, Fred"
new Ext.Button({
    text: 'Say Hi',
    renderTo: Ext.getBody(),
    handler: sayHi.createCallback('Fred')
});
</code></pre>
     * @return {Function} The new function
    */
  createCallback: function (/*args...*/) {
    // make args available, in function below
    var args = arguments;
    var method = this;
    return function () {
      return method.apply(window, args);
    };
  },

  /**
     * Creates a delegate (callback) that sets the scope to obj.
     * Call directly on any function. Example: <code>this.myFunction.createDelegate(this, [arg1, arg2])</code>
     * Will create a function that is automatically scoped to obj so that the <tt>this</tt> variable inside the
     * callback points to obj. Example usage:
     * <pre><code>
var sayHi = function(name){
    // Note this use of "this.text" here.  This function expects to
    // execute within a scope that contains a text property.  In this
    // example, the "this" variable is pointing to the btn object that
    // was passed in createDelegate below.
    alert('Hi, ' + name + '. You clicked the "' + this.text + '" button.');
}

var btn = new Ext.Button({
    text: 'Say Hi',
    renderTo: Ext.getBody()
});

// This callback will execute in the scope of the
// button instance. Clicking the button alerts
// "Hi, Fred. You clicked the "Say Hi" button."
btn.on('click', sayHi.createDelegate(btn, ['Fred']));
</code></pre>
     * @param {Object} obj (optional) The object for which the scope is set
     * @param {Array} args (optional) Overrides arguments for the call. (Defaults to the arguments passed by the caller)
     * @param {Boolean/Number} appendArgs (optional) if True args are appended to call args instead of overriding,
     *                                             if a number the args are inserted at the specified position
     * @return {Function} The new function
     */
  createDelegate: function (obj, args, appendArgs) {
    var method = this;
    return function () {
      var callArgs = args || arguments;
      if (appendArgs === true) {
        callArgs = Array.prototype.slice.call(arguments, 0);
        callArgs = callArgs.concat(args);
      } else if (typeof appendArgs == 'number') {
        callArgs = Array.prototype.slice.call(arguments, 0); // copy arguments first
        var applyArgs = [appendArgs, 0].concat(args); // create method call params
        Array.prototype.splice.apply(callArgs, applyArgs); // splice them in
      }
      return method.apply(obj || window, callArgs);
    };
  },

  /**
     * Calls this function after the number of millseconds specified, optionally in a specific scope. Example usage:
     * <pre><code>
var sayHi = function(name){
    alert('Hi, ' + name);
}

// executes immediately:
sayHi('Fred');

// executes after 2 seconds:
sayHi.defer(2000, this, ['Fred']);

// this syntax is sometimes useful for deferring
// execution of an anonymous function:
(function(){
    alert('Anonymous');
}).defer(100);
</code></pre>
     * @param {Number} millis The number of milliseconds for the setTimeout call (if 0 the function is executed immediately)
     * @param {Object} obj (optional) The object for which the scope is set
     * @param {Array} args (optional) Overrides arguments for the call. (Defaults to the arguments passed by the caller)
     * @param {Boolean/Number} appendArgs (optional) if True args are appended to call args instead of overriding,
     *                                             if a number the args are inserted at the specified position
     * @return {Number} The timeout id that can be used with clearTimeout
     */
  defer: function (millis, obj, args, appendArgs) {
    var fn = this.createDelegate(obj, args, appendArgs);
    if (millis) {
      return setTimeout(fn, millis);
    }
    fn();
    return 0;
  },

  /**
     * Create a combined function call sequence of the original function + the passed function.
     * The resulting function returns the results of the original function.
     * The passed fcn is called with the parameters of the original function. Example usage:
     * <pre><code>
var sayHi = function(name){
    alert('Hi, ' + name);
}

sayHi('Fred'); // alerts "Hi, Fred"

var sayGoodbye = sayHi.createSequence(function(name){
    alert('Bye, ' + name);
});

sayGoodbye('Fred'); // both alerts show
</code></pre>
     * @param {Function} fcn The function to sequence
     * @param {Object} scope (optional) The scope of the passed fcn (Defaults to scope of original function or window)
     * @return {Function} The new function
     */
  createSequence: function (fcn, scope) {
    if (typeof fcn != 'function') {
      return this;
    }
    var method = this;
    return function () {
      var retval = method.apply(this || window, arguments);
      fcn.apply(scope || this || window, arguments);
      return retval;
    };
  },

  /**
     * Creates an interceptor function. The passed fcn is called before the original one. If it returns false,
     * the original one is not called. The resulting function returns the results of the original function.
     * The passed fcn is called with the parameters of the original function. Example usage:
     * <pre><code>
var sayHi = function(name){
    alert('Hi, ' + name);
}

sayHi('Fred'); // alerts "Hi, Fred"

// create a new function that validates input without
// directly modifying the original function:
var sayHiToFriend = sayHi.createInterceptor(function(name){
    return name == 'Brian';
});

sayHiToFriend('Fred');  // no alert
sayHiToFriend('Brian'); // alerts "Hi, Brian"
</code></pre>
     * @param {Function} fcn The function to call before the original
     * @param {Object} scope (optional) The scope of the passed fcn (Defaults to scope of original function or window)
     * @return {Function} The new function
     */
  createInterceptor: function (fcn, scope) {
    if (typeof fcn != 'function') {
      return this;
    }
    var method = this;
    return function () {
      fcn.target = this;
      fcn.method = method;
      if (fcn.apply(scope || this || window, arguments) === false) {
        return;
      }
      return method.apply(this || window, arguments);
    };
  },
});

/**
 * @class String
 * These functions are available as static methods on the JavaScript String object.
 */
Ext.applyIf(String, {
  /**
   * Escapes the passed string for ' and \
   * @param {String} string The string to escape
   * @return {String} The escaped string
   * @static
   */
  escape: function (string) {
    return string.replace(/('|\\)/g, '\\$1');
  },

  /**
     * Pads the left side of a string with a specified character.  This is especially useful
     * for normalizing number and date strings.  Example usage:
     * <pre><code>
var s = String.leftPad('123', 5, '0');
// s now contains the string: '00123'
</code></pre>
     * @param {String} string The original string
     * @param {Number} size The total length of the output string
     * @param {String} char (optional) The character with which to pad the original string (defaults to empty string " ")
     * @return {String} The padded string
     * @static
     */
  leftPad: function (val, size, ch) {
    var result = new String(val);
    if (!ch) {
      ch = ' ';
    }
    while (result.length < size) {
      result = ch + result;
    }
    return result.toString();
  },

  /**
     * Allows you to define a tokenized string and pass an arbitrary number of arguments to replace the tokens.  Each
     * token must be unique, and must increment in the format {0}, {1}, etc.  Example usage:
     * <pre><code>
var cls = 'my-class', text = 'Some text';
var s = String.format('&lt;div class="{0}">{1}&lt;/div>', cls, text);
// s now contains the string: '&lt;div class="my-class">Some text&lt;/div>'
</code></pre>
     * @param {String} string The tokenized string to be formatted
     * @param {String} value1 The value to replace token {0}
     * @param {String} value2 Etc...
     * @return {String} The formatted string
     * @static
     */
  format: function (format) {
    var args = Array.prototype.slice.call(arguments, 1);
    return format.replace(/\{(\d+)\}/g, function (m, i) {
      return args[i];
    });
  },
});

/**
 * Utility function that allows you to easily switch a string between two alternating values.  The passed value
 * is compared to the current string, and if they are equal, the other value that was passed in is returned.  If
 * they are already different, the first value passed in is returned.  Note that this method returns the new value
 * but does not change the current string.
 * <pre><code>
// alternate sort directions
sort = sort.toggle('ASC', 'DESC');

// instead of conditional logic:
sort = (sort == 'ASC' ? 'DESC' : 'ASC');
</code></pre>
 * @param {String} value The value to compare to the current string
 * @param {String} other The new value to use if the string already equals the first value passed in
 * @return {String} The new value
 */
String.prototype.toggle = function (value, other) {
  return this == value ? other : value;
};

/**
 * Trims whitespace from either end of a string, leaving spaces within the string intact.  Example:
 * <pre><code>
var s = '  foo bar  ';
alert('-' + s + '-');         //alerts "- foo bar -"
alert('-' + s.trim() + '-');  //alerts "-foo bar-"
</code></pre>
 * @return {String} The trimmed string
 */
String.prototype.trim = (function () {
  var re = /^\s+|\s+$/g;
  return function () {
    return this.replace(re, '');
  };
})();
/**
 * @class Number
 */
Ext.applyIf(Number.prototype, {
  /**
   * Checks whether or not the current number is within a desired range.  If the number is already within the
   * range it is returned, otherwise the min or max value is returned depending on which side of the range is
   * exceeded.  Note that this method returns the constrained value but does not change the current number.
   * @param {Number} min The minimum number in the range
   * @param {Number} max The maximum number in the range
   * @return {Number} The constrained value if outside the range, otherwise the current value
   */
  constrain: function (min, max) {
    return Math.min(Math.max(this, min), max);
  },
});
/**
 * @class Array
 */
Ext.applyIf(Array.prototype, {
  /**
   * Checks whether or not the specified object exists in the array.
   * @param {Object} o The object to check for
   * @return {Number} The index of o in the array (or -1 if it is not found)
   */
  indexOf: function (o) {
    for (var i = 0, len = this.length; i < len; i++) {
      if (this[i] == o) return i;
    }
    return -1;
  },

  /**
   * Removes the specified object from the array.  If the object is not found nothing happens.
   * @param {Object} o The object to remove
   * @return {Array} this array
   */
  remove: function (o) {
    var index = this.indexOf(o);
    if (index != -1) {
      this.splice(index, 1);
    }
    return this;
  },
});

/**
 Returns the number of milliseconds between this date and date
 @param {Date} date (optional) Defaults to now
 @return {Number} The diff in milliseconds
 @member Date getElapsed
 */
Date.prototype.getElapsed = function (date) {
  return Math.abs((date || new Date()).getTime() - this.getTime());
};
/*
 * Ext JS Library 2.3.0
 * Copyright(c) 2006-2009, Ext JS, LLC.
 * licensing@extjs.com
 *
 * http://extjs.com/license
 */

(function () {
  var libFlyweight;

  Ext.lib.Dom = {
    getViewWidth: function (full) {
      return full ? this.getDocumentWidth() : this.getViewportWidth();
    },

    getViewHeight: function (full) {
      return full ? this.getDocumentHeight() : this.getViewportHeight();
    },

    getDocumentHeight: function () {
      var scrollHeight =
        document.compatMode != 'CSS1Compat'
          ? document.body.scrollHeight
          : document.documentElement.scrollHeight;
      return Math.max(scrollHeight, this.getViewportHeight());
    },

    getDocumentWidth: function () {
      var scrollWidth =
        document.compatMode != 'CSS1Compat'
          ? document.body.scrollWidth
          : document.documentElement.scrollWidth;
      return Math.max(scrollWidth, this.getViewportWidth());
    },

    getViewportHeight: function () {
      if (Ext.isIE) {
        return Ext.isStrict
          ? document.documentElement.clientHeight
          : document.body.clientHeight;
      } else {
        return self.innerHeight;
      }
    },

    getViewportWidth: function () {
      if (Ext.isIE) {
        return Ext.isStrict
          ? document.documentElement.clientWidth
          : document.body.clientWidth;
      } else {
        return self.innerWidth;
      }
    },

    isAncestor: function (p, c) {
      p = Ext.getDom(p);
      c = Ext.getDom(c);
      if (!p || !c) {
        return false;
      }

      if (p.contains && !Ext.isWebKit) {
        return p.contains(c);
      } else if (p.compareDocumentPosition) {
        return !!(p.compareDocumentPosition(c) & 16);
      } else {
        var parent = c.parentNode;
        while (parent) {
          if (parent == p) {
            return true;
          } else if (
            !parent.tagName ||
            parent.tagName.toUpperCase() == 'HTML'
          ) {
            return false;
          }
          parent = parent.parentNode;
        }
        return false;
      }
    },

    getRegion: function (el) {
      return Ext.lib.Region.getRegion(el);
    },

    getY: function (el) {
      return this.getXY(el)[1];
    },

    getX: function (el) {
      return this.getXY(el)[0];
    },

    getXY: function (el) {
      var p,
        pe,
        b,
        scroll,
        bd = document.body || document.documentElement;
      el = Ext.getDom(el);

      if (el == bd) {
        return [0, 0];
      }

      if (el.getBoundingClientRect) {
        b = el.getBoundingClientRect();
        scroll = fly(document).getScroll();
        return [b.left + scroll.left, b.top + scroll.top];
      }
      var x = 0,
        y = 0;

      p = el;

      var hasAbsolute = fly(el).getStyle('position') == 'absolute';

      while (p) {
        x += p.offsetLeft;
        y += p.offsetTop;

        if (!hasAbsolute && fly(p).getStyle('position') == 'absolute') {
          hasAbsolute = true;
        }

        if (Ext.isGecko) {
          pe = fly(p);

          var bt = parseInt(pe.getStyle('borderTopWidth'), 10) || 0;
          var bl = parseInt(pe.getStyle('borderLeftWidth'), 10) || 0;

          x += bl;
          y += bt;

          if (p != el && pe.getStyle('overflow') != 'visible') {
            x += bl;
            y += bt;
          }
        }
        p = p.offsetParent;
      }

      if (Ext.isWebKit && hasAbsolute) {
        x -= bd.offsetLeft;
        y -= bd.offsetTop;
      }

      if (Ext.isGecko && !hasAbsolute) {
        var dbd = fly(bd);
        x += parseInt(dbd.getStyle('borderLeftWidth'), 10) || 0;
        y += parseInt(dbd.getStyle('borderTopWidth'), 10) || 0;
      }

      p = el.parentNode;
      while (p && p != bd) {
        if (
          !Ext.isOpera ||
          (p.tagName != 'TR' && fly(p).getStyle('display') != 'inline')
        ) {
          x -= p.scrollLeft;
          y -= p.scrollTop;
        }
        p = p.parentNode;
      }
      return [x, y];
    },

    setXY: function (el, xy) {
      el = Ext.fly(el, '_setXY');
      el.position();
      var pts = el.translatePoints(xy);
      if (xy[0] !== false) {
        el.dom.style.left = pts.left + 'px';
      }
      if (xy[1] !== false) {
        el.dom.style.top = pts.top + 'px';
      }
    },

    setX: function (el, x) {
      this.setXY(el, [x, false]);
    },

    setY: function (el, y) {
      this.setXY(el, [false, y]);
    },
  };

  /*
   * Portions of this file are based on pieces of Yahoo User Interface Library
   * Copyright (c) 2007, Yahoo! Inc. All rights reserved.
   * YUI licensed under the BSD License:
   * http://developer.yahoo.net/yui/license.txt
   */
  Ext.lib.Event = (function () {
    var loadComplete = false;
    var listeners = [];
    var unloadListeners = [];
    var retryCount = 0;
    var onAvailStack = [];
    var counter = 0;
    var lastError = null;

    return {
      POLL_RETRYS: 200,
      POLL_INTERVAL: 20,
      EL: 0,
      TYPE: 1,
      FN: 2,
      WFN: 3,
      OBJ: 3,
      ADJ_SCOPE: 4,
      _interval: null,

      startInterval: function () {
        if (!this._interval) {
          var self = this;
          var callback = function () {
            self._tryPreloadAttach();
          };
          this._interval = setInterval(callback, this.POLL_INTERVAL);
        }
      },

      onAvailable: function (p_id, p_fn, p_obj, p_override) {
        onAvailStack.push({
          id: p_id,
          fn: p_fn,
          obj: p_obj,
          override: p_override,
          checkReady: false,
        });

        retryCount = this.POLL_RETRYS;
        this.startInterval();
      },

      addListener: function (el, eventName, fn) {
        el = Ext.getDom(el);
        if (!el || !fn) {
          return false;
        }

        if ('unload' == eventName) {
          unloadListeners[unloadListeners.length] = [el, eventName, fn];
          return true;
        }

        // prevent unload errors with simple check
        var wrappedFn = function (e) {
          return typeof Ext != 'undefined'
            ? fn(Ext.lib.Event.getEvent(e))
            : false;
        };

        var li = [el, eventName, fn, wrappedFn];

        var index = listeners.length;
        listeners[index] = li;

        this.doAdd(el, eventName, wrappedFn, false);
        return true;
      },

      removeListener: function (el, eventName, fn) {
        var i, len;

        el = Ext.getDom(el);

        if (!fn) {
          return this.purgeElement(el, false, eventName);
        }

        if ('unload' == eventName) {
          for (i = 0, len = unloadListeners.length; i < len; i++) {
            var li = unloadListeners[i];
            if (li && li[0] == el && li[1] == eventName && li[2] == fn) {
              unloadListeners.splice(i, 1);
              return true;
            }
          }

          return false;
        }

        var cacheItem = null;

        var index = arguments[3];

        if ('undefined' == typeof index) {
          index = this._getCacheIndex(el, eventName, fn);
        }

        if (index >= 0) {
          cacheItem = listeners[index];
        }

        if (!el || !cacheItem) {
          return false;
        }

        this.doRemove(el, eventName, cacheItem[this.WFN], false);

        delete listeners[index][this.WFN];
        delete listeners[index][this.FN];
        listeners.splice(index, 1);

        return true;
      },

      getTarget: function (ev, resolveTextNode) {
        ev = ev.browserEvent || ev;
        var t = ev.target || ev.srcElement;
        return this.resolveTextNode(t);
      },

      resolveTextNode: function (node) {
        if (Ext.isWebKit && node && 3 == node.nodeType) {
          return node.parentNode;
        } else {
          return node;
        }
      },

      getPageX: function (ev) {
        ev = ev.browserEvent || ev;
        var x = ev.pageX;
        if (!x && 0 !== x) {
          x = ev.clientX || 0;

          if (Ext.isIE) {
            x += this.getScroll()[1];
          }
        }

        return x;
      },

      getPageY: function (ev) {
        ev = ev.browserEvent || ev;
        var y = ev.pageY;
        if (!y && 0 !== y) {
          y = ev.clientY || 0;

          if (Ext.isIE) {
            y += this.getScroll()[0];
          }
        }

        return y;
      },

      getXY: function (ev) {
        ev = ev.browserEvent || ev;
        return [this.getPageX(ev), this.getPageY(ev)];
      },

      getRelatedTarget: function (ev) {
        ev = ev.browserEvent || ev;
        var t = ev.relatedTarget;
        if (!t) {
          if (ev.type == 'mouseout') {
            t = ev.toElement;
          } else if (ev.type == 'mouseover') {
            t = ev.fromElement;
          }
        }

        return this.resolveTextNode(t);
      },

      getTime: function (ev) {
        ev = ev.browserEvent || ev;
        if (!ev.time) {
          var t = new Date().getTime();
          try {
            ev.time = t;
          } catch (ex) {
            this.lastError = ex;
            return t;
          }
        }

        return ev.time;
      },

      stopEvent: function (ev) {
        this.stopPropagation(ev);
        this.preventDefault(ev);
      },

      stopPropagation: function (ev) {
        ev = ev.browserEvent || ev;
        if (ev.stopPropagation) {
          ev.stopPropagation();
        } else {
          ev.cancelBubble = true;
        }
      },

      preventDefault: function (ev) {
        ev = ev.browserEvent || ev;
        if (ev.preventDefault) {
          ev.preventDefault();
        } else {
          ev.returnValue = false;
        }
      },

      getEvent: function (e) {
        var ev = e || window.event;
        if (!ev) {
          var c = this.getEvent.caller;
          while (c) {
            ev = c.arguments[0];
            if (ev && Event == ev.constructor) {
              break;
            }
            c = c.caller;
          }
        }
        return ev;
      },

      getCharCode: function (ev) {
        ev = ev.browserEvent || ev;
        return ev.charCode || ev.keyCode || 0;
      },

      _getCacheIndex: function (el, eventName, fn) {
        for (var i = 0, len = listeners.length; i < len; ++i) {
          var li = listeners[i];
          if (
            li &&
            li[this.FN] == fn &&
            li[this.EL] == el &&
            li[this.TYPE] == eventName
          ) {
            return i;
          }
        }

        return -1;
      },

      elCache: {},

      getEl: function (id) {
        return document.getElementById(id);
      },

      clearCache: function () {},

      _load: function (e) {
        loadComplete = true;
        var EU = Ext.lib.Event;

        if (Ext.isIE) {
          EU.doRemove(window, 'load', EU._load);
        }
      },

      _tryPreloadAttach: function () {
        if (this.locked) {
          return false;
        }

        this.locked = true;

        var tryAgain = !loadComplete;
        if (!tryAgain) {
          tryAgain = retryCount > 0;
        }

        var notAvail = [];
        for (var i = 0, len = onAvailStack.length; i < len; ++i) {
          var item = onAvailStack[i];
          if (item) {
            var el = this.getEl(item.id);

            if (el) {
              if (
                !item.checkReady ||
                loadComplete ||
                el.nextSibling ||
                (document && document.body)
              ) {
                var scope = el;
                if (item.override) {
                  if (item.override === true) {
                    scope = item.obj;
                  } else {
                    scope = item.override;
                  }
                }
                item.fn.call(scope, item.obj);
                onAvailStack[i] = null;
              }
            } else {
              notAvail.push(item);
            }
          }
        }

        retryCount = notAvail.length === 0 ? 0 : retryCount - 1;

        if (tryAgain) {
          this.startInterval();
        } else {
          clearInterval(this._interval);
          this._interval = null;
        }

        this.locked = false;

        return true;
      },

      purgeElement: function (el, recurse, eventName) {
        var elListeners = this.getListeners(el, eventName);
        if (elListeners) {
          for (var i = 0, len = elListeners.length; i < len; ++i) {
            var l = elListeners[i];
            this.removeListener(el, l.type, l.fn);
          }
        }

        if (recurse && el && el.childNodes) {
          for (i = 0, len = el.childNodes.length; i < len; ++i) {
            this.purgeElement(el.childNodes[i], recurse, eventName);
          }
        }
      },

      getListeners: function (el, eventName) {
        var results = [],
          searchLists;
        if (!eventName) {
          searchLists = [listeners, unloadListeners];
        } else if (eventName == 'unload') {
          searchLists = [unloadListeners];
        } else {
          searchLists = [listeners];
        }

        for (var j = 0; j < searchLists.length; ++j) {
          var searchList = searchLists[j];
          if (searchList && searchList.length > 0) {
            for (var i = 0, len = searchList.length; i < len; ++i) {
              var l = searchList[i];
              if (
                l &&
                l[this.EL] === el &&
                (!eventName || eventName === l[this.TYPE])
              ) {
                results.push({
                  type: l[this.TYPE],
                  fn: l[this.FN],
                  obj: l[this.OBJ],
                  adjust: l[this.ADJ_SCOPE],
                  index: i,
                });
              }
            }
          }
        }

        return results.length ? results : null;
      },

      _unload: function (e) {
        var EU = Ext.lib.Event,
          i,
          j,
          l,
          len,
          index;

        for (i = 0, len = unloadListeners.length; i < len; ++i) {
          l = unloadListeners[i];
          if (l) {
            var scope = window;
            if (l[EU.ADJ_SCOPE]) {
              if (l[EU.ADJ_SCOPE] === true) {
                scope = l[EU.OBJ];
              } else {
                scope = l[EU.ADJ_SCOPE];
              }
            }
            l[EU.FN].call(scope, EU.getEvent(e), l[EU.OBJ]);
            unloadListeners[i] = null;
            l = null;
            scope = null;
          }
        }

        unloadListeners = null;

        if (listeners && listeners.length > 0) {
          j = listeners.length;
          while (j) {
            index = j - 1;
            l = listeners[index];
            if (l) {
              EU.removeListener(l[EU.EL], l[EU.TYPE], l[EU.FN], index);
            }
            j = j - 1;
          }
          l = null;

          EU.clearCache();
        }

        EU.doRemove(window, 'unload', EU._unload);
      },

      getScroll: function () {
        var dd = document.documentElement,
          db = document.body;
        if (dd && (dd.scrollTop || dd.scrollLeft)) {
          return [dd.scrollTop, dd.scrollLeft];
        } else if (db) {
          return [db.scrollTop, db.scrollLeft];
        } else {
          return [0, 0];
        }
      },

      doAdd: (function () {
        if (window.addEventListener) {
          return function (el, eventName, fn, capture) {
            el.addEventListener(eventName, fn, capture);
          };
        } else if (window.attachEvent) {
          return function (el, eventName, fn, capture) {
            el.attachEvent('on' + eventName, fn);
          };
        } else {
          return function () {};
        }
      })(),

      doRemove: (function () {
        if (window.removeEventListener) {
          return function (el, eventName, fn, capture) {
            el.removeEventListener(eventName, fn, capture);
          };
        } else if (window.detachEvent) {
          return function (el, eventName, fn) {
            el.detachEvent('on' + eventName, fn);
          };
        } else {
          return function () {};
        }
      })(),
    };
  })();

  var E = Ext.lib.Event;
  E.on = E.addListener;
  E.un = E.removeListener;
  if (document && document.body) {
    E._load();
  } else {
    E.doAdd(window, 'load', E._load);
  }
  E.doAdd(window, 'unload', E._unload);
  E._tryPreloadAttach();

  Ext.lib.Ajax = {
    request: function (method, uri, cb, data, options) {
      if (options) {
        var hs = options.headers;
        if (hs) {
          for (var h in hs) {
            if (hs.hasOwnProperty(h)) {
              this.initHeader(h, hs[h], false);
            }
          }
        }
        if (options.xmlData) {
          if (!hs || !hs['Content-Type']) {
            this.initHeader('Content-Type', 'text/xml', false);
          }
          method = method ? method : options.method ? options.method : 'POST';
          data = options.xmlData;
        } else if (options.jsonData) {
          if (!hs || !hs['Content-Type']) {
            this.initHeader('Content-Type', 'application/json', false);
          }
          method = method ? method : options.method ? options.method : 'POST';
          data =
            typeof options.jsonData == 'object'
              ? Ext.encode(options.jsonData)
              : options.jsonData;
        }
      }

      return this.asyncRequest(method, uri, cb, data);
    },

    serializeForm: function (form) {
      if (typeof form == 'string') {
        form = document.getElementById(form) || document.forms[form];
      }

      var el,
        name,
        val,
        disabled,
        data = '',
        hasSubmit = false;
      for (var i = 0; i < form.elements.length; i++) {
        el = form.elements[i];
        disabled = form.elements[i].disabled;
        name = form.elements[i].name;
        val = form.elements[i].value;

        if (!disabled && name) {
          switch (el.type) {
            case 'select-one':
            case 'select-multiple':
              for (var j = 0; j < el.options.length; j++) {
                if (el.options[j].selected) {
                  var opt = el.options[j],
                    sel = (
                      opt.hasAttribute
                        ? opt.hasAttribute('value')
                        : opt.getAttributeNode('value').specified
                    )
                      ? opt.value
                      : opt.text;
                  data +=
                    encodeURIComponent(name) +
                    '=' +
                    encodeURIComponent(sel) +
                    '&';
                }
              }
              break;
            case 'radio':
            case 'checkbox':
              if (el.checked) {
                data +=
                  encodeURIComponent(name) +
                  '=' +
                  encodeURIComponent(val) +
                  '&';
              }
              break;
            case 'file':

            case undefined:

            case 'reset':

            case 'button':
              break;
            case 'submit':
              if (hasSubmit == false) {
                data +=
                  encodeURIComponent(name) +
                  '=' +
                  encodeURIComponent(val) +
                  '&';
                hasSubmit = true;
              }
              break;
            default:
              data +=
                encodeURIComponent(name) + '=' + encodeURIComponent(val) + '&';
              break;
          }
        }
      }
      data = data.substr(0, data.length - 1);
      return data;
    },

    headers: {},

    hasHeaders: false,

    useDefaultHeader: true,

    defaultPostHeader: 'application/x-www-form-urlencoded; charset=UTF-8',

    useDefaultXhrHeader: true,

    defaultXhrHeader: 'XMLHttpRequest',

    hasDefaultHeaders: true,

    defaultHeaders: {},

    poll: {},

    timeout: {},

    pollInterval: 50,

    transactionId: 0,

    setProgId: function (id) {
      this.activeX.unshift(id);
    },

    setDefaultPostHeader: function (b) {
      this.useDefaultHeader = b;
    },

    setDefaultXhrHeader: function (b) {
      this.useDefaultXhrHeader = b;
    },

    setPollingInterval: function (i) {
      if (typeof i == 'number' && isFinite(i)) {
        this.pollInterval = i;
      }
    },

    createXhrObject: function (transactionId) {
      var obj, http;
      try {
        http = new XMLHttpRequest();

        obj = { conn: http, tId: transactionId };
      } catch (e) {
        for (var i = 0; i < this.activeX.length; ++i) {
          try {
            http = new ActiveXObject(this.activeX[i]);

            obj = { conn: http, tId: transactionId };
            break;
          } catch (e) {}
        }
      } finally {
        return obj;
      }
    },

    getConnectionObject: function () {
      var o;
      var tId = this.transactionId;

      try {
        o = this.createXhrObject(tId);
        if (o) {
          this.transactionId++;
        }
      } catch (e) {
      } finally {
        return o;
      }
    },

    asyncRequest: function (method, uri, callback, postData) {
      var o = this.getConnectionObject();

      if (!o) {
        return null;
      } else {
        o.conn.open(method, uri, true);

        if (this.useDefaultXhrHeader) {
          if (!this.defaultHeaders['X-Requested-With']) {
            this.initHeader('X-Requested-With', this.defaultXhrHeader, true);
          }
        }

        if (
          postData &&
          this.useDefaultHeader &&
          (!this.hasHeaders || !this.headers['Content-Type'])
        ) {
          this.initHeader('Content-Type', this.defaultPostHeader);
        }

        if (this.hasDefaultHeaders || this.hasHeaders) {
          this.setHeader(o);
        }

        this.handleReadyState(o, callback);
        o.conn.send(postData || null);

        return o;
      }
    },

    handleReadyState: function (o, callback) {
      var oConn = this;

      if (callback && callback.timeout) {
        this.timeout[o.tId] = window.setTimeout(function () {
          oConn.abort(o, callback, true);
        }, callback.timeout);
      }

      this.poll[o.tId] = window.setInterval(function () {
        if (o.conn && o.conn.readyState == 4) {
          window.clearInterval(oConn.poll[o.tId]);
          delete oConn.poll[o.tId];

          if (callback && callback.timeout) {
            window.clearTimeout(oConn.timeout[o.tId]);
            delete oConn.timeout[o.tId];
          }

          oConn.handleTransactionResponse(o, callback);
        }
      }, this.pollInterval);
    },

    handleTransactionResponse: function (o, callback, isAbort) {
      if (!callback) {
        this.releaseObject(o);
        return;
      }

      var httpStatus, responseObject;

      try {
        if (o.conn.status !== undefined && o.conn.status != 0) {
          httpStatus = o.conn.status;
        } else {
          httpStatus = 13030;
        }
      } catch (e) {
        httpStatus = 13030;
      }

      if (
        (httpStatus >= 200 && httpStatus < 300) ||
        (Ext.isIE && httpStatus == 1223)
      ) {
        responseObject = this.createResponseObject(o, callback.argument);
        if (callback.success) {
          if (!callback.scope) {
            callback.success(responseObject);
          } else {
            callback.success.apply(callback.scope, [responseObject]);
          }
        }
      } else {
        switch (httpStatus) {
          case 12002:
          case 12029:
          case 12030:
          case 12031:
          case 12152:
          case 13030:
            responseObject = this.createExceptionObject(
              o.tId,
              callback.argument,
              isAbort ? isAbort : false,
            );
            if (callback.failure) {
              if (!callback.scope) {
                callback.failure(responseObject);
              } else {
                callback.failure.apply(callback.scope, [responseObject]);
              }
            }
            break;
          default:
            responseObject = this.createResponseObject(o, callback.argument);
            if (callback.failure) {
              if (!callback.scope) {
                callback.failure(responseObject);
              } else {
                callback.failure.apply(callback.scope, [responseObject]);
              }
            }
        }
      }

      this.releaseObject(o);
      responseObject = null;
    },

    createResponseObject: function (o, callbackArg) {
      var obj = {};
      var headerObj = {};

      try {
        var headerStr = o.conn.getAllResponseHeaders();
        var header = headerStr.split('\n');
        for (var i = 0; i < header.length; i++) {
          var delimitPos = header[i].indexOf(':');
          if (delimitPos != -1) {
            headerObj[header[i].substring(0, delimitPos)] = header[i].substring(
              delimitPos + 2,
            );
          }
        }
      } catch (e) {}

      obj.tId = o.tId;
      obj.status = o.conn.status;
      obj.statusText = o.conn.statusText;
      obj.getResponseHeader = function (header) {
        return headerObj[header];
      };
      obj.getAllResponseHeaders = function () {
        return headerStr;
      };
      obj.responseText = o.conn.responseText;
      obj.responseXML = o.conn.responseXML;

      if (typeof callbackArg !== undefined) {
        obj.argument = callbackArg;
      }

      return obj;
    },

    createExceptionObject: function (tId, callbackArg, isAbort) {
      var COMM_CODE = 0;
      var COMM_ERROR = 'communication failure';
      var ABORT_CODE = -1;
      var ABORT_ERROR = 'transaction aborted';

      var obj = {};

      obj.tId = tId;
      if (isAbort) {
        obj.status = ABORT_CODE;
        obj.statusText = ABORT_ERROR;
      } else {
        obj.status = COMM_CODE;
        obj.statusText = COMM_ERROR;
      }

      if (callbackArg) {
        obj.argument = callbackArg;
      }

      return obj;
    },

    initHeader: function (label, value, isDefault) {
      var headerObj = isDefault ? this.defaultHeaders : this.headers;

      if (headerObj[label] === undefined) {
        headerObj[label] = value;
      } else {
        headerObj[label] = value + ',' + headerObj[label];
      }

      if (isDefault) {
        this.hasDefaultHeaders = true;
      } else {
        this.hasHeaders = true;
      }
    },

    setHeader: function (o) {
      if (this.hasDefaultHeaders) {
        for (var prop in this.defaultHeaders) {
          if (this.defaultHeaders.hasOwnProperty(prop)) {
            o.conn.setRequestHeader(prop, this.defaultHeaders[prop]);
          }
        }
      }

      if (this.hasHeaders) {
        for (var prop in this.headers) {
          if (this.headers.hasOwnProperty(prop)) {
            o.conn.setRequestHeader(prop, this.headers[prop]);
          }
        }
        this.headers = {};
        this.hasHeaders = false;
      }
    },

    resetDefaultHeaders: function () {
      delete this.defaultHeaders;
      this.defaultHeaders = {};
      this.hasDefaultHeaders = false;
    },

    abort: function (o, callback, isTimeout) {
      if (this.isCallInProgress(o)) {
        o.conn.abort();
        window.clearInterval(this.poll[o.tId]);
        delete this.poll[o.tId];
        if (isTimeout) {
          delete this.timeout[o.tId];
        }

        this.handleTransactionResponse(o, callback, true);

        return true;
      } else {
        return false;
      }
    },

    isCallInProgress: function (o) {
      if (o.conn) {
        return o.conn.readyState != 4 && o.conn.readyState != 0;
      } else {
        return false;
      }
    },

    releaseObject: function (o) {
      o.conn = null;

      o = null;
    },

    activeX: ['MSXML2.XMLHTTP.3.0', 'MSXML2.XMLHTTP', 'Microsoft.XMLHTTP'],
  };

  Ext.lib.Region = function (t, r, b, l) {
    this.top = t;
    this[1] = t;
    this.right = r;
    this.bottom = b;
    this.left = l;
    this[0] = l;
  };

  Ext.lib.Region.prototype = {
    contains: function (region) {
      return (
        region.left >= this.left &&
        region.right <= this.right &&
        region.top >= this.top &&
        region.bottom <= this.bottom
      );
    },

    getArea: function () {
      return (this.bottom - this.top) * (this.right - this.left);
    },

    intersect: function (region) {
      var t = Math.max(this.top, region.top);
      var r = Math.min(this.right, region.right);
      var b = Math.min(this.bottom, region.bottom);
      var l = Math.max(this.left, region.left);

      if (b >= t && r >= l) {
        return new Ext.lib.Region(t, r, b, l);
      } else {
        return null;
      }
    },
    union: function (region) {
      var t = Math.min(this.top, region.top);
      var r = Math.max(this.right, region.right);
      var b = Math.max(this.bottom, region.bottom);
      var l = Math.min(this.left, region.left);

      return new Ext.lib.Region(t, r, b, l);
    },

    constrainTo: function (r) {
      this.top = this.top.constrain(r.top, r.bottom);
      this.bottom = this.bottom.constrain(r.top, r.bottom);
      this.left = this.left.constrain(r.left, r.right);
      this.right = this.right.constrain(r.left, r.right);
      return this;
    },

    adjust: function (t, l, b, r) {
      this.top += t;
      this.left += l;
      this.right += r;
      this.bottom += b;
      return this;
    },
  };

  Ext.lib.Region.getRegion = function (el) {
    var p = Ext.lib.Dom.getXY(el);

    var t = p[1];
    var r = p[0] + el.offsetWidth;
    var b = p[1] + el.offsetHeight;
    var l = p[0];

    return new Ext.lib.Region(t, r, b, l);
  };

  Ext.lib.Point = function (x, y) {
    if (Ext.isArray(x)) {
      y = x[1];
      x = x[0];
    }
    this.x = this.right = this.left = this[0] = x;
    this.y = this.top = this.bottom = this[1] = y;
  };

  Ext.lib.Point.prototype = new Ext.lib.Region();

  Ext.lib.Anim = {
    scroll: function (el, args, duration, easing, cb, scope) {
      return this.run(el, args, duration, easing, cb, scope, Ext.lib.Scroll);
    },

    motion: function (el, args, duration, easing, cb, scope) {
      return this.run(el, args, duration, easing, cb, scope, Ext.lib.Motion);
    },

    color: function (el, args, duration, easing, cb, scope) {
      return this.run(el, args, duration, easing, cb, scope, Ext.lib.ColorAnim);
    },

    run: function (el, args, duration, easing, cb, scope, type) {
      type = type || Ext.lib.AnimBase;
      if (typeof easing == 'string') {
        easing = Ext.lib.Easing[easing];
      }
      var anim = new type(el, args, duration, easing);
      anim.animateX(function () {
        Ext.callback(cb, scope);
      });
      return anim;
    },
  };

  function fly(el) {
    if (!libFlyweight) {
      libFlyweight = new Ext.Element.Flyweight();
    }
    libFlyweight.dom = el;
    return libFlyweight;
  }

  if (Ext.isIE) {
    function fnCleanUp() {
      var p = Function.prototype;
      delete p.createSequence;
      delete p.defer;
      delete p.createDelegate;
      delete p.createCallback;
      delete p.createInterceptor;

      window.detachEvent('onunload', fnCleanUp);
    }
    window.attachEvent('onunload', fnCleanUp);
  }

  Ext.lib.AnimBase = function (el, attributes, duration, method) {
    if (el) {
      this.init(el, attributes, duration, method);
    }
  };

  Ext.lib.AnimBase.prototype = {
    toString: function () {
      var el = this.getEl();
      var id = el.id || el.tagName;
      return 'Anim ' + id;
    },

    patterns: {
      noNegatives: /width|height|opacity|padding/i,
      offsetAttribute: /^((width|height)|(top|left))$/,
      defaultUnit: /width|height|top$|bottom$|left$|right$/i,
      offsetUnit: /\d+(em|%|en|ex|pt|in|cm|mm|pc)$/i,
    },

    doMethod: function (attr, start, end) {
      return this.method(
        this.currentFrame,
        start,
        end - start,
        this.totalFrames,
      );
    },

    setAttribute: function (attr, val, unit) {
      if (this.patterns.noNegatives.test(attr)) {
        val = val > 0 ? val : 0;
      }

      Ext.fly(this.getEl(), '_anim').setStyle(attr, val + unit);
    },

    getAttribute: function (attr) {
      var el = this.getEl();
      var val = fly(el).getStyle(attr);

      if (val !== 'auto' && !this.patterns.offsetUnit.test(val)) {
        return parseFloat(val);
      }

      var a = this.patterns.offsetAttribute.exec(attr) || [];
      var pos = !!a[3];
      var box = !!a[2];

      if (box || (fly(el).getStyle('position') == 'absolute' && pos)) {
        val = el['offset' + a[0].charAt(0).toUpperCase() + a[0].substr(1)];
      } else {
        val = 0;
      }

      return val;
    },

    getDefaultUnit: function (attr) {
      if (this.patterns.defaultUnit.test(attr)) {
        return 'px';
      }

      return '';
    },

    animateX: function (callback, scope) {
      var f = function () {
        this.onComplete.removeListener(f);
        if (typeof callback == 'function') {
          callback.call(scope || this, this);
        }
      };
      this.onComplete.addListener(f, this);
      this.animate();
    },

    setRuntimeAttribute: function (attr) {
      var start;
      var end;
      var attributes = this.attributes;

      this.runtimeAttributes[attr] = {};

      var isset = function (prop) {
        return typeof prop !== 'undefined';
      };

      if (!isset(attributes[attr]['to']) && !isset(attributes[attr]['by'])) {
        return false;
      }

      start = isset(attributes[attr]['from'])
        ? attributes[attr]['from']
        : this.getAttribute(attr);

      if (isset(attributes[attr]['to'])) {
        end = attributes[attr]['to'];
      } else if (isset(attributes[attr]['by'])) {
        if (start.constructor == Array) {
          end = [];
          for (var i = 0, len = start.length; i < len; ++i) {
            end[i] = start[i] + attributes[attr]['by'][i];
          }
        } else {
          end = start + attributes[attr]['by'];
        }
      }

      this.runtimeAttributes[attr].start = start;
      this.runtimeAttributes[attr].end = end;

      this.runtimeAttributes[attr].unit = isset(attributes[attr].unit)
        ? attributes[attr]['unit']
        : this.getDefaultUnit(attr);
    },

    init: function (el, attributes, duration, method) {
      var isAnimated = false;

      var startTime = null;

      var actualFrames = 0;

      el = Ext.getDom(el);

      this.attributes = attributes || {};

      this.duration = duration || 1;

      this.method = method || Ext.lib.Easing.easeNone;

      this.useSeconds = true;

      this.currentFrame = 0;

      this.totalFrames = Ext.lib.AnimMgr.fps;

      this.getEl = function () {
        return el;
      };

      this.isAnimated = function () {
        return isAnimated;
      };

      this.getStartTime = function () {
        return startTime;
      };

      this.runtimeAttributes = {};

      this.animate = function () {
        if (this.isAnimated()) {
          return false;
        }

        this.currentFrame = 0;

        this.totalFrames = this.useSeconds
          ? Math.ceil(Ext.lib.AnimMgr.fps * this.duration)
          : this.duration;

        Ext.lib.AnimMgr.registerElement(this);
      };

      this.stop = function (finish) {
        if (finish) {
          this.currentFrame = this.totalFrames;
          this._onTween.fire();
        }
        Ext.lib.AnimMgr.stop(this);
      };

      var onStart = function () {
        this.onStart.fire();

        this.runtimeAttributes = {};
        for (var attr in this.attributes) {
          this.setRuntimeAttribute(attr);
        }

        isAnimated = true;
        actualFrames = 0;
        startTime = new Date();
      };

      var onTween = function () {
        var data = {
          duration: new Date() - this.getStartTime(),
          currentFrame: this.currentFrame,
        };

        data.toString = function () {
          return (
            'duration: ' +
            data.duration +
            ', currentFrame: ' +
            data.currentFrame
          );
        };

        this.onTween.fire(data);

        var runtimeAttributes = this.runtimeAttributes;

        for (var attr in runtimeAttributes) {
          this.setAttribute(
            attr,
            this.doMethod(
              attr,
              runtimeAttributes[attr].start,
              runtimeAttributes[attr].end,
            ),
            runtimeAttributes[attr].unit,
          );
        }

        actualFrames += 1;
      };

      var onComplete = function () {
        var actual_duration = (new Date() - startTime) / 1000;

        var data = {
          duration: actual_duration,
          frames: actualFrames,
          fps: actualFrames / actual_duration,
        };

        data.toString = function () {
          return (
            'duration: ' +
            data.duration +
            ', frames: ' +
            data.frames +
            ', fps: ' +
            data.fps
          );
        };

        isAnimated = false;
        actualFrames = 0;
        this.onComplete.fire(data);
      };

      this._onStart = new Ext.util.Event(this);
      this.onStart = new Ext.util.Event(this);
      this.onTween = new Ext.util.Event(this);
      this._onTween = new Ext.util.Event(this);
      this.onComplete = new Ext.util.Event(this);
      this._onComplete = new Ext.util.Event(this);
      this._onStart.addListener(onStart);
      this._onTween.addListener(onTween);
      this._onComplete.addListener(onComplete);
    },
  };

  Ext.lib.AnimMgr = new (function () {
    var thread = null;

    var queue = [];

    var tweenCount = 0;

    this.fps = 1000;

    this.delay = 1;

    this.registerElement = function (tween) {
      queue[queue.length] = tween;
      tweenCount += 1;
      tween._onStart.fire();
      this.start();
    };

    this.unRegister = function (tween, index) {
      tween._onComplete.fire();
      index = index || getIndex(tween);
      if (index != -1) {
        queue.splice(index, 1);
      }

      tweenCount -= 1;
      if (tweenCount <= 0) {
        this.stop();
      }
    };

    this.start = function () {
      if (thread === null) {
        thread = setInterval(this.run, this.delay);
      }
    };

    this.stop = function (tween) {
      if (!tween) {
        clearInterval(thread);

        for (var i = 0, len = queue.length; i < len; ++i) {
          if (queue[0].isAnimated()) {
            this.unRegister(queue[0], 0);
          }
        }

        queue = [];
        thread = null;
        tweenCount = 0;
      } else {
        this.unRegister(tween);
      }
    };

    this.run = function () {
      for (var i = 0, len = queue.length; i < len; ++i) {
        var tween = queue[i];
        if (!tween || !tween.isAnimated()) {
          continue;
        }

        if (
          tween.currentFrame < tween.totalFrames ||
          tween.totalFrames === null
        ) {
          tween.currentFrame += 1;

          if (tween.useSeconds) {
            correctFrame(tween);
          }
          tween._onTween.fire();
        } else {
          Ext.lib.AnimMgr.stop(tween, i);
        }
      }
    };

    var getIndex = function (anim) {
      for (var i = 0, len = queue.length; i < len; ++i) {
        if (queue[i] == anim) {
          return i;
        }
      }
      return -1;
    };

    var correctFrame = function (tween) {
      var frames = tween.totalFrames;
      var frame = tween.currentFrame;
      var expected =
        (tween.currentFrame * tween.duration * 1000) / tween.totalFrames;
      var elapsed = new Date() - tween.getStartTime();
      var tweak = 0;

      if (elapsed < tween.duration * 1000) {
        tweak = Math.round((elapsed / expected - 1) * tween.currentFrame);
      } else {
        tweak = frames - (frame + 1);
      }
      if (tweak > 0 && isFinite(tweak)) {
        if (tween.currentFrame + tweak >= frames) {
          tweak = frames - (frame + 1);
        }

        tween.currentFrame += tweak;
      }
    };
  })();

  Ext.lib.Bezier = new (function () {
    this.getPosition = function (points, t) {
      var n = points.length;
      var tmp = [];

      for (var i = 0; i < n; ++i) {
        tmp[i] = [points[i][0], points[i][1]];
      }

      for (var j = 1; j < n; ++j) {
        for (i = 0; i < n - j; ++i) {
          tmp[i][0] = (1 - t) * tmp[i][0] + t * tmp[parseInt(i + 1, 10)][0];
          tmp[i][1] = (1 - t) * tmp[i][1] + t * tmp[parseInt(i + 1, 10)][1];
        }
      }

      return [tmp[0][0], tmp[0][1]];
    };
  })();
  (function () {
    Ext.lib.ColorAnim = function (el, attributes, duration, method) {
      Ext.lib.ColorAnim.superclass.constructor.call(
        this,
        el,
        attributes,
        duration,
        method,
      );
    };

    Ext.extend(Ext.lib.ColorAnim, Ext.lib.AnimBase);

    var Y = Ext.lib;
    var superclass = Y.ColorAnim.superclass;
    var proto = Y.ColorAnim.prototype;

    proto.toString = function () {
      var el = this.getEl();
      var id = el.id || el.tagName;
      return 'ColorAnim ' + id;
    };

    proto.patterns.color = /color$/i;
    proto.patterns.rgb = /^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i;
    proto.patterns.hex = /^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i;
    proto.patterns.hex3 = /^#?([0-9A-F]{1})([0-9A-F]{1})([0-9A-F]{1})$/i;
    proto.patterns.transparent = /^transparent|rgba\(0, 0, 0, 0\)$/;

    proto.parseColor = function (s) {
      if (s.length == 3) {
        return s;
      }

      var c = this.patterns.hex.exec(s);
      if (c && c.length == 4) {
        return [parseInt(c[1], 16), parseInt(c[2], 16), parseInt(c[3], 16)];
      }

      c = this.patterns.rgb.exec(s);
      if (c && c.length == 4) {
        return [parseInt(c[1], 10), parseInt(c[2], 10), parseInt(c[3], 10)];
      }

      c = this.patterns.hex3.exec(s);
      if (c && c.length == 4) {
        return [
          parseInt(c[1] + c[1], 16),
          parseInt(c[2] + c[2], 16),
          parseInt(c[3] + c[3], 16),
        ];
      }

      return null;
    };

    proto.getAttribute = function (attr) {
      var el = this.getEl();
      if (this.patterns.color.test(attr)) {
        var val = fly(el).getStyle(attr);

        if (this.patterns.transparent.test(val)) {
          var parent = el.parentNode;
          val = fly(parent).getStyle(attr);

          while (parent && this.patterns.transparent.test(val)) {
            parent = parent.parentNode;
            val = fly(parent).getStyle(attr);
            if (parent.tagName.toUpperCase() == 'HTML') {
              val = '#fff';
            }
          }
        }
      } else {
        val = superclass.getAttribute.call(this, attr);
      }

      return val;
    };

    proto.doMethod = function (attr, start, end) {
      var val;

      if (this.patterns.color.test(attr)) {
        val = [];
        for (var i = 0, len = start.length; i < len; ++i) {
          val[i] = superclass.doMethod.call(this, attr, start[i], end[i]);
        }

        val =
          'rgb(' +
          Math.floor(val[0]) +
          ',' +
          Math.floor(val[1]) +
          ',' +
          Math.floor(val[2]) +
          ')';
      } else {
        val = superclass.doMethod.call(this, attr, start, end);
      }

      return val;
    };

    proto.setRuntimeAttribute = function (attr) {
      superclass.setRuntimeAttribute.call(this, attr);

      if (this.patterns.color.test(attr)) {
        var attributes = this.attributes;
        var start = this.parseColor(this.runtimeAttributes[attr].start);
        var end = this.parseColor(this.runtimeAttributes[attr].end);

        if (
          typeof attributes[attr]['to'] === 'undefined' &&
          typeof attributes[attr]['by'] !== 'undefined'
        ) {
          end = this.parseColor(attributes[attr].by);

          for (var i = 0, len = start.length; i < len; ++i) {
            end[i] = start[i] + end[i];
          }
        }

        this.runtimeAttributes[attr].start = start;
        this.runtimeAttributes[attr].end = end;
      }
    };
  })();

  Ext.lib.Easing = {
    easeNone: function (t, b, c, d) {
      return (c * t) / d + b;
    },

    easeIn: function (t, b, c, d) {
      return c * (t /= d) * t + b;
    },

    easeOut: function (t, b, c, d) {
      return -c * (t /= d) * (t - 2) + b;
    },

    easeBoth: function (t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return (c / 2) * t * t + b;
      }

      return (-c / 2) * (--t * (t - 2) - 1) + b;
    },

    easeInStrong: function (t, b, c, d) {
      return c * (t /= d) * t * t * t + b;
    },

    easeOutStrong: function (t, b, c, d) {
      return -c * ((t = t / d - 1) * t * t * t - 1) + b;
    },

    easeBothStrong: function (t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return (c / 2) * t * t * t * t + b;
      }

      return (-c / 2) * ((t -= 2) * t * t * t - 2) + b;
    },

    elasticIn: function (t, b, c, d, a, p) {
      if (t == 0) {
        return b;
      }
      if ((t /= d) == 1) {
        return b + c;
      }
      if (!p) {
        p = d * 0.3;
      }

      if (!a || a < Math.abs(c)) {
        a = c;
        var s = p / 4;
      } else {
        var s = (p / (2 * Math.PI)) * Math.asin(c / a);
      }

      return (
        -(
          a *
          Math.pow(2, 10 * (t -= 1)) *
          Math.sin(((t * d - s) * (2 * Math.PI)) / p)
        ) + b
      );
    },

    elasticOut: function (t, b, c, d, a, p) {
      if (t == 0) {
        return b;
      }
      if ((t /= d) == 1) {
        return b + c;
      }
      if (!p) {
        p = d * 0.3;
      }

      if (!a || a < Math.abs(c)) {
        a = c;
        var s = p / 4;
      } else {
        var s = (p / (2 * Math.PI)) * Math.asin(c / a);
      }

      return (
        a * Math.pow(2, -10 * t) * Math.sin(((t * d - s) * (2 * Math.PI)) / p) +
        c +
        b
      );
    },

    elasticBoth: function (t, b, c, d, a, p) {
      if (t == 0) {
        return b;
      }

      if ((t /= d / 2) == 2) {
        return b + c;
      }

      if (!p) {
        p = d * (0.3 * 1.5);
      }

      if (!a || a < Math.abs(c)) {
        a = c;
        var s = p / 4;
      } else {
        var s = (p / (2 * Math.PI)) * Math.asin(c / a);
      }

      if (t < 1) {
        return (
          -0.5 *
            (a *
              Math.pow(2, 10 * (t -= 1)) *
              Math.sin(((t * d - s) * (2 * Math.PI)) / p)) +
          b
        );
      }
      return (
        a *
          Math.pow(2, -10 * (t -= 1)) *
          Math.sin(((t * d - s) * (2 * Math.PI)) / p) *
          0.5 +
        c +
        b
      );
    },

    backIn: function (t, b, c, d, s) {
      if (typeof s == 'undefined') {
        s = 1.70158;
      }
      return c * (t /= d) * t * ((s + 1) * t - s) + b;
    },

    backOut: function (t, b, c, d, s) {
      if (typeof s == 'undefined') {
        s = 1.70158;
      }
      return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
    },

    backBoth: function (t, b, c, d, s) {
      if (typeof s == 'undefined') {
        s = 1.70158;
      }

      if ((t /= d / 2) < 1) {
        return (c / 2) * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
      }
      return (c / 2) * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
    },

    bounceIn: function (t, b, c, d) {
      return c - Ext.lib.Easing.bounceOut(d - t, 0, c, d) + b;
    },

    bounceOut: function (t, b, c, d) {
      if ((t /= d) < 1 / 2.75) {
        return c * (7.5625 * t * t) + b;
      } else if (t < 2 / 2.75) {
        return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
      } else if (t < 2.5 / 2.75) {
        return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
      }
      return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
    },

    bounceBoth: function (t, b, c, d) {
      if (t < d / 2) {
        return Ext.lib.Easing.bounceIn(t * 2, 0, c, d) * 0.5 + b;
      }
      return Ext.lib.Easing.bounceOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
    },
  };

  (function () {
    Ext.lib.Motion = function (el, attributes, duration, method) {
      if (el) {
        Ext.lib.Motion.superclass.constructor.call(
          this,
          el,
          attributes,
          duration,
          method,
        );
      }
    };

    Ext.extend(Ext.lib.Motion, Ext.lib.ColorAnim);

    var Y = Ext.lib;
    var superclass = Y.Motion.superclass;
    var proto = Y.Motion.prototype;

    proto.toString = function () {
      var el = this.getEl();
      var id = el.id || el.tagName;
      return 'Motion ' + id;
    };

    proto.patterns.points = /^points$/i;

    proto.setAttribute = function (attr, val, unit) {
      if (this.patterns.points.test(attr)) {
        unit = unit || 'px';
        superclass.setAttribute.call(this, 'left', val[0], unit);
        superclass.setAttribute.call(this, 'top', val[1], unit);
      } else {
        superclass.setAttribute.call(this, attr, val, unit);
      }
    };

    proto.getAttribute = function (attr) {
      if (this.patterns.points.test(attr)) {
        var val = [
          superclass.getAttribute.call(this, 'left'),
          superclass.getAttribute.call(this, 'top'),
        ];
      } else {
        val = superclass.getAttribute.call(this, attr);
      }

      return val;
    };

    proto.doMethod = function (attr, start, end) {
      var val = null;

      if (this.patterns.points.test(attr)) {
        var t = this.method(this.currentFrame, 0, 100, this.totalFrames) / 100;
        val = Y.Bezier.getPosition(this.runtimeAttributes[attr], t);
      } else {
        val = superclass.doMethod.call(this, attr, start, end);
      }
      return val;
    };

    proto.setRuntimeAttribute = function (attr) {
      if (this.patterns.points.test(attr)) {
        var el = this.getEl();
        var attributes = this.attributes;
        var start;
        var control = attributes['points']['control'] || [];
        var end;
        var i, len;

        if (control.length > 0 && !Ext.isArray(control[0])) {
          control = [control];
        } else {
          var tmp = [];
          for (i = 0, len = control.length; i < len; ++i) {
            tmp[i] = control[i];
          }
          control = tmp;
        }

        Ext.fly(el, '_anim').position();

        if (isset(attributes['points']['from'])) {
          Ext.lib.Dom.setXY(el, attributes['points']['from']);
        } else {
          Ext.lib.Dom.setXY(el, Ext.lib.Dom.getXY(el));
        }

        start = this.getAttribute('points');

        if (isset(attributes['points']['to'])) {
          end = translateValues.call(this, attributes['points']['to'], start);

          var pageXY = Ext.lib.Dom.getXY(this.getEl());
          for (i = 0, len = control.length; i < len; ++i) {
            control[i] = translateValues.call(this, control[i], start);
          }
        } else if (isset(attributes['points']['by'])) {
          end = [
            start[0] + attributes['points']['by'][0],
            start[1] + attributes['points']['by'][1],
          ];

          for (i = 0, len = control.length; i < len; ++i) {
            control[i] = [start[0] + control[i][0], start[1] + control[i][1]];
          }
        }

        this.runtimeAttributes[attr] = [start];

        if (control.length > 0) {
          this.runtimeAttributes[attr] =
            this.runtimeAttributes[attr].concat(control);
        }

        this.runtimeAttributes[attr][this.runtimeAttributes[attr].length] = end;
      } else {
        superclass.setRuntimeAttribute.call(this, attr);
      }
    };

    var translateValues = function (val, start) {
      var pageXY = Ext.lib.Dom.getXY(this.getEl());
      val = [val[0] - pageXY[0] + start[0], val[1] - pageXY[1] + start[1]];

      return val;
    };

    var isset = function (prop) {
      return typeof prop !== 'undefined';
    };
  })();

  (function () {
    Ext.lib.Scroll = function (el, attributes, duration, method) {
      if (el) {
        Ext.lib.Scroll.superclass.constructor.call(
          this,
          el,
          attributes,
          duration,
          method,
        );
      }
    };

    Ext.extend(Ext.lib.Scroll, Ext.lib.ColorAnim);

    var Y = Ext.lib;
    var superclass = Y.Scroll.superclass;
    var proto = Y.Scroll.prototype;

    proto.toString = function () {
      var el = this.getEl();
      var id = el.id || el.tagName;
      return 'Scroll ' + id;
    };

    proto.doMethod = function (attr, start, end) {
      var val = null;

      if (attr == 'scroll') {
        val = [
          this.method(
            this.currentFrame,
            start[0],
            end[0] - start[0],
            this.totalFrames,
          ),
          this.method(
            this.currentFrame,
            start[1],
            end[1] - start[1],
            this.totalFrames,
          ),
        ];
      } else {
        val = superclass.doMethod.call(this, attr, start, end);
      }
      return val;
    };

    proto.getAttribute = function (attr) {
      var val = null;
      var el = this.getEl();

      if (attr == 'scroll') {
        val = [el.scrollLeft, el.scrollTop];
      } else {
        val = superclass.getAttribute.call(this, attr);
      }

      return val;
    };

    proto.setAttribute = function (attr, val, unit) {
      var el = this.getEl();

      if (attr == 'scroll') {
        el.scrollLeft = val[0];
        el.scrollTop = val[1];
      } else {
        superclass.setAttribute.call(this, attr, val, unit);
      }
    };
  })();
})();
/*
 * Ext JS Library 2.3.0
 * Copyright(c) 2006-2009, Ext JS, LLC.
 * licensing@extjs.com
 *
 * http://extjs.com/license
 */

Ext.DomHelper = (function () {
  var tempTableEl = null;
  var emptyTags =
    /^(?:br|frame|hr|img|input|link|meta|range|spacer|wbr|area|param|col)$/i;
  var tableRe = /^table|tbody|tr|td$/i;

  // build as innerHTML where available
  var createHtml = function (o) {
    if (typeof o == 'string') {
      return o;
    }
    var b = '';
    if (Ext.isArray(o)) {
      for (var i = 0, l = o.length; i < l; i++) {
        b += createHtml(o[i]);
      }
      return b;
    }
    if (!o.tag) {
      o.tag = 'div';
    }
    b += '<' + o.tag;
    for (var attr in o) {
      if (
        attr == 'tag' ||
        attr == 'children' ||
        attr == 'cn' ||
        attr == 'html' ||
        typeof o[attr] == 'function'
      )
        continue;
      if (attr == 'style') {
        var s = o['style'];
        if (typeof s == 'function') {
          s = s.call();
        }
        if (typeof s == 'string') {
          b += ' style="' + s + '"';
        } else if (typeof s == 'object') {
          b += ' style="';
          for (var key in s) {
            if (typeof s[key] != 'function') {
              b += key + ':' + s[key] + ';';
            }
          }
          b += '"';
        }
      } else {
        if (attr == 'cls') {
          b += ' class="' + o['cls'] + '"';
        } else if (attr == 'htmlFor') {
          b += ' for="' + o['htmlFor'] + '"';
        } else {
          b += ' ' + attr + '="' + o[attr] + '"';
        }
      }
    }
    if (emptyTags.test(o.tag)) {
      b += '/>';
    } else {
      b += '>';
      var cn = o.children || o.cn;
      if (cn) {
        b += createHtml(cn);
      } else if (o.html) {
        b += o.html;
      }
      b += '</' + o.tag + '>';
    }
    return b;
  };

  // build as dom

  var createDom = function (o, parentNode) {
    var el;
    if (Ext.isArray(o)) {
      // Allow Arrays of siblings to be inserted
      el = document.createDocumentFragment(); // in one shot using a DocumentFragment
      for (var i = 0, l = o.length; i < l; i++) {
        createDom(o[i], el);
      }
    } else if (typeof o == 'string') {
      // Allow a string as a child spec.
      el = document.createTextNode(o);
    } else {
      el = document.createElement(o.tag || 'div');
      var useSet = !!el.setAttribute; // In IE some elements don't have setAttribute
      for (var attr in o) {
        if (
          attr == 'tag' ||
          attr == 'children' ||
          attr == 'cn' ||
          attr == 'html' ||
          attr == 'style' ||
          typeof o[attr] == 'function'
        )
          continue;
        if (attr == 'cls') {
          el.className = o['cls'];
        } else {
          if (useSet) el.setAttribute(attr, o[attr]);
          else el[attr] = o[attr];
        }
      }
      Ext.DomHelper.applyStyles(el, o.style);
      var cn = o.children || o.cn;
      if (cn) {
        createDom(cn, el);
      } else if (o.html) {
        el.innerHTML = o.html;
      }
    }
    if (parentNode) {
      parentNode.appendChild(el);
    }
    return el;
  };

  var ieTable = function (depth, s, h, e) {
    tempTableEl.innerHTML = [s, h, e].join('');
    var i = -1,
      el = tempTableEl;
    while (++i < depth) {
      el = el.firstChild;
    }
    return el;
  };

  // kill repeat to save bytes
  var ts = '<table>',
    te = '</table>',
    tbs = ts + '<tbody>',
    tbe = '</tbody>' + te,
    trs = tbs + '<tr>',
    tre = '</tr>' + tbe;

  var insertIntoTable = function (tag, where, el, html) {
    if (!tempTableEl) {
      tempTableEl = document.createElement('div');
    }
    var node;
    var before = null;
    if (tag == 'td') {
      if (where == 'afterbegin' || where == 'beforeend') {
        // INTO a TD
        return;
      }
      if (where == 'beforebegin') {
        before = el;
        el = el.parentNode;
      } else {
        before = el.nextSibling;
        el = el.parentNode;
      }
      node = ieTable(4, trs, html, tre);
    } else if (tag == 'tr') {
      if (where == 'beforebegin') {
        before = el;
        el = el.parentNode;
        node = ieTable(3, tbs, html, tbe);
      } else if (where == 'afterend') {
        before = el.nextSibling;
        el = el.parentNode;
        node = ieTable(3, tbs, html, tbe);
      } else {
        // INTO a TR
        if (where == 'afterbegin') {
          before = el.firstChild;
        }
        node = ieTable(4, trs, html, tre);
      }
    } else if (tag == 'tbody') {
      if (where == 'beforebegin') {
        before = el;
        el = el.parentNode;
        node = ieTable(2, ts, html, te);
      } else if (where == 'afterend') {
        before = el.nextSibling;
        el = el.parentNode;
        node = ieTable(2, ts, html, te);
      } else {
        if (where == 'afterbegin') {
          before = el.firstChild;
        }
        node = ieTable(3, tbs, html, tbe);
      }
    } else {
      // TABLE
      if (where == 'beforebegin' || where == 'afterend') {
        // OUTSIDE the table
        return;
      }
      if (where == 'afterbegin') {
        before = el.firstChild;
      }
      node = ieTable(2, ts, html, te);
    }
    el.insertBefore(node, before);
    return node;
  };

  return {
    useDom: false,

    markup: function (o) {
      return createHtml(o);
    },

    applyStyles: function (el, styles) {
      if (styles) {
        el = Ext.fly(el);
        if (typeof styles == 'string') {
          var re = /\s?([a-z\-]*)\:\s?([^;]*);?/gi;
          var matches;
          while ((matches = re.exec(styles)) != null) {
            el.setStyle(matches[1], matches[2]);
          }
        } else if (typeof styles == 'object') {
          for (var style in styles) {
            el.setStyle(style, styles[style]);
          }
        } else if (typeof styles == 'function') {
          Ext.DomHelper.applyStyles(el, styles.call());
        }
      }
    },

    insertHtml: function (where, el, html) {
      where = where.toLowerCase();
      if (el.insertAdjacentHTML) {
        if (tableRe.test(el.tagName)) {
          var rs;
          if (
            (rs = insertIntoTable(el.tagName.toLowerCase(), where, el, html))
          ) {
            return rs;
          }
        }
        switch (where) {
          case 'beforebegin':
            el.insertAdjacentHTML('BeforeBegin', html);
            return el.previousSibling;
          case 'afterbegin':
            el.insertAdjacentHTML('AfterBegin', html);
            return el.firstChild;
          case 'beforeend':
            el.insertAdjacentHTML('BeforeEnd', html);
            return el.lastChild;
          case 'afterend':
            el.insertAdjacentHTML('AfterEnd', html);
            return el.nextSibling;
        }
        throw 'Illegal insertion point -> "' + where + '"';
      }
      var range = el.ownerDocument.createRange();
      var frag;
      switch (where) {
        case 'beforebegin':
          range.setStartBefore(el);
          frag = range.createContextualFragment(html);
          el.parentNode.insertBefore(frag, el);
          return el.previousSibling;
        case 'afterbegin':
          if (el.firstChild) {
            range.setStartBefore(el.firstChild);
            frag = range.createContextualFragment(html);
            el.insertBefore(frag, el.firstChild);
            return el.firstChild;
          } else {
            el.innerHTML = html;
            return el.firstChild;
          }
        case 'beforeend':
          if (el.lastChild) {
            range.setStartAfter(el.lastChild);
            frag = range.createContextualFragment(html);
            el.appendChild(frag);
            return el.lastChild;
          } else {
            el.innerHTML = html;
            return el.lastChild;
          }
        case 'afterend':
          range.setStartAfter(el);
          frag = range.createContextualFragment(html);
          el.parentNode.insertBefore(frag, el.nextSibling);
          return el.nextSibling;
      }
      throw 'Illegal insertion point -> "' + where + '"';
    },

    insertBefore: function (el, o, returnElement) {
      return this.doInsert(el, o, returnElement, 'beforeBegin');
    },

    insertAfter: function (el, o, returnElement) {
      return this.doInsert(el, o, returnElement, 'afterEnd', 'nextSibling');
    },

    insertFirst: function (el, o, returnElement) {
      return this.doInsert(el, o, returnElement, 'afterBegin', 'firstChild');
    },

    // private
    doInsert: function (el, o, returnElement, pos, sibling) {
      el = Ext.getDom(el);
      var newNode;
      if (this.useDom) {
        newNode = createDom(o, null);
        (sibling === 'firstChild' ? el : el.parentNode).insertBefore(
          newNode,
          sibling ? el[sibling] : el,
        );
      } else {
        var html = createHtml(o);
        newNode = this.insertHtml(pos, el, html);
      }
      return returnElement ? Ext.get(newNode, true) : newNode;
    },

    append: function (el, o, returnElement) {
      el = Ext.getDom(el);
      var newNode;
      if (this.useDom) {
        newNode = createDom(o, null);
        el.appendChild(newNode);
      } else {
        var html = createHtml(o);
        newNode = this.insertHtml('beforeEnd', el, html);
      }
      return returnElement ? Ext.get(newNode, true) : newNode;
    },

    overwrite: function (el, o, returnElement) {
      el = Ext.getDom(el);
      el.innerHTML = createHtml(o);
      return returnElement ? Ext.get(el.firstChild, true) : el.firstChild;
    },

    createTemplate: function (o) {
      var html = createHtml(o);
      return new Ext.Template(html);
    },
  };
})();

Ext.Template = function (html) {
  var a = arguments;
  if (Ext.isArray(html)) {
    html = html.join('');
  } else if (a.length > 1) {
    var buf = [];
    for (var i = 0, len = a.length; i < len; i++) {
      if (typeof a[i] == 'object') {
        Ext.apply(this, a[i]);
      } else {
        buf[buf.length] = a[i];
      }
    }
    html = buf.join('');
  }

  this.html = html;
  if (this.compiled) {
    this.compile();
  }
};
Ext.Template.prototype = {
  applyTemplate: function (values) {
    if (this.compiled) {
      return this.compiled(values);
    }
    var useF = this.disableFormats !== true;
    var fm = Ext.util.Format,
      tpl = this;
    var fn = function (m, name, format, args) {
      if (format && useF) {
        if (format.substr(0, 5) == 'this.') {
          return tpl.call(format.substr(5), values[name], values);
        } else {
          if (args) {
            // quoted values are required for strings in compiled templates,
            // but for non compiled we need to strip them
            // quoted reversed for jsmin
            var re = /^\s*['"](.*)["']\s*$/;
            args = args.split(',');
            for (var i = 0, len = args.length; i < len; i++) {
              args[i] = args[i].replace(re, '$1');
            }
            args = [values[name]].concat(args);
          } else {
            args = [values[name]];
          }
          return fm[format].apply(fm, args);
        }
      } else {
        return values[name] !== undefined ? values[name] : '';
      }
    };
    return this.html.replace(this.re, fn);
  },

  set: function (html, compile) {
    this.html = html;
    this.compiled = null;
    if (compile) {
      this.compile();
    }
    return this;
  },

  disableFormats: false,

  re: /\{([\w-]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?\}/g,

  compile: function () {
    var fm = Ext.util.Format;
    var useF = this.disableFormats !== true;
    var sep = Ext.isGecko ? '+' : ',';
    var fn = function (m, name, format, args) {
      if (format && useF) {
        args = args ? ',' + args : '';
        if (format.substr(0, 5) != 'this.') {
          format = 'fm.' + format + '(';
        } else {
          format = 'this.call("' + format.substr(5) + '", ';
          args = ', values';
        }
      } else {
        args = '';
        format = "(values['" + name + "'] == undefined ? '' : ";
      }
      return (
        "'" + sep + format + "values['" + name + "']" + args + ')' + sep + "'"
      );
    };
    var body;
    // branched to use + in gecko and [].join() in others
    if (Ext.isGecko) {
      body =
        "this.compiled = function(values){ return '" +
        this.html
          .replace(/\\/g, '\\\\')
          .replace(/(\r\n|\n)/g, '\\n')
          .replace(/'/g, "\\'")
          .replace(this.re, fn) +
        "';};";
    } else {
      body = ["this.compiled = function(values){ return ['"];
      body.push(
        this.html
          .replace(/\\/g, '\\\\')
          .replace(/(\r\n|\n)/g, '\\n')
          .replace(/'/g, "\\'")
          .replace(this.re, fn),
      );
      body.push("'].join('');};");
      body = body.join('');
    }
    eval(body);
    return this;
  },

  // private function used to call members
  call: function (fnName, value, allValues) {
    return this[fnName](value, allValues);
  },

  insertFirst: function (el, values, returnElement) {
    return this.doInsert('afterBegin', el, values, returnElement);
  },

  insertBefore: function (el, values, returnElement) {
    return this.doInsert('beforeBegin', el, values, returnElement);
  },

  insertAfter: function (el, values, returnElement) {
    return this.doInsert('afterEnd', el, values, returnElement);
  },

  append: function (el, values, returnElement) {
    return this.doInsert('beforeEnd', el, values, returnElement);
  },

  doInsert: function (where, el, values, returnEl) {
    el = Ext.getDom(el);
    var newNode = Ext.DomHelper.insertHtml(
      where,
      el,
      this.applyTemplate(values),
    );
    return returnEl ? Ext.get(newNode, true) : newNode;
  },

  overwrite: function (el, values, returnElement) {
    el = Ext.getDom(el);
    el.innerHTML = this.applyTemplate(values);
    return returnElement ? Ext.get(el.firstChild, true) : el.firstChild;
  },
};

Ext.Template.prototype.apply = Ext.Template.prototype.applyTemplate;

// backwards compat
Ext.DomHelper.Template = Ext.Template;

Ext.Template.from = function (el, config) {
  el = Ext.getDom(el);
  return new Ext.Template(el.value || el.innerHTML, config || '');
};

Ext.DomQuery = (function () {
  var cache = {},
    simpleCache = {},
    valueCache = {};
  var nonSpace = /\S/;
  var trimRe = /^\s+|\s+$/g;
  var tplRe = /\{(\d+)\}/g;
  var modeRe = /^(\s?[\/>+~]\s?|\s|$)/;
  var tagTokenRe = /^(#)?([\w-\*]+)/;
  var nthRe = /(\d*)n\+?(\d*)/,
    nthRe2 = /\D/;
  var opera = Ext.isOpera;

  function child(p, index) {
    var i = 0;
    var n = p.firstChild;
    while (n) {
      if (n.nodeType == 1) {
        if (++i == index) {
          return n;
        }
      }
      n = n.nextSibling;
    }
    return null;
  }

  function next(n) {
    while ((n = n.nextSibling) && n.nodeType != 1);
    return n;
  }

  function prev(n) {
    while ((n = n.previousSibling) && n.nodeType != 1);
    return n;
  }

  function children(d) {
    var n = d.firstChild,
      ni = -1;
    while (n) {
      var nx = n.nextSibling;
      if (n.nodeType == 3 && !nonSpace.test(n.nodeValue)) {
        d.removeChild(n);
      } else {
        n.nodeIndex = ++ni;
      }
      n = nx;
    }
    return this;
  }

  function byClassName(c, a, v) {
    if (!v) {
      return c;
    }
    var r = [],
      ri = -1,
      cn;
    for (var i = 0, ci; (ci = c[i]); i++) {
      if ((' ' + ci.className + ' ').indexOf(v) != -1) {
        r[++ri] = ci;
      }
    }
    return r;
  }

  function attrValue(n, attr) {
    if (!n.tagName && typeof n.length != 'undefined') {
      n = n[0];
    }
    if (!n) {
      return null;
    }
    if (attr == 'for') {
      return n.htmlFor;
    }
    if (attr == 'class' || attr == 'className') {
      return n.className;
    }
    return n.getAttribute(attr) || n[attr];
  }

  function getNodes(ns, mode, tagName) {
    var result = [],
      ri = -1,
      cs;
    if (!ns) {
      return result;
    }
    tagName = tagName || '*';
    if (typeof ns.getElementsByTagName != 'undefined') {
      ns = [ns];
    }
    if (!mode) {
      for (var i = 0, ni; (ni = ns[i]); i++) {
        cs = ni.getElementsByTagName(tagName);
        for (var j = 0, ci; (ci = cs[j]); j++) {
          result[++ri] = ci;
        }
      }
    } else if (mode == '/' || mode == '>') {
      var utag = tagName.toUpperCase();
      for (var i = 0, ni, cn; (ni = ns[i]); i++) {
        cn = opera ? ni.childNodes : ni.children || ni.childNodes;
        for (var j = 0, cj; (cj = cn[j]); j++) {
          if (cj.nodeName == utag || cj.nodeName == tagName || tagName == '*') {
            result[++ri] = cj;
          }
        }
      }
    } else if (mode == '+') {
      var utag = tagName.toUpperCase();
      for (var i = 0, n; (n = ns[i]); i++) {
        while ((n = n.nextSibling) && n.nodeType != 1);
        if (
          n &&
          (n.nodeName == utag || n.nodeName == tagName || tagName == '*')
        ) {
          result[++ri] = n;
        }
      }
    } else if (mode == '~') {
      var utag = tagName.toUpperCase();
      for (var i = 0, n; (n = ns[i]); i++) {
        while ((n = n.nextSibling)) {
          if (n.nodeName == utag || n.nodeName == tagName || tagName == '*') {
            result[++ri] = n;
          }
        }
      }
    }
    return result;
  }

  function concat(a, b) {
    if (b.slice) {
      return a.concat(b);
    }
    for (var i = 0, l = b.length; i < l; i++) {
      a[a.length] = b[i];
    }
    return a;
  }

  function byTag(cs, tagName) {
    if (cs.tagName || cs == document) {
      cs = [cs];
    }
    if (!tagName) {
      return cs;
    }
    var r = [],
      ri = -1;
    tagName = tagName.toLowerCase();
    for (var i = 0, ci; (ci = cs[i]); i++) {
      if (ci.nodeType == 1 && ci.tagName.toLowerCase() == tagName) {
        r[++ri] = ci;
      }
    }
    return r;
  }

  function byId(cs, attr, id) {
    if (cs.tagName || cs == document) {
      cs = [cs];
    }
    if (!id) {
      return cs;
    }
    var r = [],
      ri = -1;
    for (var i = 0, ci; (ci = cs[i]); i++) {
      if (ci && ci.id == id) {
        r[++ri] = ci;
        return r;
      }
    }
    return r;
  }

  function byAttribute(cs, attr, value, op, custom) {
    var r = [],
      ri = -1,
      st = custom == '{';
    var f = Ext.DomQuery.operators[op];
    for (var i = 0, ci; (ci = cs[i]); i++) {
      if (ci.nodeType != 1) {
        continue;
      }
      var a;
      if (st) {
        a = Ext.DomQuery.getStyle(ci, attr);
      } else if (attr == 'class' || attr == 'className') {
        a = ci.className;
      } else if (attr == 'for') {
        a = ci.htmlFor;
      } else if (attr == 'href') {
        a = ci.getAttribute('href', 2);
      } else {
        a = ci.getAttribute(attr);
      }
      if ((f && f(a, value)) || (!f && a)) {
        r[++ri] = ci;
      }
    }
    return r;
  }

  function byPseudo(cs, name, value) {
    return Ext.DomQuery.pseudos[name](cs, value);
  }

  // This is for IE MSXML which does not support expandos.
  // IE runs the same speed using setAttribute, however FF slows way down
  // and Safari completely fails so they need to continue to use expandos.
  var isIE = window.ActiveXObject ? true : false;

  // this eval is stop the compressor from
  // renaming the variable to something shorter
  eval('var batch = 30803;');

  var key = 30803;

  function nodupIEXml(cs) {
    var d = ++key;
    cs[0].setAttribute('_nodup', d);
    var r = [cs[0]];
    for (var i = 1, len = cs.length; i < len; i++) {
      var c = cs[i];
      if (!c.getAttribute('_nodup') != d) {
        c.setAttribute('_nodup', d);
        r[r.length] = c;
      }
    }
    for (var i = 0, len = cs.length; i < len; i++) {
      cs[i].removeAttribute('_nodup');
    }
    return r;
  }

  function nodup(cs) {
    if (!cs) {
      return [];
    }
    var len = cs.length,
      c,
      i,
      r = cs,
      cj,
      ri = -1;
    if (!len || typeof cs.nodeType != 'undefined' || len == 1) {
      return cs;
    }
    if (isIE && typeof cs[0].selectSingleNode != 'undefined') {
      return nodupIEXml(cs);
    }
    var d = ++key;
    cs[0]._nodup = d;
    for (i = 1; (c = cs[i]); i++) {
      if (c._nodup != d) {
        c._nodup = d;
      } else {
        r = [];
        for (var j = 0; j < i; j++) {
          r[++ri] = cs[j];
        }
        for (j = i + 1; (cj = cs[j]); j++) {
          if (cj._nodup != d) {
            cj._nodup = d;
            r[++ri] = cj;
          }
        }
        return r;
      }
    }
    return r;
  }

  function quickDiffIEXml(c1, c2) {
    var d = ++key;
    for (var i = 0, len = c1.length; i < len; i++) {
      c1[i].setAttribute('_qdiff', d);
    }
    var r = [];
    for (var i = 0, len = c2.length; i < len; i++) {
      if (c2[i].getAttribute('_qdiff') != d) {
        r[r.length] = c2[i];
      }
    }
    for (var i = 0, len = c1.length; i < len; i++) {
      c1[i].removeAttribute('_qdiff');
    }
    return r;
  }

  function quickDiff(c1, c2) {
    var len1 = c1.length;
    if (!len1) {
      return c2;
    }
    if (isIE && c1[0].selectSingleNode) {
      return quickDiffIEXml(c1, c2);
    }
    var d = ++key;
    for (var i = 0; i < len1; i++) {
      c1[i]._qdiff = d;
    }
    var r = [];
    for (var i = 0, len = c2.length; i < len; i++) {
      if (c2[i]._qdiff != d) {
        r[r.length] = c2[i];
      }
    }
    return r;
  }

  function quickId(ns, mode, root, id) {
    if (ns == root) {
      var d = root.ownerDocument || root;
      return d.getElementById(id);
    }
    ns = getNodes(ns, mode, '*');
    return byId(ns, null, id);
  }

  return {
    getStyle: function (el, name) {
      return Ext.fly(el).getStyle(name);
    },

    compile: function (path, type) {
      type = type || 'select';

      var fn = [
        'var f = function(root){\n var mode; ++batch; var n = root || document;\n',
      ];
      var q = path,
        mode,
        lq;
      var tk = Ext.DomQuery.matchers;
      var tklen = tk.length;
      var mm;

      // accept leading mode switch
      var lmode = q.match(modeRe);
      if (lmode && lmode[1]) {
        fn[fn.length] = 'mode="' + lmode[1].replace(trimRe, '') + '";';
        q = q.replace(lmode[1], '');
      }
      // strip leading slashes
      while (path.substr(0, 1) == '/') {
        path = path.substr(1);
      }

      while (q && lq != q) {
        lq = q;
        var tm = q.match(tagTokenRe);
        if (type == 'select') {
          if (tm) {
            if (tm[1] == '#') {
              fn[fn.length] = 'n = quickId(n, mode, root, "' + tm[2] + '");';
            } else {
              fn[fn.length] = 'n = getNodes(n, mode, "' + tm[2] + '");';
            }
            q = q.replace(tm[0], '');
          } else if (q.substr(0, 1) != '@') {
            fn[fn.length] = 'n = getNodes(n, mode, "*");';
          }
        } else {
          if (tm) {
            if (tm[1] == '#') {
              fn[fn.length] = 'n = byId(n, null, "' + tm[2] + '");';
            } else {
              fn[fn.length] = 'n = byTag(n, "' + tm[2] + '");';
            }
            q = q.replace(tm[0], '');
          }
        }
        while (!(mm = q.match(modeRe))) {
          var matched = false;
          for (var j = 0; j < tklen; j++) {
            var t = tk[j];
            var m = q.match(t.re);
            if (m) {
              fn[fn.length] = t.select.replace(tplRe, function (x, i) {
                return m[i];
              });
              q = q.replace(m[0], '');
              matched = true;
              break;
            }
          }
          // prevent infinite loop on bad selector
          if (!matched) {
            throw 'Error parsing selector, parsing failed at "' + q + '"';
          }
        }
        if (mm[1]) {
          fn[fn.length] = 'mode="' + mm[1].replace(trimRe, '') + '";';
          q = q.replace(mm[1], '');
        }
      }
      fn[fn.length] = 'return nodup(n);\n}';
      eval(fn.join(''));
      return f;
    },

    select: function (path, root, type) {
      if (!root || root == document) {
        root = document;
      }
      if (typeof root == 'string') {
        root = document.getElementById(root);
      }
      var paths = path.split(',');
      var results = [];
      for (var i = 0, len = paths.length; i < len; i++) {
        var p = paths[i].replace(trimRe, '');
        if (!cache[p]) {
          cache[p] = Ext.DomQuery.compile(p);
          if (!cache[p]) {
            throw p + ' is not a valid selector';
          }
        }
        var result = cache[p](root);
        if (result && result != document) {
          results = results.concat(result);
        }
      }
      if (paths.length > 1) {
        return nodup(results);
      }
      return results;
    },

    selectNode: function (path, root) {
      return Ext.DomQuery.select(path, root)[0];
    },

    selectValue: function (path, root, defaultValue) {
      path = path.replace(trimRe, '');
      if (!valueCache[path]) {
        valueCache[path] = Ext.DomQuery.compile(path, 'select');
      }
      var n = valueCache[path](root);
      n = n[0] ? n[0] : n;
      var v = n && n.firstChild ? n.firstChild.nodeValue : null;
      return v === null || v === undefined || v === '' ? defaultValue : v;
    },

    selectNumber: function (path, root, defaultValue) {
      var v = Ext.DomQuery.selectValue(path, root, defaultValue || 0);
      return parseFloat(v);
    },

    is: function (el, ss) {
      if (typeof el == 'string') {
        el = document.getElementById(el);
      }
      var isArray = Ext.isArray(el);
      var result = Ext.DomQuery.filter(isArray ? el : [el], ss);
      return isArray ? result.length == el.length : result.length > 0;
    },

    filter: function (els, ss, nonMatches) {
      ss = ss.replace(trimRe, '');
      if (!simpleCache[ss]) {
        simpleCache[ss] = Ext.DomQuery.compile(ss, 'simple');
      }
      var result = simpleCache[ss](els);
      return nonMatches ? quickDiff(result, els) : result;
    },

    matchers: [
      {
        re: /^\.([\w-]+)/,
        select: 'n = byClassName(n, null, " {1} ");',
      },
      {
        re: /^\:([\w-]+)(?:\(((?:[^\s>\/]*|.*?))\))?/,
        select: 'n = byPseudo(n, "{1}", "{2}");',
      },
      {
        re: /^(?:([\[\{])(?:@)?([\w-]+)\s?(?:(=|.=)\s?['"]?(.*?)["']?)?[\]\}])/,
        select: 'n = byAttribute(n, "{2}", "{4}", "{3}", "{1}");',
      },
      {
        re: /^#([\w-]+)/,
        select: 'n = byId(n, null, "{1}");',
      },
      {
        re: /^@([\w-]+)/,
        select: 'return {firstChild:{nodeValue:attrValue(n, "{1}")}};',
      },
    ],

    operators: {
      '=': function (a, v) {
        return a == v;
      },
      '!=': function (a, v) {
        return a != v;
      },
      '^=': function (a, v) {
        return a && a.substr(0, v.length) == v;
      },
      '$=': function (a, v) {
        return a && a.substr(a.length - v.length) == v;
      },
      '*=': function (a, v) {
        return a && a.indexOf(v) !== -1;
      },
      '%=': function (a, v) {
        return a % v == 0;
      },
      '|=': function (a, v) {
        return a && (a == v || a.substr(0, v.length + 1) == v + '-');
      },
      '~=': function (a, v) {
        return a && (' ' + a + ' ').indexOf(' ' + v + ' ') != -1;
      },
    },

    pseudos: {
      'first-child': function (c) {
        var r = [],
          ri = -1,
          n;
        for (var i = 0, ci; (ci = n = c[i]); i++) {
          while ((n = n.previousSibling) && n.nodeType != 1);
          if (!n) {
            r[++ri] = ci;
          }
        }
        return r;
      },

      'last-child': function (c) {
        var r = [],
          ri = -1,
          n;
        for (var i = 0, ci; (ci = n = c[i]); i++) {
          while ((n = n.nextSibling) && n.nodeType != 1);
          if (!n) {
            r[++ri] = ci;
          }
        }
        return r;
      },

      'nth-child': function (c, a) {
        var r = [],
          ri = -1;
        var m = nthRe.exec(
          (a == 'even' && '2n') ||
            (a == 'odd' && '2n+1') ||
            (!nthRe2.test(a) && 'n+' + a) ||
            a,
        );
        var f = (m[1] || 1) - 0,
          l = m[2] - 0;
        for (var i = 0, n; (n = c[i]); i++) {
          var pn = n.parentNode;
          if (batch != pn._batch) {
            var j = 0;
            for (var cn = pn.firstChild; cn; cn = cn.nextSibling) {
              if (cn.nodeType == 1) {
                cn.nodeIndex = ++j;
              }
            }
            pn._batch = batch;
          }
          if (f == 1) {
            if (l == 0 || n.nodeIndex == l) {
              r[++ri] = n;
            }
          } else if ((n.nodeIndex + l) % f == 0) {
            r[++ri] = n;
          }
        }

        return r;
      },

      'only-child': function (c) {
        var r = [],
          ri = -1;
        for (var i = 0, ci; (ci = c[i]); i++) {
          if (!prev(ci) && !next(ci)) {
            r[++ri] = ci;
          }
        }
        return r;
      },

      empty: function (c) {
        var r = [],
          ri = -1;
        for (var i = 0, ci; (ci = c[i]); i++) {
          var cns = ci.childNodes,
            j = 0,
            cn,
            empty = true;
          while ((cn = cns[j])) {
            ++j;
            if (cn.nodeType == 1 || cn.nodeType == 3) {
              empty = false;
              break;
            }
          }
          if (empty) {
            r[++ri] = ci;
          }
        }
        return r;
      },

      contains: function (c, v) {
        var r = [],
          ri = -1;
        for (var i = 0, ci; (ci = c[i]); i++) {
          if ((ci.textContent || ci.innerText || '').indexOf(v) != -1) {
            r[++ri] = ci;
          }
        }
        return r;
      },

      nodeValue: function (c, v) {
        var r = [],
          ri = -1;
        for (var i = 0, ci; (ci = c[i]); i++) {
          if (ci.firstChild && ci.firstChild.nodeValue == v) {
            r[++ri] = ci;
          }
        }
        return r;
      },

      checked: function (c) {
        var r = [],
          ri = -1;
        for (var i = 0, ci; (ci = c[i]); i++) {
          if (ci.checked == true) {
            r[++ri] = ci;
          }
        }
        return r;
      },

      not: function (c, ss) {
        return Ext.DomQuery.filter(c, ss, true);
      },

      any: function (c, selectors) {
        var ss = selectors.split('|');
        var r = [],
          ri = -1,
          s;
        for (var i = 0, ci; (ci = c[i]); i++) {
          for (var j = 0; (s = ss[j]); j++) {
            if (Ext.DomQuery.is(ci, s)) {
              r[++ri] = ci;
              break;
            }
          }
        }
        return r;
      },

      odd: function (c) {
        return this['nth-child'](c, 'odd');
      },

      even: function (c) {
        return this['nth-child'](c, 'even');
      },

      nth: function (c, a) {
        return c[a - 1] || [];
      },

      first: function (c) {
        return c[0] || [];
      },

      last: function (c) {
        return c[c.length - 1] || [];
      },

      has: function (c, ss) {
        var s = Ext.DomQuery.select;
        var r = [],
          ri = -1;
        for (var i = 0, ci; (ci = c[i]); i++) {
          if (s(ss, ci).length > 0) {
            r[++ri] = ci;
          }
        }
        return r;
      },

      next: function (c, ss) {
        var is = Ext.DomQuery.is;
        var r = [],
          ri = -1;
        for (var i = 0, ci; (ci = c[i]); i++) {
          var n = next(ci);
          if (n && is(n, ss)) {
            r[++ri] = ci;
          }
        }
        return r;
      },

      prev: function (c, ss) {
        var is = Ext.DomQuery.is;
        var r = [],
          ri = -1;
        for (var i = 0, ci; (ci = c[i]); i++) {
          var n = prev(ci);
          if (n && is(n, ss)) {
            r[++ri] = ci;
          }
        }
        return r;
      },
    },
  };
})();

Ext.query = Ext.DomQuery.select;

Ext.util.Observable = function () {
  if (this.listeners) {
    this.on(this.listeners);
    delete this.listeners;
  }
};
Ext.util.Observable.prototype = {
  fireEvent: function () {
    if (this.eventsSuspended !== true) {
      var ce = this.events[arguments[0].toLowerCase()];
      if (typeof ce == 'object') {
        return ce.fire.apply(ce, Array.prototype.slice.call(arguments, 1));
      }
    }
    return true;
  },

  // private
  filterOptRe: /^(?:scope|delay|buffer|single)$/,

  addListener: function (eventName, fn, scope, o) {
    if (typeof eventName == 'object') {
      o = eventName;
      for (var e in o) {
        if (this.filterOptRe.test(e)) {
          continue;
        }
        if (typeof o[e] == 'function') {
          // shared options
          this.addListener(e, o[e], o.scope, o);
        } else {
          // individual options
          this.addListener(e, o[e].fn, o[e].scope, o[e]);
        }
      }
      return;
    }
    o = !o || typeof o == 'boolean' ? {} : o;
    eventName = eventName.toLowerCase();
    var ce = this.events[eventName] || true;
    if (typeof ce == 'boolean') {
      ce = new Ext.util.Event(this, eventName);
      this.events[eventName] = ce;
    }
    ce.addListener(fn, scope, o);
  },

  removeListener: function (eventName, fn, scope) {
    var ce = this.events[eventName.toLowerCase()];
    if (typeof ce == 'object') {
      ce.removeListener(fn, scope);
    }
  },

  purgeListeners: function () {
    for (var evt in this.events) {
      if (typeof this.events[evt] == 'object') {
        this.events[evt].clearListeners();
      }
    }
  },

  relayEvents: function (o, events) {
    var createHandler = function (ename) {
      return function () {
        return this.fireEvent.apply(
          this,
          Ext.combine(ename, Array.prototype.slice.call(arguments, 0)),
        );
      };
    };
    for (var i = 0, len = events.length; i < len; i++) {
      var ename = events[i];
      if (!this.events[ename]) {
        this.events[ename] = true;
      }
      o.on(ename, createHandler(ename), this);
    }
  },

  addEvents: function (o) {
    if (!this.events) {
      this.events = {};
    }
    if (typeof o == 'string') {
      for (var i = 0, a = arguments, v; (v = a[i]); i++) {
        if (!this.events[a[i]]) {
          this.events[a[i]] = true;
        }
      }
    } else {
      Ext.applyIf(this.events, o);
    }
  },

  hasListener: function (eventName) {
    var e = this.events[eventName];
    return typeof e == 'object' && e.listeners.length > 0;
  },

  suspendEvents: function () {
    this.eventsSuspended = true;
  },

  resumeEvents: function () {
    this.eventsSuspended = false;
  },

  // these are considered experimental
  // allows for easier interceptor and sequences, including cancelling and overwriting the return value of the call
  // private
  getMethodEvent: function (method) {
    if (!this.methodEvents) {
      this.methodEvents = {};
    }
    var e = this.methodEvents[method];
    if (!e) {
      e = {};
      this.methodEvents[method] = e;

      e.originalFn = this[method];
      e.methodName = method;
      e.before = [];
      e.after = [];

      var returnValue, v, cancel;
      var obj = this;

      var makeCall = function (fn, scope, args) {
        if ((v = fn.apply(scope || obj, args)) !== undefined) {
          if (typeof v === 'object') {
            if (v.returnValue !== undefined) {
              returnValue = v.returnValue;
            } else {
              returnValue = v;
            }
            if (v.cancel === true) {
              cancel = true;
            }
          } else if (v === false) {
            cancel = true;
          } else {
            returnValue = v;
          }
        }
      };

      this[method] = function () {
        returnValue = v = undefined;
        cancel = false;
        var args = Array.prototype.slice.call(arguments, 0);
        for (var i = 0, len = e.before.length; i < len; i++) {
          makeCall(e.before[i].fn, e.before[i].scope, args);
          if (cancel) {
            return returnValue;
          }
        }

        if ((v = e.originalFn.apply(obj, args)) !== undefined) {
          returnValue = v;
        }

        for (var i = 0, len = e.after.length; i < len; i++) {
          makeCall(e.after[i].fn, e.after[i].scope, args);
          if (cancel) {
            return returnValue;
          }
        }
        return returnValue;
      };
    }
    return e;
  },

  // adds an "interceptor" called before the original method
  beforeMethod: function (method, fn, scope) {
    var e = this.getMethodEvent(method);
    e.before.push({ fn: fn, scope: scope });
  },

  // adds a "sequence" called after the original method
  afterMethod: function (method, fn, scope) {
    var e = this.getMethodEvent(method);
    e.after.push({ fn: fn, scope: scope });
  },

  removeMethodListener: function (method, fn, scope) {
    var e = this.getMethodEvent(method);
    for (var i = 0, len = e.before.length; i < len; i++) {
      if (e.before[i].fn == fn && e.before[i].scope == scope) {
        e.before.splice(i, 1);
        return;
      }
    }
    for (var i = 0, len = e.after.length; i < len; i++) {
      if (e.after[i].fn == fn && e.after[i].scope == scope) {
        e.after.splice(i, 1);
        return;
      }
    }
  },
};

Ext.util.Observable.prototype.on = Ext.util.Observable.prototype.addListener;

Ext.util.Observable.prototype.un = Ext.util.Observable.prototype.removeListener;

Ext.util.Observable.capture = function (o, fn, scope) {
  o.fireEvent = o.fireEvent.createInterceptor(fn, scope);
};

Ext.util.Observable.releaseCapture = function (o) {
  o.fireEvent = Ext.util.Observable.prototype.fireEvent;
};

(function () {
  var createBuffered = function (h, o, scope) {
    var task = new Ext.util.DelayedTask();
    return function () {
      task.delay(o.buffer, h, scope, Array.prototype.slice.call(arguments, 0));
    };
  };

  var createSingle = function (h, e, fn, scope) {
    return function () {
      e.removeListener(fn, scope);
      return h.apply(scope, arguments);
    };
  };

  var createDelayed = function (h, o, scope) {
    return function () {
      var args = Array.prototype.slice.call(arguments, 0);
      setTimeout(function () {
        h.apply(scope, args);
      }, o.delay || 10);
    };
  };

  Ext.util.Event = function (obj, name) {
    this.name = name;
    this.obj = obj;
    this.listeners = [];
  };

  Ext.util.Event.prototype = {
    addListener: function (fn, scope, options) {
      scope = scope || this.obj;
      if (!this.isListening(fn, scope)) {
        var l = this.createListener(fn, scope, options);
        if (!this.firing) {
          this.listeners.push(l);
        } else {
          // if we are currently firing this event, don't disturb the listener loop
          this.listeners = this.listeners.slice(0);
          this.listeners.push(l);
        }
      }
    },

    createListener: function (fn, scope, o) {
      o = o || {};
      scope = scope || this.obj;
      var l = { fn: fn, scope: scope, options: o };
      var h = fn;
      if (o.delay) {
        h = createDelayed(h, o, scope);
      }
      if (o.single) {
        h = createSingle(h, this, fn, scope);
      }
      if (o.buffer) {
        h = createBuffered(h, o, scope);
      }
      l.fireFn = h;
      return l;
    },

    findListener: function (fn, scope) {
      scope = scope || this.obj;
      var ls = this.listeners;
      for (var i = 0, len = ls.length; i < len; i++) {
        var l = ls[i];
        if (l.fn == fn && l.scope == scope) {
          return i;
        }
      }
      return -1;
    },

    isListening: function (fn, scope) {
      return this.findListener(fn, scope) != -1;
    },

    removeListener: function (fn, scope) {
      var index;
      if ((index = this.findListener(fn, scope)) != -1) {
        if (!this.firing) {
          this.listeners.splice(index, 1);
        } else {
          this.listeners = this.listeners.slice(0);
          this.listeners.splice(index, 1);
        }
        return true;
      }
      return false;
    },

    clearListeners: function () {
      this.listeners = [];
    },

    fire: function () {
      var ls = this.listeners,
        scope,
        len = ls.length;
      if (len > 0) {
        this.firing = true;
        var args = Array.prototype.slice.call(arguments, 0);
        for (var i = 0; i < len; i++) {
          var l = ls[i];
          if (
            l.fireFn.apply(l.scope || this.obj || window, arguments) === false
          ) {
            this.firing = false;
            return false;
          }
        }
        this.firing = false;
      }
      return true;
    },
  };
})();

Ext.EventManager = (function () {
  var docReadyEvent,
    docReadyProcId,
    docReadyState = false;
  var resizeEvent, resizeTask, textEvent, textSize;
  var E = Ext.lib.Event;
  var D = Ext.lib.Dom;
  // fix parser confusion
  var xname = 'Ex' + 't';

  var elHash = {};

  var addListener = function (el, ename, fn, wrap, scope) {
    var id = Ext.id(el);
    if (!elHash[id]) {
      elHash[id] = {};
    }
    var es = elHash[id];
    if (!es[ename]) {
      es[ename] = [];
    }
    var ls = es[ename];
    ls.push({
      id: id,
      ename: ename,
      fn: fn,
      wrap: wrap,
      scope: scope,
    });

    E.on(el, ename, wrap);

    if (ename == 'mousewheel' && el.addEventListener) {
      // workaround for jQuery
      el.addEventListener('DOMMouseScroll', wrap, false);
      E.on(window, 'unload', function () {
        el.removeEventListener('DOMMouseScroll', wrap, false);
      });
    }
    if (ename == 'mousedown' && el == document) {
      // fix stopped mousedowns on the document
      Ext.EventManager.stoppedMouseDownEvent.addListener(wrap);
    }
  };

  var removeListener = function (el, ename, fn, scope) {
    el = Ext.getDom(el);

    var id = Ext.id(el),
      es = elHash[id],
      wrap;
    if (es) {
      var ls = es[ename],
        l;
      if (ls) {
        for (var i = 0, len = ls.length; i < len; i++) {
          l = ls[i];
          if (l.fn == fn && (!scope || l.scope == scope)) {
            wrap = l.wrap;
            E.un(el, ename, wrap);
            ls.splice(i, 1);
            break;
          }
        }
      }
    }
    if (ename == 'mousewheel' && el.addEventListener && wrap) {
      el.removeEventListener('DOMMouseScroll', wrap, false);
    }
    if (ename == 'mousedown' && el == document && wrap) {
      // fix stopped mousedowns on the document
      Ext.EventManager.stoppedMouseDownEvent.removeListener(wrap);
    }
  };

  var removeAll = function (el) {
    el = Ext.getDom(el);
    var id = Ext.id(el),
      es = elHash[id],
      ls;
    if (es) {
      for (var ename in es) {
        if (es.hasOwnProperty(ename)) {
          ls = es[ename];
          for (var i = 0, len = ls.length; i < len; i++) {
            E.un(el, ename, ls[i].wrap);
            ls[i] = null;
          }
        }
        es[ename] = null;
      }
      delete elHash[id];
    }
  };

  var fireDocReady = function () {
    if (!docReadyState) {
      docReadyState = true;
      Ext.isReady = true;
      if (docReadyProcId) {
        clearInterval(docReadyProcId);
      }
      if (Ext.isGecko || Ext.isOpera) {
        document.removeEventListener('DOMContentLoaded', fireDocReady, false);
      }
      if (Ext.isIE) {
        var defer = document.getElementById('ie-deferred-loader');
        if (defer) {
          defer.onreadystatechange = null;
          defer.parentNode.removeChild(defer);
        }
      }
      if (docReadyEvent) {
        docReadyEvent.fire();
        docReadyEvent.clearListeners();
      }
    }
  };

  var initDocReady = function () {
    docReadyEvent = new Ext.util.Event();
    if (Ext.isGecko || Ext.isOpera) {
      document.addEventListener('DOMContentLoaded', fireDocReady, false);
    } else if (Ext.isIE) {
      document.write(
        '<s' +
          'cript id="ie-deferred-loader" defer="defer" src="/' +
          '/:"></s' +
          'cript>',
      );
      var defer = document.getElementById('ie-deferred-loader');
      defer.onreadystatechange = function () {
        if (this.readyState == 'complete') {
          fireDocReady();
        }
      };
    } else if (Ext.isWebKit) {
      docReadyProcId = setInterval(function () {
        var rs = document.readyState;
        if (rs == 'complete') {
          fireDocReady();
        }
      }, 10);
    }
    // no matter what, make sure it fires on load
    E.on(window, 'load', fireDocReady);
  };

  var createBuffered = function (h, o) {
    var task = new Ext.util.DelayedTask(h);
    return function (e) {
      // create new event object impl so new events don't wipe out properties
      e = new Ext.EventObjectImpl(e);
      task.delay(o.buffer, h, null, [e]);
    };
  };

  var createSingle = function (h, el, ename, fn, scope) {
    return function (e) {
      Ext.EventManager.removeListener(el, ename, fn, scope);
      h(e);
    };
  };

  var createDelayed = function (h, o) {
    return function (e) {
      // create new event object impl so new events don't wipe out properties
      e = new Ext.EventObjectImpl(e);
      setTimeout(function () {
        h(e);
      }, o.delay || 10);
    };
  };

  var listen = function (element, ename, opt, fn, scope) {
    var o = !opt || typeof opt == 'boolean' ? {} : opt;
    fn = fn || o.fn;
    scope = scope || o.scope;
    var el = Ext.getDom(element);
    if (!el) {
      throw (
        'Error listening for "' +
        ename +
        '". Element "' +
        element +
        '" doesn\'t exist.'
      );
    }
    var h = function (e) {
      // prevent errors while unload occurring
      if (!window[xname]) {
        return;
      }
      e = Ext.EventObject.setEvent(e);
      var t;
      if (o.delegate) {
        t = e.getTarget(o.delegate, el);
        if (!t) {
          return;
        }
      } else {
        t = e.target;
      }
      if (o.stopEvent === true) {
        e.stopEvent();
      }
      if (o.preventDefault === true) {
        e.preventDefault();
      }
      if (o.stopPropagation === true) {
        e.stopPropagation();
      }

      if (o.normalized === false) {
        e = e.browserEvent;
      }

      fn.call(scope || el, e, t, o);
    };
    if (o.delay) {
      h = createDelayed(h, o);
    }
    if (o.single) {
      h = createSingle(h, el, ename, fn, scope);
    }
    if (o.buffer) {
      h = createBuffered(h, o);
    }

    addListener(el, ename, fn, h, scope);
    return h;
  };

  var propRe =
      /^(?:scope|delay|buffer|single|stopEvent|preventDefault|stopPropagation|normalized|args|delegate)$/,
    curWidth = 0,
    curHeight = 0;
  var pub = {
    addListener: function (element, eventName, fn, scope, options) {
      if (typeof eventName == 'object') {
        var o = eventName;
        for (var e in o) {
          if (propRe.test(e)) {
            continue;
          }
          if (typeof o[e] == 'function') {
            // shared options
            listen(element, e, o, o[e], o.scope);
          } else {
            // individual options
            listen(element, e, o[e]);
          }
        }
        return;
      }
      return listen(element, eventName, options, fn, scope);
    },

    removeListener: function (element, eventName, fn, scope) {
      return removeListener(element, eventName, fn, scope);
    },

    removeAll: function (element) {
      return removeAll(element);
    },

    onDocumentReady: function (fn, scope, options) {
      if (docReadyState) {
        // if it already fired
        docReadyEvent.addListener(fn, scope, options);
        docReadyEvent.fire();
        docReadyEvent.clearListeners();
        return;
      }
      if (!docReadyEvent) {
        initDocReady();
      }
      options = options || {};
      if (!options.delay) {
        options.delay = 1;
      }
      docReadyEvent.addListener(fn, scope, options);
    },

    // private
    doResizeEvent: function () {
      var h = D.getViewHeight(),
        w = D.getViewWidth();

      //whacky problem in IE where the resize event will fire even though the w/h are the same.
      if (curHeight != h || curWidth != w) {
        resizeEvent.fire((curWidth = w), (curHeight = h));
      }
    },

    onWindowResize: function (fn, scope, options) {
      if (!resizeEvent) {
        resizeEvent = new Ext.util.Event();
        resizeTask = new Ext.util.DelayedTask(this.doResizeEvent);
        E.on(window, 'resize', this.fireWindowResize, this);
      }
      resizeEvent.addListener(fn, scope, options);
    },

    // exposed only to allow manual firing
    fireWindowResize: function () {
      if (resizeEvent) {
        if ((Ext.isIE || Ext.isAir) && resizeTask) {
          resizeTask.delay(50);
        } else {
          resizeEvent.fire(D.getViewWidth(), D.getViewHeight());
        }
      }
    },

    onTextResize: function (fn, scope, options) {
      if (!textEvent) {
        textEvent = new Ext.util.Event();
        var textEl = new Ext.Element(document.createElement('div'));
        textEl.dom.className = 'x-text-resize';
        textEl.dom.innerHTML = 'X';
        textEl.appendTo(document.body);
        textSize = textEl.dom.offsetHeight;
        setInterval(function () {
          if (textEl.dom.offsetHeight != textSize) {
            textEvent.fire(textSize, (textSize = textEl.dom.offsetHeight));
          }
        }, this.textResizeInterval);
      }
      textEvent.addListener(fn, scope, options);
    },

    removeResizeListener: function (fn, scope) {
      if (resizeEvent) {
        resizeEvent.removeListener(fn, scope);
      }
    },

    // private
    fireResize: function () {
      if (resizeEvent) {
        resizeEvent.fire(D.getViewWidth(), D.getViewHeight());
      }
    },

    ieDeferSrc: false,

    textResizeInterval: 50,
  };

  pub.on = pub.addListener;

  pub.un = pub.removeListener;

  pub.stoppedMouseDownEvent = new Ext.util.Event();
  return pub;
})();

Ext.onReady = Ext.EventManager.onDocumentReady;

// Initialize doc classes
(function () {
  var initExtCss = function () {
    // find the body element
    var bd = document.body || document.getElementsByTagName('body')[0];
    if (!bd) {
      return false;
    }
    var cls = [
      ' ',
      Ext.isIE
        ? 'ext-ie ' +
          (Ext.isIE6 ? 'ext-ie6' : Ext.isIE7 ? 'ext-ie7' : 'ext-ie8')
        : Ext.isGecko
        ? 'ext-gecko ' + (Ext.isGecko2 ? 'ext-gecko2' : 'ext-gecko3')
        : Ext.isOpera
        ? 'ext-opera'
        : Ext.isSafari
        ? 'ext-safari'
        : Ext.isChrome
        ? 'ext-chrome'
        : '',
    ];

    if (Ext.isMac) {
      cls.push('ext-mac');
    }
    if (Ext.isLinux) {
      cls.push('ext-linux');
    }

    if (Ext.isStrict || Ext.isBorderBox) {
      // add to the parent to allow for selectors like ".ext-strict .ext-ie"
      var p = bd.parentNode;
      if (p) {
        p.className += Ext.isStrict ? ' ext-strict' : ' ext-border-box';
      }
    }
    bd.className += cls.join(' ');
    return true;
  };

  if (!initExtCss()) {
    Ext.onReady(initExtCss);
  }
})();

Ext.EventObject = (function () {
  var E = Ext.lib.Event;

  // safari keypress events for special keys return bad keycodes
  var safariKeys = {
    3: 13, // enter
    63234: 37, // left
    63235: 39, // right
    63232: 38, // up
    63233: 40, // down
    63276: 33, // page up
    63277: 34, // page down
    63272: 46, // delete
    63273: 36, // home
    63275: 35, // end
  };

  // normalize button clicks
  var btnMap = Ext.isIE
    ? { 1: 0, 4: 1, 2: 2 }
    : Ext.isWebKit
    ? { 1: 0, 2: 1, 3: 2 }
    : { 0: 0, 1: 1, 2: 2 };

  Ext.EventObjectImpl = function (e) {
    if (e) {
      this.setEvent(e.browserEvent || e);
    }
  };

  Ext.EventObjectImpl.prototype = {
    browserEvent: null,

    button: -1,

    shiftKey: false,

    ctrlKey: false,

    altKey: false,

    BACKSPACE: 8,

    TAB: 9,

    NUM_CENTER: 12,

    ENTER: 13,

    RETURN: 13,

    SHIFT: 16,

    CTRL: 17,
    CONTROL: 17, // legacy

    ALT: 18,

    PAUSE: 19,

    CAPS_LOCK: 20,

    ESC: 27,

    SPACE: 32,

    PAGE_UP: 33,
    PAGEUP: 33, // legacy

    PAGE_DOWN: 34,
    PAGEDOWN: 34, // legacy

    END: 35,

    HOME: 36,

    LEFT: 37,

    UP: 38,

    RIGHT: 39,

    DOWN: 40,

    PRINT_SCREEN: 44,

    INSERT: 45,

    DELETE: 46,

    ZERO: 48,

    ONE: 49,

    TWO: 50,

    THREE: 51,

    FOUR: 52,

    FIVE: 53,

    SIX: 54,

    SEVEN: 55,

    EIGHT: 56,

    NINE: 57,

    A: 65,

    B: 66,

    C: 67,

    D: 68,

    E: 69,

    F: 70,

    G: 71,

    H: 72,

    I: 73,

    J: 74,

    K: 75,

    L: 76,

    M: 77,

    N: 78,

    O: 79,

    P: 80,

    Q: 81,

    R: 82,

    S: 83,

    T: 84,

    U: 85,

    V: 86,

    W: 87,

    X: 88,

    Y: 89,

    Z: 90,

    CONTEXT_MENU: 93,

    NUM_ZERO: 96,

    NUM_ONE: 97,

    NUM_TWO: 98,

    NUM_THREE: 99,

    NUM_FOUR: 100,

    NUM_FIVE: 101,

    NUM_SIX: 102,

    NUM_SEVEN: 103,

    NUM_EIGHT: 104,

    NUM_NINE: 105,

    NUM_MULTIPLY: 106,

    NUM_PLUS: 107,

    NUM_MINUS: 109,

    NUM_PERIOD: 110,

    NUM_DIVISION: 111,

    F1: 112,

    F2: 113,

    F3: 114,

    F4: 115,

    F5: 116,

    F6: 117,

    F7: 118,

    F8: 119,

    F9: 120,

    F10: 121,

    F11: 122,

    F12: 123,

    setEvent: function (e) {
      if (e == this || (e && e.browserEvent)) {
        // already wrapped
        return e;
      }
      this.browserEvent = e;
      if (e) {
        // normalize buttons
        this.button = e.button ? btnMap[e.button] : e.which ? e.which - 1 : -1;
        if (e.type == 'click' && this.button == -1) {
          this.button = 0;
        }
        this.type = e.type;
        this.shiftKey = e.shiftKey;
        // mac metaKey behaves like ctrlKey
        this.ctrlKey = e.ctrlKey || e.metaKey;
        this.altKey = e.altKey;
        // in getKey these will be normalized for the mac
        this.keyCode = e.keyCode;
        this.charCode = e.charCode;
        // cache the target for the delayed and or buffered events
        this.target = E.getTarget(e);
        // same for XY
        this.xy = E.getXY(e);
      } else {
        this.button = -1;
        this.shiftKey = false;
        this.ctrlKey = false;
        this.altKey = false;
        this.keyCode = 0;
        this.charCode = 0;
        this.target = null;
        this.xy = [0, 0];
      }
      return this;
    },

    stopEvent: function () {
      if (this.browserEvent) {
        if (this.browserEvent.type == 'mousedown') {
          Ext.EventManager.stoppedMouseDownEvent.fire(this);
        }
        E.stopEvent(this.browserEvent);
      }
    },

    preventDefault: function () {
      if (this.browserEvent) {
        E.preventDefault(this.browserEvent);
      }
    },

    isNavKeyPress: function () {
      var k = this.keyCode;
      k = Ext.isSafari ? safariKeys[k] || k : k;
      return (
        (k >= 33 && k <= 40) ||
        k == this.RETURN ||
        k == this.TAB ||
        k == this.ESC
      );
    },

    isSpecialKey: function () {
      var k = this.keyCode;
      k = Ext.isSafari ? safariKeys[k] || k : k;
      return (
        (this.type == 'keypress' && this.ctrlKey) ||
        this.isNavKeyPress() ||
        k == this.BACKSPACE || // Backspace
        (k >= 16 && k <= 20) || // Shift, Ctrl, Alt, Pause, Caps Lock
        (k >= 44 && k <= 45)
      ); // Print Screen, Insert
    },

    stopPropagation: function () {
      if (this.browserEvent) {
        if (this.browserEvent.type == 'mousedown') {
          Ext.EventManager.stoppedMouseDownEvent.fire(this);
        }
        E.stopPropagation(this.browserEvent);
      }
    },

    getCharCode: function () {
      return this.charCode || this.keyCode;
    },

    getKey: function () {
      var k = this.keyCode || this.charCode;
      return Ext.isSafari ? safariKeys[k] || k : k;
    },

    getPageX: function () {
      return this.xy[0];
    },

    getPageY: function () {
      return this.xy[1];
    },

    getTime: function () {
      if (this.browserEvent) {
        return E.getTime(this.browserEvent);
      }
      return null;
    },

    getXY: function () {
      return this.xy;
    },

    getTarget: function (selector, maxDepth, returnEl) {
      return selector
        ? Ext.fly(this.target).findParent(selector, maxDepth, returnEl)
        : returnEl
        ? Ext.get(this.target)
        : this.target;
    },

    getRelatedTarget: function () {
      if (this.browserEvent) {
        return E.getRelatedTarget(this.browserEvent);
      }
      return null;
    },

    getWheelDelta: function () {
      var e = this.browserEvent;
      var delta = 0;
      if (e.wheelDelta) {
        delta = e.wheelDelta / 120;
      } else if (e.detail) {
        delta = -e.detail / 3;
      }
      return delta;
    },

    hasModifier: function () {
      return this.ctrlKey || this.altKey || this.shiftKey ? true : false;
    },

    within: function (el, related, allowEl) {
      var t = this[related ? 'getRelatedTarget' : 'getTarget']();
      return (
        t &&
        ((allowEl ? t === Ext.getDom(el) : false) || Ext.fly(el).contains(t))
      );
    },

    getPoint: function () {
      return new Ext.lib.Point(this.xy[0], this.xy[1]);
    },
  };

  return new Ext.EventObjectImpl();
})();

(function () {
  var D = Ext.lib.Dom;
  var E = Ext.lib.Event;
  var A = Ext.lib.Anim;

  // local style camelizing for speed
  var propCache = {};
  var camelRe = /(-[a-z])/gi;
  var camelFn = function (m, a) {
    return a.charAt(1).toUpperCase();
  };
  var view = document.defaultView;

  Ext.Element = function (element, forceNew) {
    var dom =
      typeof element == 'string' ? document.getElementById(element) : element;
    if (!dom) {
      // invalid id/element
      return null;
    }
    var id = dom.id;
    if (forceNew !== true && id && Ext.Element.cache[id]) {
      // element object already exists
      return Ext.Element.cache[id];
    }

    this.dom = dom;

    this.id = id || Ext.id(dom);
  };

  var El = Ext.Element;

  El.prototype = {
    //  Mouse events

    //  Keyboard events

    //  HTML frame/object events

    //  Form events

    //  User Interface events

    //  DOM Mutation events

    originalDisplay: '',

    visibilityMode: 1,

    defaultUnit: 'px',

    setVisibilityMode: function (visMode) {
      this.visibilityMode = visMode;
      return this;
    },

    enableDisplayMode: function (display) {
      this.setVisibilityMode(El.DISPLAY);
      if (typeof display != 'undefined') this.originalDisplay = display;
      return this;
    },

    findParent: function (simpleSelector, maxDepth, returnEl) {
      var p = this.dom,
        b = document.body,
        depth = 0,
        dq = Ext.DomQuery,
        stopEl;
      maxDepth = maxDepth || 50;
      if (typeof maxDepth != 'number') {
        stopEl = Ext.getDom(maxDepth);
        maxDepth = Number.MAX_VALUE;
      }
      while (
        p &&
        p.nodeType == 1 &&
        depth < maxDepth &&
        p != b &&
        p != stopEl
      ) {
        if (dq.is(p, simpleSelector)) {
          return returnEl ? Ext.get(p) : p;
        }
        depth++;
        p = p.parentNode;
      }
      return null;
    },

    findParentNode: function (simpleSelector, maxDepth, returnEl) {
      var p = Ext.fly(this.dom.parentNode, '_internal');
      return p ? p.findParent(simpleSelector, maxDepth, returnEl) : null;
    },

    up: function (simpleSelector, maxDepth) {
      return this.findParentNode(simpleSelector, maxDepth, true);
    },

    is: function (simpleSelector) {
      return Ext.DomQuery.is(this.dom, simpleSelector);
    },

    animate: function (args, duration, onComplete, easing, animType) {
      this.anim(
        args,
        { duration: duration, callback: onComplete, easing: easing },
        animType,
      );
      return this;
    },

    anim: function (args, opt, animType, defaultDur, defaultEase, cb) {
      animType = animType || 'run';
      opt = opt || {};
      var anim = Ext.lib.Anim[animType](
        this.dom,
        args,
        opt.duration || defaultDur || 0.35,
        opt.easing || defaultEase || 'easeOut',
        function () {
          Ext.callback(cb, this);
          Ext.callback(opt.callback, opt.scope || this, [this, opt]);
        },
        this,
      );
      opt.anim = anim;
      return anim;
    },

    // private legacy anim prep
    preanim: function (a, i) {
      return !a[i]
        ? false
        : typeof a[i] == 'object'
        ? a[i]
        : { duration: a[i + 1], callback: a[i + 2], easing: a[i + 3] };
    },

    clean: function (forceReclean) {
      if (this.isCleaned && forceReclean !== true) {
        return this;
      }
      var ns = /\S/;
      var d = this.dom,
        n = d.firstChild,
        ni = -1;
      while (n) {
        var nx = n.nextSibling;
        if (n.nodeType == 3 && !ns.test(n.nodeValue)) {
          d.removeChild(n);
        } else {
          n.nodeIndex = ++ni;
        }
        n = nx;
      }
      this.isCleaned = true;
      return this;
    },

    scrollIntoView: function (container, hscroll) {
      var c = Ext.getDom(container) || Ext.getBody().dom;
      var el = this.dom;

      var o = this.getOffsetsTo(c),
        l = o[0] + c.scrollLeft,
        t = o[1] + c.scrollTop,
        b = t + el.offsetHeight,
        r = l + el.offsetWidth;

      var ch = c.clientHeight;
      var ct = parseInt(c.scrollTop, 10);
      var cl = parseInt(c.scrollLeft, 10);
      var cb = ct + ch;
      var cr = cl + c.clientWidth;

      if (el.offsetHeight > ch || t < ct) {
        c.scrollTop = t;
      } else if (b > cb) {
        c.scrollTop = b - ch;
      }
      c.scrollTop = c.scrollTop; // corrects IE, other browsers will ignore

      if (hscroll !== false) {
        if (el.offsetWidth > c.clientWidth || l < cl) {
          c.scrollLeft = l;
        } else if (r > cr) {
          c.scrollLeft = r - c.clientWidth;
        }
        c.scrollLeft = c.scrollLeft;
      }
      return this;
    },

    // private
    scrollChildIntoView: function (child, hscroll) {
      Ext.fly(child, '_scrollChildIntoView').scrollIntoView(this, hscroll);
    },

    autoHeight: function (animate, duration, onComplete, easing) {
      var oldHeight = this.getHeight();
      this.clip();
      this.setHeight(1); // force clipping
      setTimeout(
        function () {
          var height = parseInt(this.dom.scrollHeight, 10); // parseInt for Safari
          if (!animate) {
            this.setHeight(height);
            this.unclip();
            if (typeof onComplete == 'function') {
              onComplete();
            }
          } else {
            this.setHeight(oldHeight); // restore original height
            this.setHeight(
              height,
              animate,
              duration,
              function () {
                this.unclip();
                if (typeof onComplete == 'function') onComplete();
              }.createDelegate(this),
              easing,
            );
          }
        }.createDelegate(this),
        0,
      );
      return this;
    },

    contains: function (el) {
      if (!el) {
        return false;
      }
      return D.isAncestor(this.dom, el.dom ? el.dom : el);
    },

    isVisible: function (deep) {
      var vis = !(
        this.getStyle('visibility') == 'hidden' ||
        this.getStyle('display') == 'none'
      );
      if (deep !== true || !vis) {
        return vis;
      }
      var p = this.dom.parentNode;
      while (p && p.tagName.toLowerCase() != 'body') {
        if (!Ext.fly(p, '_isVisible').isVisible()) {
          return false;
        }
        p = p.parentNode;
      }
      return true;
    },

    select: function (selector, unique) {
      return El.select(selector, unique, this.dom);
    },

    query: function (selector) {
      return Ext.DomQuery.select(selector, this.dom);
    },

    child: function (selector, returnDom) {
      var n = Ext.DomQuery.selectNode(selector, this.dom);
      return returnDom ? n : Ext.get(n);
    },

    down: function (selector, returnDom) {
      var n = Ext.DomQuery.selectNode(' > ' + selector, this.dom);
      return returnDom ? n : Ext.get(n);
    },

    initDD: function (group, config, overrides) {
      var dd = new Ext.dd.DD(Ext.id(this.dom), group, config);
      return Ext.apply(dd, overrides);
    },

    initDDProxy: function (group, config, overrides) {
      var dd = new Ext.dd.DDProxy(Ext.id(this.dom), group, config);
      return Ext.apply(dd, overrides);
    },

    initDDTarget: function (group, config, overrides) {
      var dd = new Ext.dd.DDTarget(Ext.id(this.dom), group, config);
      return Ext.apply(dd, overrides);
    },

    setVisible: function (visible, animate) {
      if (!animate || !A) {
        if (this.visibilityMode == El.DISPLAY) {
          this.setDisplayed(visible);
        } else {
          this.fixDisplay();
          this.dom.style.visibility = visible ? 'visible' : 'hidden';
        }
      } else {
        // closure for composites
        var dom = this.dom;
        var visMode = this.visibilityMode;
        if (visible) {
          this.setOpacity(0.01);
          this.setVisible(true);
        }
        this.anim(
          { opacity: { to: visible ? 1 : 0 } },
          this.preanim(arguments, 1),
          null,
          0.35,
          'easeIn',
          function () {
            if (!visible) {
              if (visMode == El.DISPLAY) {
                dom.style.display = 'none';
              } else {
                dom.style.visibility = 'hidden';
              }
              Ext.get(dom).setOpacity(1);
            }
          },
        );
      }
      return this;
    },

    isDisplayed: function () {
      return this.getStyle('display') != 'none';
    },

    toggle: function (animate) {
      this.setVisible(!this.isVisible(), this.preanim(arguments, 0));
      return this;
    },

    setDisplayed: function (value) {
      if (typeof value == 'boolean') {
        value = value ? this.originalDisplay : 'none';
      }
      this.setStyle('display', value);
      return this;
    },

    focus: function () {
      try {
        this.dom.focus();
      } catch (e) {}
      return this;
    },

    blur: function () {
      try {
        this.dom.blur();
      } catch (e) {}
      return this;
    },

    addClass: function (className) {
      if (Ext.isArray(className)) {
        for (var i = 0, len = className.length; i < len; i++) {
          this.addClass(className[i]);
        }
      } else {
        if (className && !this.hasClass(className)) {
          this.dom.className = this.dom.className + ' ' + className;
        }
      }
      return this;
    },

    radioClass: function (className) {
      var siblings = this.dom.parentNode.childNodes;
      for (var i = 0; i < siblings.length; i++) {
        var s = siblings[i];
        if (s.nodeType == 1) {
          Ext.get(s).removeClass(className);
        }
      }
      this.addClass(className);
      return this;
    },

    removeClass: function (className) {
      if (!className || !this.dom.className) {
        return this;
      }
      if (Ext.isArray(className)) {
        for (var i = 0, len = className.length; i < len; i++) {
          this.removeClass(className[i]);
        }
      } else {
        if (this.hasClass(className)) {
          var re = this.classReCache[className];
          if (!re) {
            re = new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)', 'g');
            this.classReCache[className] = re;
          }
          this.dom.className = this.dom.className.replace(re, ' ');
        }
      }
      return this;
    },

    // private
    classReCache: {},

    toggleClass: function (className) {
      if (this.hasClass(className)) {
        this.removeClass(className);
      } else {
        this.addClass(className);
      }
      return this;
    },

    hasClass: function (className) {
      return (
        className &&
        (' ' + this.dom.className + ' ').indexOf(' ' + className + ' ') != -1
      );
    },

    replaceClass: function (oldClassName, newClassName) {
      this.removeClass(oldClassName);
      this.addClass(newClassName);
      return this;
    },

    getStyles: function () {
      var a = arguments,
        len = a.length,
        r = {};
      for (var i = 0; i < len; i++) {
        r[a[i]] = this.getStyle(a[i]);
      }
      return r;
    },

    getStyle: (function () {
      return view && view.getComputedStyle
        ? function (prop) {
            var el = this.dom,
              v,
              cs,
              camel;
            if (prop == 'float') {
              prop = 'cssFloat';
            }
            if ((v = el.style[prop])) {
              return v;
            }
            if ((cs = view.getComputedStyle(el, ''))) {
              if (!(camel = propCache[prop])) {
                camel = propCache[prop] = prop.replace(camelRe, camelFn);
              }
              return cs[camel];
            }
            return null;
          }
        : function (prop) {
            var el = this.dom,
              v,
              cs,
              camel;
            if (prop == 'opacity') {
              if (typeof el.style.filter == 'string') {
                var m = el.style.filter.match(/alpha\(opacity=(.*)\)/i);
                if (m) {
                  var fv = parseFloat(m[1]);
                  if (!isNaN(fv)) {
                    return fv ? fv / 100 : 0;
                  }
                }
              }
              return 1;
            } else if (prop == 'float') {
              prop = 'styleFloat';
            }
            if (!(camel = propCache[prop])) {
              camel = propCache[prop] = prop.replace(camelRe, camelFn);
            }
            if ((v = el.style[camel])) {
              return v;
            }
            if ((cs = el.currentStyle)) {
              return cs[camel];
            }
            return null;
          };
    })(),

    setStyle: function (prop, value) {
      if (typeof prop == 'string') {
        var camel;
        if (!(camel = propCache[prop])) {
          camel = propCache[prop] = prop.replace(camelRe, camelFn);
        }
        if (camel == 'opacity') {
          this.setOpacity(value);
        } else {
          this.dom.style[camel] = value;
        }
      } else {
        for (var style in prop) {
          if (typeof prop[style] != 'function') {
            this.setStyle(style, prop[style]);
          }
        }
      }
      return this;
    },

    applyStyles: function (style) {
      Ext.DomHelper.applyStyles(this.dom, style);
      return this;
    },

    getX: function () {
      return D.getX(this.dom);
    },

    getY: function () {
      return D.getY(this.dom);
    },

    getXY: function () {
      return D.getXY(this.dom);
    },

    getOffsetsTo: function (el) {
      var o = this.getXY();
      var e = Ext.fly(el, '_internal').getXY();
      return [o[0] - e[0], o[1] - e[1]];
    },

    setX: function (x, animate) {
      if (!animate || !A) {
        D.setX(this.dom, x);
      } else {
        this.setXY([x, this.getY()], this.preanim(arguments, 1));
      }
      return this;
    },

    setY: function (y, animate) {
      if (!animate || !A) {
        D.setY(this.dom, y);
      } else {
        this.setXY([this.getX(), y], this.preanim(arguments, 1));
      }
      return this;
    },

    setLeft: function (left) {
      this.setStyle('left', this.addUnits(left));
      return this;
    },

    setTop: function (top) {
      this.setStyle('top', this.addUnits(top));
      return this;
    },

    setRight: function (right) {
      this.setStyle('right', this.addUnits(right));
      return this;
    },

    setBottom: function (bottom) {
      this.setStyle('bottom', this.addUnits(bottom));
      return this;
    },

    setXY: function (pos, animate) {
      if (!animate || !A) {
        D.setXY(this.dom, pos);
      } else {
        this.anim(
          { points: { to: pos } },
          this.preanim(arguments, 1),
          'motion',
        );
      }
      return this;
    },

    setLocation: function (x, y, animate) {
      this.setXY([x, y], this.preanim(arguments, 2));
      return this;
    },

    moveTo: function (x, y, animate) {
      this.setXY([x, y], this.preanim(arguments, 2));
      return this;
    },

    getRegion: function () {
      return D.getRegion(this.dom);
    },

    getHeight: function (contentHeight) {
      var h = Math.max(this.dom.offsetHeight, this.dom.clientHeight) || 0;
      h =
        contentHeight !== true
          ? h
          : h - this.getBorderWidth('tb') - this.getPadding('tb');
      return h < 0 ? 0 : h;
    },

    getWidth: function (contentWidth) {
      var w = Math.max(this.dom.offsetWidth, this.dom.clientWidth) || 0;
      w =
        contentWidth !== true
          ? w
          : w - this.getBorderWidth('lr') - this.getPadding('lr');
      return w < 0 ? 0 : w;
    },

    getComputedHeight: function () {
      var h = Math.max(this.dom.offsetHeight, this.dom.clientHeight);
      if (!h) {
        h = parseInt(this.getStyle('height'), 10) || 0;
        if (!this.isBorderBox()) {
          h += this.getFrameWidth('tb');
        }
      }
      return h;
    },

    getComputedWidth: function () {
      var w = Math.max(this.dom.offsetWidth, this.dom.clientWidth);
      if (!w) {
        w = parseInt(this.getStyle('width'), 10) || 0;
        if (!this.isBorderBox()) {
          w += this.getFrameWidth('lr');
        }
      }
      return w;
    },

    getSize: function (contentSize) {
      return {
        width: this.getWidth(contentSize),
        height: this.getHeight(contentSize),
      };
    },

    getStyleSize: function () {
      var w,
        h,
        d = this.dom,
        s = d.style;
      if (s.width && s.width != 'auto') {
        w = parseInt(s.width, 10);
        if (Ext.isBorderBox) {
          w -= this.getFrameWidth('lr');
        }
      }
      if (s.height && s.height != 'auto') {
        h = parseInt(s.height, 10);
        if (Ext.isBorderBox) {
          h -= this.getFrameWidth('tb');
        }
      }
      return {
        width: w || this.getWidth(true),
        height: h || this.getHeight(true),
      };
    },

    getViewSize: function () {
      var d = this.dom,
        doc = document,
        aw = 0,
        ah = 0;
      if (d == doc || d == doc.body) {
        return { width: D.getViewWidth(), height: D.getViewHeight() };
      } else {
        return {
          width: d.clientWidth,
          height: d.clientHeight,
        };
      }
    },

    getValue: function (asNumber) {
      return asNumber ? parseInt(this.dom.value, 10) : this.dom.value;
    },

    // private
    adjustWidth: function (width) {
      if (typeof width == 'number') {
        if (this.autoBoxAdjust && !this.isBorderBox()) {
          width -= this.getBorderWidth('lr') + this.getPadding('lr');
        }
        if (width < 0) {
          width = 0;
        }
      }
      return width;
    },

    // private
    adjustHeight: function (height) {
      if (typeof height == 'number') {
        if (this.autoBoxAdjust && !this.isBorderBox()) {
          height -= this.getBorderWidth('tb') + this.getPadding('tb');
        }
        if (height < 0) {
          height = 0;
        }
      }
      return height;
    },

    setWidth: function (width, animate) {
      width = this.adjustWidth(width);
      if (!animate || !A) {
        this.dom.style.width = this.addUnits(width);
      } else {
        this.anim({ width: { to: width } }, this.preanim(arguments, 1));
      }
      return this;
    },

    setHeight: function (height, animate) {
      height = this.adjustHeight(height);
      if (!animate || !A) {
        this.dom.style.height = this.addUnits(height);
      } else {
        this.anim({ height: { to: height } }, this.preanim(arguments, 1));
      }
      return this;
    },

    setSize: function (width, height, animate) {
      if (typeof width == 'object') {
        // in case of object from getSize()
        height = width.height;
        width = width.width;
      }
      width = this.adjustWidth(width);
      height = this.adjustHeight(height);
      if (!animate || !A) {
        this.dom.style.width = this.addUnits(width);
        this.dom.style.height = this.addUnits(height);
      } else {
        this.anim(
          { width: { to: width }, height: { to: height } },
          this.preanim(arguments, 2),
        );
      }
      return this;
    },

    setBounds: function (x, y, width, height, animate) {
      if (!animate || !A) {
        this.setSize(width, height);
        this.setLocation(x, y);
      } else {
        width = this.adjustWidth(width);
        height = this.adjustHeight(height);
        this.anim(
          {
            points: { to: [x, y] },
            width: { to: width },
            height: { to: height },
          },
          this.preanim(arguments, 4),
          'motion',
        );
      }
      return this;
    },

    setRegion: function (region, animate) {
      this.setBounds(
        region.left,
        region.top,
        region.right - region.left,
        region.bottom - region.top,
        this.preanim(arguments, 1),
      );
      return this;
    },

    addListener: function (eventName, fn, scope, options) {
      Ext.EventManager.on(this.dom, eventName, fn, scope || this, options);
    },

    removeListener: function (eventName, fn, scope) {
      Ext.EventManager.removeListener(this.dom, eventName, fn, scope || this);
      return this;
    },

    removeAllListeners: function () {
      Ext.EventManager.removeAll(this.dom);
      return this;
    },

    relayEvent: function (eventName, observable) {
      this.on(eventName, function (e) {
        observable.fireEvent(eventName, e);
      });
    },

    setOpacity: function (opacity, animate) {
      if (!animate || !A) {
        var s = this.dom.style;
        if (Ext.isIE) {
          s.zoom = 1;
          s.filter =
            (s.filter || '').replace(/alpha\([^\)]*\)/gi, '') +
            (opacity == 1 ? '' : ' alpha(opacity=' + opacity * 100 + ')');
        } else {
          s.opacity = opacity;
        }
      } else {
        this.anim(
          { opacity: { to: opacity } },
          this.preanim(arguments, 1),
          null,
          0.35,
          'easeIn',
        );
      }
      return this;
    },

    getLeft: function (local) {
      if (!local) {
        return this.getX();
      } else {
        return parseInt(this.getStyle('left'), 10) || 0;
      }
    },

    getRight: function (local) {
      if (!local) {
        return this.getX() + this.getWidth();
      } else {
        return this.getLeft(true) + this.getWidth() || 0;
      }
    },

    getTop: function (local) {
      if (!local) {
        return this.getY();
      } else {
        return parseInt(this.getStyle('top'), 10) || 0;
      }
    },

    getBottom: function (local) {
      if (!local) {
        return this.getY() + this.getHeight();
      } else {
        return this.getTop(true) + this.getHeight() || 0;
      }
    },

    position: function (pos, zIndex, x, y) {
      if (!pos) {
        if (this.getStyle('position') == 'static') {
          this.setStyle('position', 'relative');
        }
      } else {
        this.setStyle('position', pos);
      }
      if (zIndex) {
        this.setStyle('z-index', zIndex);
      }
      if (x !== undefined && y !== undefined) {
        this.setXY([x, y]);
      } else if (x !== undefined) {
        this.setX(x);
      } else if (y !== undefined) {
        this.setY(y);
      }
    },

    clearPositioning: function (value) {
      value = value || '';
      this.setStyle({
        left: value,
        right: value,
        top: value,
        bottom: value,
        'z-index': '',
        position: 'static',
      });
      return this;
    },

    getPositioning: function () {
      var l = this.getStyle('left');
      var t = this.getStyle('top');
      return {
        position: this.getStyle('position'),
        left: l,
        right: l ? '' : this.getStyle('right'),
        top: t,
        bottom: t ? '' : this.getStyle('bottom'),
        'z-index': this.getStyle('z-index'),
      };
    },

    getBorderWidth: function (side) {
      return this.addStyles(side, El.borders);
    },

    getPadding: function (side) {
      return this.addStyles(side, El.paddings);
    },

    setPositioning: function (pc) {
      this.applyStyles(pc);
      if (pc.right == 'auto') {
        this.dom.style.right = '';
      }
      if (pc.bottom == 'auto') {
        this.dom.style.bottom = '';
      }
      return this;
    },

    // private
    fixDisplay: function () {
      if (this.getStyle('display') == 'none') {
        this.setStyle('visibility', 'hidden');
        this.setStyle('display', this.originalDisplay); // first try reverting to default
        if (this.getStyle('display') == 'none') {
          // if that fails, default to block
          this.setStyle('display', 'block');
        }
      }
    },

    // private
    setOverflow: function (v) {
      if (v == 'auto' && Ext.isMac && Ext.isGecko2) {
        // work around stupid FF 2.0/Mac scroll bar bug
        this.dom.style.overflow = 'hidden';
        (function () {
          this.dom.style.overflow = 'auto';
        }).defer(1, this);
      } else {
        this.dom.style.overflow = v;
      }
    },

    setLeftTop: function (left, top) {
      this.dom.style.left = this.addUnits(left);
      this.dom.style.top = this.addUnits(top);
      return this;
    },

    move: function (direction, distance, animate) {
      var xy = this.getXY();
      direction = direction.toLowerCase();
      switch (direction) {
        case 'l':
        case 'left':
          this.moveTo(xy[0] - distance, xy[1], this.preanim(arguments, 2));
          break;
        case 'r':
        case 'right':
          this.moveTo(xy[0] + distance, xy[1], this.preanim(arguments, 2));
          break;
        case 't':
        case 'top':
        case 'up':
          this.moveTo(xy[0], xy[1] - distance, this.preanim(arguments, 2));
          break;
        case 'b':
        case 'bottom':
        case 'down':
          this.moveTo(xy[0], xy[1] + distance, this.preanim(arguments, 2));
          break;
      }
      return this;
    },

    clip: function () {
      if (!this.isClipped) {
        this.isClipped = true;
        this.originalClip = {
          o: this.getStyle('overflow'),
          x: this.getStyle('overflow-x'),
          y: this.getStyle('overflow-y'),
        };
        this.setStyle('overflow', 'hidden');
        this.setStyle('overflow-x', 'hidden');
        this.setStyle('overflow-y', 'hidden');
      }
      return this;
    },

    unclip: function () {
      if (this.isClipped) {
        this.isClipped = false;
        var o = this.originalClip;
        if (o.o) {
          this.setStyle('overflow', o.o);
        }
        if (o.x) {
          this.setStyle('overflow-x', o.x);
        }
        if (o.y) {
          this.setStyle('overflow-y', o.y);
        }
      }
      return this;
    },

    getAnchorXY: function (anchor, local, s) {
      //Passing a different size is useful for pre-calculating anchors,
      //especially for anchored animations that change the el size.

      var w,
        h,
        vp = false;
      if (!s) {
        var d = this.dom;
        if (d == document.body || d == document) {
          vp = true;
          w = D.getViewWidth();
          h = D.getViewHeight();
        } else {
          w = this.getWidth();
          h = this.getHeight();
        }
      } else {
        w = s.width;
        h = s.height;
      }
      var x = 0,
        y = 0,
        r = Math.round;
      switch ((anchor || 'tl').toLowerCase()) {
        case 'c':
          x = r(w * 0.5);
          y = r(h * 0.5);
          break;
        case 't':
          x = r(w * 0.5);
          y = 0;
          break;
        case 'l':
          x = 0;
          y = r(h * 0.5);
          break;
        case 'r':
          x = w;
          y = r(h * 0.5);
          break;
        case 'b':
          x = r(w * 0.5);
          y = h;
          break;
        case 'tl':
          x = 0;
          y = 0;
          break;
        case 'bl':
          x = 0;
          y = h;
          break;
        case 'br':
          x = w;
          y = h;
          break;
        case 'tr':
          x = w;
          y = 0;
          break;
      }
      if (local === true) {
        return [x, y];
      }
      if (vp) {
        var sc = this.getScroll();
        return [x + sc.left, y + sc.top];
      }
      //Add the element's offset xy
      var o = this.getXY();
      return [x + o[0], y + o[1]];
    },

    getAlignToXY: function (el, p, o) {
      el = Ext.get(el);
      if (!el || !el.dom) {
        throw "Element.alignToXY with an element that doesn't exist";
      }
      var d = this.dom;
      var c = false; //constrain to viewport
      var p1 = '',
        p2 = '';
      o = o || [0, 0];

      if (!p) {
        p = 'tl-bl';
      } else if (p == '?') {
        p = 'tl-bl?';
      } else if (p.indexOf('-') == -1) {
        p = 'tl-' + p;
      }
      p = p.toLowerCase();
      var m = p.match(/^([a-z]+)-([a-z]+)(\?)?$/);
      if (!m) {
        throw 'Element.alignTo with an invalid alignment ' + p;
      }
      p1 = m[1];
      p2 = m[2];
      c = !!m[3];

      //Subtract the aligned el's internal xy from the target's offset xy
      //plus custom offset to get the aligned el's new offset xy
      var a1 = this.getAnchorXY(p1, true);
      var a2 = el.getAnchorXY(p2, false);

      var x = a2[0] - a1[0] + o[0];
      var y = a2[1] - a1[1] + o[1];

      if (c) {
        //constrain the aligned el to viewport if necessary
        var w = this.getWidth(),
          h = this.getHeight(),
          r = el.getRegion();
        // 5px of margin for ie
        var dw = D.getViewWidth() - 5,
          dh = D.getViewHeight() - 5;

        //If we are at a viewport boundary and the aligned el is anchored on a target border that is
        //perpendicular to the vp border, allow the aligned el to slide on that border,
        //otherwise swap the aligned el to the opposite border of the target.
        var p1y = p1.charAt(0),
          p1x = p1.charAt(p1.length - 1);
        var p2y = p2.charAt(0),
          p2x = p2.charAt(p2.length - 1);
        var swapY = (p1y == 't' && p2y == 'b') || (p1y == 'b' && p2y == 't');
        var swapX = (p1x == 'r' && p2x == 'l') || (p1x == 'l' && p2x == 'r');

        var doc = document;
        var scrollX =
          (doc.documentElement.scrollLeft || doc.body.scrollLeft || 0) + 5;
        var scrollY =
          (doc.documentElement.scrollTop || doc.body.scrollTop || 0) + 5;

        if (x + w > dw + scrollX) {
          x = swapX ? r.left - w : dw + scrollX - w;
        }
        if (x < scrollX) {
          x = swapX ? r.right : scrollX;
        }
        if (y + h > dh + scrollY) {
          y = swapY ? r.top - h : dh + scrollY - h;
        }
        if (y < scrollY) {
          y = swapY ? r.bottom : scrollY;
        }
      }
      return [x, y];
    },

    // private
    getConstrainToXY: (function () {
      var os = { top: 0, left: 0, bottom: 0, right: 0 };

      return function (el, local, offsets, proposedXY) {
        el = Ext.get(el);
        offsets = offsets ? Ext.applyIf(offsets, os) : os;

        var vw,
          vh,
          vx = 0,
          vy = 0;
        if (el.dom == document.body || el.dom == document) {
          vw = Ext.lib.Dom.getViewWidth();
          vh = Ext.lib.Dom.getViewHeight();
        } else {
          vw = el.dom.clientWidth;
          vh = el.dom.clientHeight;
          if (!local) {
            var vxy = el.getXY();
            vx = vxy[0];
            vy = vxy[1];
          }
        }

        var s = el.getScroll();

        vx += offsets.left + s.left;
        vy += offsets.top + s.top;

        vw -= offsets.right;
        vh -= offsets.bottom;

        var vr = vx + vw;
        var vb = vy + vh;

        var xy =
          proposedXY ||
          (!local ? this.getXY() : [this.getLeft(true), this.getTop(true)]);
        var x = xy[0],
          y = xy[1];
        var w = this.dom.offsetWidth,
          h = this.dom.offsetHeight;

        // only move it if it needs it
        var moved = false;

        // first validate right/bottom
        if (x + w > vr) {
          x = vr - w;
          moved = true;
        }
        if (y + h > vb) {
          y = vb - h;
          moved = true;
        }
        // then make sure top/left isn't negative
        if (x < vx) {
          x = vx;
          moved = true;
        }
        if (y < vy) {
          y = vy;
          moved = true;
        }
        return moved ? [x, y] : false;
      };
    })(),

    // private
    adjustForConstraints: function (xy, parent, offsets) {
      return (
        this.getConstrainToXY(parent || document, false, offsets, xy) || xy
      );
    },

    alignTo: function (element, position, offsets, animate) {
      var xy = this.getAlignToXY(element, position, offsets);
      this.setXY(xy, this.preanim(arguments, 3));
      return this;
    },

    anchorTo: function (
      el,
      alignment,
      offsets,
      animate,
      monitorScroll,
      callback,
    ) {
      var action = function () {
        this.alignTo(el, alignment, offsets, animate);
        Ext.callback(callback, this);
      };
      Ext.EventManager.onWindowResize(action, this);
      var tm = typeof monitorScroll;
      if (tm != 'undefined') {
        Ext.EventManager.on(window, 'scroll', action, this, {
          buffer: tm == 'number' ? monitorScroll : 50,
        });
      }
      action.call(this); // align immediately
      return this;
    },

    clearOpacity: function () {
      if (window.ActiveXObject) {
        if (
          typeof this.dom.style.filter == 'string' &&
          /alpha/i.test(this.dom.style.filter)
        ) {
          this.dom.style.filter = '';
        }
      } else {
        this.dom.style.opacity = '';
        this.dom.style['-moz-opacity'] = '';
        this.dom.style['-khtml-opacity'] = '';
      }
      return this;
    },

    hide: function (animate) {
      this.setVisible(false, this.preanim(arguments, 0));
      return this;
    },

    show: function (animate) {
      this.setVisible(true, this.preanim(arguments, 0));
      return this;
    },

    addUnits: function (size) {
      return Ext.Element.addUnits(size, this.defaultUnit);
    },

    update: function (html, loadScripts, callback) {
      if (typeof html == 'undefined') {
        html = '';
      }
      if (loadScripts !== true) {
        this.dom.innerHTML = html;
        if (typeof callback == 'function') {
          callback();
        }
        return this;
      }
      var id = Ext.id();
      var dom = this.dom;

      html += '<span id="' + id + '"></span>';

      E.onAvailable(id, function () {
        var hd = document.getElementsByTagName('head')[0];
        var re = /(?:<script([^>]*)?>)((\n|\r|.)*?)(?:<\/script>)/gi;
        var srcRe = /\ssrc=([\'\"])(.*?)\1/i;
        var typeRe = /\stype=([\'\"])(.*?)\1/i;

        var match;
        while ((match = re.exec(html))) {
          var attrs = match[1];
          var srcMatch = attrs ? attrs.match(srcRe) : false;
          if (srcMatch && srcMatch[2]) {
            var s = document.createElement('script');
            s.src = srcMatch[2];
            var typeMatch = attrs.match(typeRe);
            if (typeMatch && typeMatch[2]) {
              s.type = typeMatch[2];
            }
            hd.appendChild(s);
          } else if (match[2] && match[2].length > 0) {
            if (window.execScript) {
              window.execScript(match[2]);
            } else {
              window.eval(match[2]);
            }
          }
        }
        var el = document.getElementById(id);
        if (el) {
          Ext.removeNode(el);
        }
        if (typeof callback == 'function') {
          callback();
        }
      });
      dom.innerHTML = html.replace(
        /(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/gi,
        '',
      );
      return this;
    },

    load: function () {
      var um = this.getUpdater();
      um.update.apply(um, arguments);
      return this;
    },

    getUpdater: function () {
      if (!this.updateManager) {
        this.updateManager = new Ext.Updater(this);
      }
      return this.updateManager;
    },

    unselectable: function () {
      this.dom.unselectable = 'on';
      this.swallowEvent('selectstart', true);
      this.applyStyles('-moz-user-select:none;-khtml-user-select:none;');
      this.addClass('x-unselectable');
      return this;
    },

    getCenterXY: function () {
      return this.getAlignToXY(document, 'c-c');
    },

    center: function (centerIn) {
      this.alignTo(centerIn || document, 'c-c');
      return this;
    },

    isBorderBox: function () {
      return noBoxAdjust[this.dom.tagName.toLowerCase()] || Ext.isBorderBox;
    },

    getBox: function (contentBox, local) {
      var xy;
      if (!local) {
        xy = this.getXY();
      } else {
        var left = parseInt(this.getStyle('left'), 10) || 0;
        var top = parseInt(this.getStyle('top'), 10) || 0;
        xy = [left, top];
      }
      var el = this.dom,
        w = el.offsetWidth,
        h = el.offsetHeight,
        bx;
      if (!contentBox) {
        bx = { x: xy[0], y: xy[1], 0: xy[0], 1: xy[1], width: w, height: h };
      } else {
        var l = this.getBorderWidth('l') + this.getPadding('l');
        var r = this.getBorderWidth('r') + this.getPadding('r');
        var t = this.getBorderWidth('t') + this.getPadding('t');
        var b = this.getBorderWidth('b') + this.getPadding('b');
        bx = {
          x: xy[0] + l,
          y: xy[1] + t,
          0: xy[0] + l,
          1: xy[1] + t,
          width: w - (l + r),
          height: h - (t + b),
        };
      }
      bx.right = bx.x + bx.width;
      bx.bottom = bx.y + bx.height;
      return bx;
    },

    getFrameWidth: function (sides, onlyContentBox) {
      return onlyContentBox && Ext.isBorderBox
        ? 0
        : this.getPadding(sides) + this.getBorderWidth(sides);
    },

    setBox: function (box, adjust, animate) {
      var w = box.width,
        h = box.height;
      if (adjust && !this.autoBoxAdjust && !this.isBorderBox()) {
        w -= this.getBorderWidth('lr') + this.getPadding('lr');
        h -= this.getBorderWidth('tb') + this.getPadding('tb');
      }
      this.setBounds(box.x, box.y, w, h, this.preanim(arguments, 2));
      return this;
    },

    repaint: function () {
      var dom = this.dom;
      this.addClass('x-repaint');
      setTimeout(function () {
        Ext.get(dom).removeClass('x-repaint');
      }, 1);
      return this;
    },

    getMargins: function (side) {
      if (!side) {
        return {
          top: parseInt(this.getStyle('margin-top'), 10) || 0,
          left: parseInt(this.getStyle('margin-left'), 10) || 0,
          bottom: parseInt(this.getStyle('margin-bottom'), 10) || 0,
          right: parseInt(this.getStyle('margin-right'), 10) || 0,
        };
      } else {
        return this.addStyles(side, El.margins);
      }
    },

    // private
    addStyles: function (sides, styles) {
      var val = 0,
        v,
        w;
      for (var i = 0, len = sides.length; i < len; i++) {
        v = this.getStyle(styles[sides.charAt(i)]);
        if (v) {
          w = parseInt(v, 10);
          if (w) {
            val += w >= 0 ? w : -1 * w;
          }
        }
      }
      return val;
    },

    createProxy: function (config, renderTo, matchBox) {
      config = typeof config == 'object' ? config : { tag: 'div', cls: config };

      var proxy;
      if (renderTo) {
        proxy = Ext.DomHelper.append(renderTo, config, true);
      } else {
        proxy = Ext.DomHelper.insertBefore(this.dom, config, true);
      }
      if (matchBox) {
        proxy.setBox(this.getBox());
      }
      return proxy;
    },

    mask: function (msg, msgCls) {
      if (this.getStyle('position') == 'static') {
        this.addClass('x-masked-relative');
      }
      if (this._maskMsg) {
        this._maskMsg.remove();
      }
      if (this._mask) {
        this._mask.remove();
      }

      this._mask = Ext.DomHelper.append(this.dom, { cls: 'ext-el-mask' }, true);

      this.addClass('x-masked');
      this._mask.setDisplayed(true);
      if (typeof msg == 'string') {
        this._maskMsg = Ext.DomHelper.append(
          this.dom,
          { cls: 'ext-el-mask-msg', cn: { tag: 'div' } },
          true,
        );
        var mm = this._maskMsg;
        mm.dom.className = msgCls
          ? 'ext-el-mask-msg ' + msgCls
          : 'ext-el-mask-msg';
        mm.dom.firstChild.innerHTML = msg;
        mm.setDisplayed(true);
        mm.center(this);
      }
      if (
        Ext.isIE &&
        !(Ext.isIE7 && Ext.isStrict) &&
        this.getStyle('height') == 'auto'
      ) {
        // ie will not expand full height automatically
        this._mask.setSize(this.getWidth(), this.getHeight());
      }
      return this._mask;
    },

    unmask: function () {
      if (this._mask) {
        if (this._maskMsg) {
          this._maskMsg.remove();
          delete this._maskMsg;
        }
        this._mask.remove();
        delete this._mask;
      }
      this.removeClass(['x-masked', 'x-masked-relative']);
    },

    isMasked: function () {
      return this._mask && this._mask.isVisible();
    },

    createShim: function () {
      var el = document.createElement('iframe');
      el.frameBorder = '0';
      el.className = 'ext-shim';
      if (Ext.isIE && Ext.isSecure) {
        el.src = Ext.SSL_SECURE_URL;
      }
      var shim = Ext.get(this.dom.parentNode.insertBefore(el, this.dom));
      shim.autoBoxAdjust = false;
      return shim;
    },

    remove: function () {
      Ext.removeNode(this.dom);
      delete El.cache[this.dom.id];
    },

    hover: function (overFn, outFn, scope) {
      var preOverFn = function (e) {
        if (!e.within(this, true)) {
          overFn.apply(scope || this, arguments);
        }
      };
      var preOutFn = function (e) {
        if (!e.within(this, true)) {
          outFn.apply(scope || this, arguments);
        }
      };
      this.on('mouseover', preOverFn, this.dom);
      this.on('mouseout', preOutFn, this.dom);
      return this;
    },

    addClassOnOver: function (className) {
      this.hover(
        function () {
          Ext.fly(this, '_internal').addClass(className);
        },
        function () {
          Ext.fly(this, '_internal').removeClass(className);
        },
      );
      return this;
    },

    addClassOnFocus: function (className) {
      this.on(
        'focus',
        function () {
          Ext.fly(this, '_internal').addClass(className);
        },
        this.dom,
      );
      this.on(
        'blur',
        function () {
          Ext.fly(this, '_internal').removeClass(className);
        },
        this.dom,
      );
      return this;
    },

    addClassOnClick: function (className) {
      var dom = this.dom;
      this.on('mousedown', function () {
        Ext.fly(dom, '_internal').addClass(className);
        var d = Ext.getDoc();
        var fn = function () {
          Ext.fly(dom, '_internal').removeClass(className);
          d.removeListener('mouseup', fn);
        };
        d.on('mouseup', fn);
      });
      return this;
    },

    swallowEvent: function (eventName, preventDefault) {
      var fn = function (e) {
        e.stopPropagation();
        if (preventDefault) {
          e.preventDefault();
        }
      };
      if (Ext.isArray(eventName)) {
        for (var i = 0, len = eventName.length; i < len; i++) {
          this.on(eventName[i], fn);
        }
        return this;
      }
      this.on(eventName, fn);
      return this;
    },

    parent: function (selector, returnDom) {
      return this.matchNode('parentNode', 'parentNode', selector, returnDom);
    },

    next: function (selector, returnDom) {
      return this.matchNode('nextSibling', 'nextSibling', selector, returnDom);
    },

    prev: function (selector, returnDom) {
      return this.matchNode(
        'previousSibling',
        'previousSibling',
        selector,
        returnDom,
      );
    },

    first: function (selector, returnDom) {
      return this.matchNode('nextSibling', 'firstChild', selector, returnDom);
    },

    last: function (selector, returnDom) {
      return this.matchNode(
        'previousSibling',
        'lastChild',
        selector,
        returnDom,
      );
    },

    matchNode: function (dir, start, selector, returnDom) {
      var n = this.dom[start];
      while (n) {
        if (n.nodeType == 1 && (!selector || Ext.DomQuery.is(n, selector))) {
          return !returnDom ? Ext.get(n) : n;
        }
        n = n[dir];
      }
      return null;
    },

    appendChild: function (el) {
      el = Ext.get(el);
      el.appendTo(this);
      return this;
    },

    createChild: function (config, insertBefore, returnDom) {
      config = config || { tag: 'div' };
      if (insertBefore) {
        return Ext.DomHelper.insertBefore(
          insertBefore,
          config,
          returnDom !== true,
        );
      }
      return Ext.DomHelper[!this.dom.firstChild ? 'overwrite' : 'append'](
        this.dom,
        config,
        returnDom !== true,
      );
    },

    appendTo: function (el) {
      el = Ext.getDom(el);
      el.appendChild(this.dom);
      return this;
    },

    insertBefore: function (el) {
      el = Ext.getDom(el);
      el.parentNode.insertBefore(this.dom, el);
      return this;
    },

    insertAfter: function (el) {
      el = Ext.getDom(el);
      el.parentNode.insertBefore(this.dom, el.nextSibling);
      return this;
    },

    insertFirst: function (el, returnDom) {
      el = el || {};
      if (el.nodeType || el.dom) {
        // dh config
        el = Ext.getDom(el);
        this.dom.insertBefore(el, this.dom.firstChild);
        return !returnDom ? Ext.get(el) : el;
      } else {
        return this.createChild(el, this.dom.firstChild, returnDom);
      }
    },

    insertSibling: function (el, where, returnDom) {
      var rt;
      if (Ext.isArray(el)) {
        for (var i = 0, len = el.length; i < len; i++) {
          rt = this.insertSibling(el[i], where, returnDom);
        }
        return rt;
      }
      where = where ? where.toLowerCase() : 'before';
      el = el || {};
      var refNode = where == 'before' ? this.dom : this.dom.nextSibling;

      if (el.nodeType || el.dom) {
        // dh config
        rt = this.dom.parentNode.insertBefore(Ext.getDom(el), refNode);
        if (!returnDom) {
          rt = Ext.get(rt);
        }
      } else {
        if (where == 'after' && !this.dom.nextSibling) {
          rt = Ext.DomHelper.append(this.dom.parentNode, el, !returnDom);
        } else {
          rt = Ext.DomHelper[where == 'after' ? 'insertAfter' : 'insertBefore'](
            this.dom,
            el,
            !returnDom,
          );
        }
      }
      return rt;
    },

    wrap: function (config, returnDom) {
      if (!config) {
        config = { tag: 'div' };
      }
      var newEl = Ext.DomHelper.insertBefore(this.dom, config, !returnDom);
      newEl.dom ? newEl.dom.appendChild(this.dom) : newEl.appendChild(this.dom);
      return newEl;
    },

    replace: function (el) {
      el = Ext.get(el);
      this.insertBefore(el);
      el.remove();
      return this;
    },

    replaceWith: function (el) {
      if (el.nodeType || el.dom) {
        // dh config
        el = Ext.getDom(el);
        this.dom.parentNode.insertBefore(el, this.dom);
      } else {
        el = this.insertSibling(el, 'before');
      }
      El.uncache(this.id);
      Ext.removeNode(this.dom);
      this.dom = el;
      this.id = Ext.id(el);
      El.cache[this.id] = this;
      return this;
    },

    insertHtml: function (where, html, returnEl) {
      var el = Ext.DomHelper.insertHtml(where, this.dom, html);
      return returnEl ? Ext.get(el) : el;
    },

    set: function (o, useSet) {
      var el = this.dom;
      useSet =
        typeof useSet == 'undefined'
          ? el.setAttribute
            ? true
            : false
          : useSet;
      for (var attr in o) {
        if (attr == 'style' || typeof o[attr] == 'function') continue;
        if (attr == 'cls') {
          el.className = o['cls'];
        } else if (o.hasOwnProperty(attr)) {
          if (useSet) el.setAttribute(attr, o[attr]);
          else el[attr] = o[attr];
        }
      }
      if (o.style) {
        Ext.DomHelper.applyStyles(el, o.style);
      }
      return this;
    },

    addKeyListener: function (key, fn, scope) {
      var config;
      if (typeof key != 'object' || Ext.isArray(key)) {
        config = {
          key: key,
          fn: fn,
          scope: scope,
        };
      } else {
        config = {
          key: key.key,
          shift: key.shift,
          ctrl: key.ctrl,
          alt: key.alt,
          fn: fn,
          scope: scope,
        };
      }
      return new Ext.KeyMap(this, config);
    },

    addKeyMap: function (config) {
      return new Ext.KeyMap(this, config);
    },

    isScrollable: function () {
      var dom = this.dom;
      return (
        dom.scrollHeight > dom.clientHeight || dom.scrollWidth > dom.clientWidth
      );
    },

    scrollTo: function (side, value, animate) {
      var prop = side.toLowerCase() == 'left' ? 'scrollLeft' : 'scrollTop';
      if (!animate || !A) {
        this.dom[prop] = value;
      } else {
        var to =
          prop == 'scrollLeft'
            ? [value, this.dom.scrollTop]
            : [this.dom.scrollLeft, value];
        this.anim({ scroll: { to: to } }, this.preanim(arguments, 2), 'scroll');
      }
      return this;
    },

    scroll: function (direction, distance, animate) {
      if (!this.isScrollable()) {
        return;
      }
      var el = this.dom;
      var l = el.scrollLeft,
        t = el.scrollTop;
      var w = el.scrollWidth,
        h = el.scrollHeight;
      var cw = el.clientWidth,
        ch = el.clientHeight;
      direction = direction.toLowerCase();
      var scrolled = false;
      var a = this.preanim(arguments, 2);
      switch (direction) {
        case 'l':
        case 'left':
          if (w - l > cw) {
            var v = Math.min(l + distance, w - cw);
            this.scrollTo('left', v, a);
            scrolled = true;
          }
          break;
        case 'r':
        case 'right':
          if (l > 0) {
            var v = Math.max(l - distance, 0);
            this.scrollTo('left', v, a);
            scrolled = true;
          }
          break;
        case 't':
        case 'top':
        case 'up':
          if (t > 0) {
            var v = Math.max(t - distance, 0);
            this.scrollTo('top', v, a);
            scrolled = true;
          }
          break;
        case 'b':
        case 'bottom':
        case 'down':
          if (h - t > ch) {
            var v = Math.min(t + distance, h - ch);
            this.scrollTo('top', v, a);
            scrolled = true;
          }
          break;
      }
      return scrolled;
    },

    translatePoints: function (x, y) {
      if (typeof x == 'object' || Ext.isArray(x)) {
        y = x[1];
        x = x[0];
      }
      var p = this.getStyle('position');
      var o = this.getXY();

      var l = parseInt(this.getStyle('left'), 10);
      var t = parseInt(this.getStyle('top'), 10);

      if (isNaN(l)) {
        l = p == 'relative' ? 0 : this.dom.offsetLeft;
      }
      if (isNaN(t)) {
        t = p == 'relative' ? 0 : this.dom.offsetTop;
      }

      return { left: x - o[0] + l, top: y - o[1] + t };
    },

    getScroll: function () {
      var d = this.dom,
        doc = document;
      if (d == doc || d == doc.body) {
        var l, t;
        if (Ext.isIE && Ext.isStrict) {
          l = doc.documentElement.scrollLeft || doc.body.scrollLeft || 0;
          t = doc.documentElement.scrollTop || doc.body.scrollTop || 0;
        } else {
          l = window.pageXOffset || doc.body.scrollLeft || 0;
          t = window.pageYOffset || doc.body.scrollTop || 0;
        }
        return { left: l, top: t };
      } else {
        return { left: d.scrollLeft, top: d.scrollTop };
      }
    },

    getColor: function (attr, defaultValue, prefix) {
      var v = this.getStyle(attr);
      if (!v || v == 'transparent' || v == 'inherit') {
        return defaultValue;
      }
      var color = typeof prefix == 'undefined' ? '#' : prefix;
      if (v.substr(0, 4) == 'rgb(') {
        var rvs = v.slice(4, v.length - 1).split(',');
        for (var i = 0; i < 3; i++) {
          var h = parseInt(rvs[i]);
          var s = h.toString(16);
          if (h < 16) {
            s = '0' + s;
          }
          color += s;
        }
      } else {
        if (v.substr(0, 1) == '#') {
          if (v.length == 4) {
            for (var i = 1; i < 4; i++) {
              var c = v.charAt(i);
              color += c + c;
            }
          } else if (v.length == 7) {
            color += v.substr(1);
          }
        }
      }
      return color.length > 5 ? color.toLowerCase() : defaultValue;
    },

    boxWrap: function (cls) {
      cls = cls || 'x-box';
      var el = Ext.get(
        this.insertHtml(
          'beforeBegin',
          String.format('<div class="{0}">' + El.boxMarkup + '</div>', cls),
        ),
      );
      el.child('.' + cls + '-mc').dom.appendChild(this.dom);
      return el;
    },

    getAttributeNS: Ext.isIE
      ? function (ns, name) {
          var d = this.dom;
          var type = typeof d[ns + ':' + name];
          if (type != 'undefined' && type != 'unknown') {
            return d[ns + ':' + name];
          }
          return d[name];
        }
      : function (ns, name) {
          var d = this.dom;
          return (
            d.getAttributeNS(ns, name) ||
            d.getAttribute(ns + ':' + name) ||
            d.getAttribute(name) ||
            d[name]
          );
        },

    getTextWidth: function (text, min, max) {
      return Ext.util.TextMetrics.measure(
        this.dom,
        Ext.value(text, this.dom.innerHTML, true),
      ).width.constrain(min || 0, max || 1000000);
    },
  };

  var ep = El.prototype;

  ep.on = ep.addListener;
  // backwards compat
  ep.mon = ep.addListener;

  ep.getUpdateManager = ep.getUpdater;

  ep.un = ep.removeListener;

  ep.autoBoxAdjust = true;

  // private
  El.unitPattern = /\d+(px|em|%|en|ex|pt|in|cm|mm|pc)$/i;

  // private
  El.addUnits = function (v, defaultUnit) {
    if (v === '' || v == 'auto') {
      return v;
    }
    if (v === undefined) {
      return '';
    }
    if (typeof v == 'number' || !El.unitPattern.test(v)) {
      return v + (defaultUnit || 'px');
    }
    return v;
  };

  // special markup used throughout Ext when box wrapping elements
  El.boxMarkup =
    '<div class="{0}-tl"><div class="{0}-tr"><div class="{0}-tc"></div></div></div><div class="{0}-ml"><div class="{0}-mr"><div class="{0}-mc"></div></div></div><div class="{0}-bl"><div class="{0}-br"><div class="{0}-bc"></div></div></div>';

  El.VISIBILITY = 1;

  El.DISPLAY = 2;

  El.borders = {
    l: 'border-left-width',
    r: 'border-right-width',
    t: 'border-top-width',
    b: 'border-bottom-width',
  };
  El.paddings = {
    l: 'padding-left',
    r: 'padding-right',
    t: 'padding-top',
    b: 'padding-bottom',
  };
  El.margins = {
    l: 'margin-left',
    r: 'margin-right',
    t: 'margin-top',
    b: 'margin-bottom',
  };

  El.cache = {};

  var docEl;

  El.get = function (el) {
    var ex, elm, id;
    if (!el) {
      return null;
    }
    if (typeof el == 'string') {
      // element id
      if (!(elm = document.getElementById(el))) {
        return null;
      }
      if ((ex = El.cache[el])) {
        ex.dom = elm;
      } else {
        ex = El.cache[el] = new El(elm);
      }
      return ex;
    } else if (el.tagName) {
      // dom element
      if (!(id = el.id)) {
        id = Ext.id(el);
      }
      if ((ex = El.cache[id])) {
        ex.dom = el;
      } else {
        ex = El.cache[id] = new El(el);
      }
      return ex;
    } else if (el instanceof El) {
      if (el != docEl) {
        el.dom = document.getElementById(el.id) || el.dom; // refresh dom element in case no longer valid,
        // catch case where it hasn't been appended
        El.cache[el.id] = el; // in case it was created directly with Element(), let's cache it
      }
      return el;
    } else if (el.isComposite) {
      return el;
    } else if (Ext.isArray(el)) {
      return El.select(el);
    } else if (el == document) {
      // create a bogus element object representing the document object
      if (!docEl) {
        var f = function () {};
        f.prototype = El.prototype;
        docEl = new f();
        docEl.dom = document;
      }
      return docEl;
    }
    return null;
  };

  // private
  El.uncache = function (el) {
    for (var i = 0, a = arguments, len = a.length; i < len; i++) {
      if (a[i]) {
        delete El.cache[a[i].id || a[i]];
      }
    }
  };

  // private
  // Garbage collection - uncache elements/purge listeners on orphaned elements
  // so we don't hold a reference and cause the browser to retain them
  El.garbageCollect = function () {
    if (!Ext.enableGarbageCollector) {
      clearInterval(El.collectorThread);
      return;
    }
    for (var eid in El.cache) {
      var el = El.cache[eid],
        d = el.dom;
      // -------------------------------------------------------
      // Determining what is garbage:
      // -------------------------------------------------------
      // !d
      // dom node is null, definitely garbage
      // -------------------------------------------------------
      // !d.parentNode
      // no parentNode == direct orphan, definitely garbage
      // -------------------------------------------------------
      // !d.offsetParent && !document.getElementById(eid)
      // display none elements have no offsetParent so we will
      // also try to look it up by it's id. However, check
      // offsetParent first so we don't do unneeded lookups.
      // This enables collection of elements that are not orphans
      // directly, but somewhere up the line they have an orphan
      // parent.
      // -------------------------------------------------------
      if (
        !d ||
        !d.parentNode ||
        (!d.offsetParent && !document.getElementById(eid))
      ) {
        delete El.cache[eid];
        if (d && Ext.enableListenerCollection) {
          Ext.EventManager.removeAll(d);
        }
      }
    }
  };
  El.collectorThreadId = setInterval(El.garbageCollect, 30000);

  var flyFn = function () {};
  flyFn.prototype = El.prototype;
  var _cls = new flyFn();

  // dom is optional
  El.Flyweight = function (dom) {
    this.dom = dom;
  };

  El.Flyweight.prototype = _cls;
  El.Flyweight.prototype.isFlyweight = true;

  El._flyweights = {};

  El.fly = function (el, named) {
    named = named || '_global';
    el = Ext.getDom(el);
    if (!el) {
      return null;
    }
    if (!El._flyweights[named]) {
      El._flyweights[named] = new El.Flyweight();
    }
    El._flyweights[named].dom = el;
    return El._flyweights[named];
  };

  Ext.get = El.get;

  Ext.fly = El.fly;

  // speedy lookup for elements never to box adjust
  var noBoxAdjust = Ext.isStrict
    ? {
        select: 1,
      }
    : {
        input: 1,
        select: 1,
        textarea: 1,
      };
  if (Ext.isIE || Ext.isGecko) {
    noBoxAdjust['button'] = 1;
  }

  Ext.EventManager.on(window, 'unload', function () {
    delete El.cache;
    delete El._flyweights;
  });
})();

//Notifies Element that fx methods are available
Ext.enableFx = true;

Ext.Fx = {
  slideIn: function (anchor, o) {
    var el = this.getFxEl();
    o = o || {};

    el.queueFx(o, function () {
      anchor = anchor || 't';

      // fix display to visibility
      this.fixDisplay();

      // restore values after effect
      var r = this.getFxRestore();
      var b = this.getBox();
      // fixed size for slide
      this.setSize(b);

      // wrap if needed
      var wrap = this.fxWrap(r.pos, o, 'hidden');

      var st = this.dom.style;
      st.visibility = 'visible';
      st.position = 'absolute';

      // clear out temp styles after slide and unwrap
      var after = function () {
        el.fxUnwrap(wrap, r.pos, o);
        st.width = r.width;
        st.height = r.height;
        el.afterFx(o);
      };
      // time to calc the positions
      var a,
        pt = { to: [b.x, b.y] },
        bw = { to: b.width },
        bh = { to: b.height };

      switch (anchor.toLowerCase()) {
        case 't':
          wrap.setSize(b.width, 0);
          st.left = st.bottom = '0';
          a = { height: bh };
          break;
        case 'l':
          wrap.setSize(0, b.height);
          st.right = st.top = '0';
          a = { width: bw };
          break;
        case 'r':
          wrap.setSize(0, b.height);
          wrap.setX(b.right);
          st.left = st.top = '0';
          a = { width: bw, points: pt };
          break;
        case 'b':
          wrap.setSize(b.width, 0);
          wrap.setY(b.bottom);
          st.left = st.top = '0';
          a = { height: bh, points: pt };
          break;
        case 'tl':
          wrap.setSize(0, 0);
          st.right = st.bottom = '0';
          a = { width: bw, height: bh };
          break;
        case 'bl':
          wrap.setSize(0, 0);
          wrap.setY(b.y + b.height);
          st.right = st.top = '0';
          a = { width: bw, height: bh, points: pt };
          break;
        case 'br':
          wrap.setSize(0, 0);
          wrap.setXY([b.right, b.bottom]);
          st.left = st.top = '0';
          a = { width: bw, height: bh, points: pt };
          break;
        case 'tr':
          wrap.setSize(0, 0);
          wrap.setX(b.x + b.width);
          st.left = st.bottom = '0';
          a = { width: bw, height: bh, points: pt };
          break;
      }
      this.dom.style.visibility = 'visible';
      wrap.show();

      arguments.callee.anim = wrap.fxanim(
        a,
        o,
        'motion',
        0.5,
        'easeOut',
        after,
      );
    });
    return this;
  },

  slideOut: function (anchor, o) {
    var el = this.getFxEl();
    o = o || {};

    el.queueFx(o, function () {
      anchor = anchor || 't';

      // restore values after effect
      var r = this.getFxRestore();

      var b = this.getBox();
      // fixed size for slide
      this.setSize(b);

      // wrap if needed
      var wrap = this.fxWrap(r.pos, o, 'visible');

      var st = this.dom.style;
      st.visibility = 'visible';
      st.position = 'absolute';

      wrap.setSize(b);

      var after = function () {
        if (o.useDisplay) {
          el.setDisplayed(false);
        } else {
          el.hide();
        }

        el.fxUnwrap(wrap, r.pos, o);

        st.width = r.width;
        st.height = r.height;

        el.afterFx(o);
      };

      var a,
        zero = { to: 0 };
      switch (anchor.toLowerCase()) {
        case 't':
          st.left = st.bottom = '0';
          a = { height: zero };
          break;
        case 'l':
          st.right = st.top = '0';
          a = { width: zero };
          break;
        case 'r':
          st.left = st.top = '0';
          a = { width: zero, points: { to: [b.right, b.y] } };
          break;
        case 'b':
          st.left = st.top = '0';
          a = { height: zero, points: { to: [b.x, b.bottom] } };
          break;
        case 'tl':
          st.right = st.bottom = '0';
          a = { width: zero, height: zero };
          break;
        case 'bl':
          st.right = st.top = '0';
          a = { width: zero, height: zero, points: { to: [b.x, b.bottom] } };
          break;
        case 'br':
          st.left = st.top = '0';
          a = {
            width: zero,
            height: zero,
            points: { to: [b.x + b.width, b.bottom] },
          };
          break;
        case 'tr':
          st.left = st.bottom = '0';
          a = { width: zero, height: zero, points: { to: [b.right, b.y] } };
          break;
      }

      arguments.callee.anim = wrap.fxanim(
        a,
        o,
        'motion',
        0.5,
        'easeOut',
        after,
      );
    });
    return this;
  },

  puff: function (o) {
    var el = this.getFxEl();
    o = o || {};

    el.queueFx(o, function () {
      this.clearOpacity();
      this.show();

      // restore values after effect
      var r = this.getFxRestore();
      var st = this.dom.style;

      var after = function () {
        if (o.useDisplay) {
          el.setDisplayed(false);
        } else {
          el.hide();
        }

        el.clearOpacity();

        el.setPositioning(r.pos);
        st.width = r.width;
        st.height = r.height;
        st.fontSize = '';
        el.afterFx(o);
      };

      var width = this.getWidth();
      var height = this.getHeight();

      arguments.callee.anim = this.fxanim(
        {
          width: { to: this.adjustWidth(width * 2) },
          height: { to: this.adjustHeight(height * 2) },
          points: { by: [-(width * 0.5), -(height * 0.5)] },
          opacity: { to: 0 },
          fontSize: { to: 200, unit: '%' },
        },
        o,
        'motion',
        0.5,
        'easeOut',
        after,
      );
    });
    return this;
  },

  switchOff: function (o) {
    var el = this.getFxEl();
    o = o || {};

    el.queueFx(o, function () {
      this.clearOpacity();
      this.clip();

      // restore values after effect
      var r = this.getFxRestore();
      var st = this.dom.style;

      var after = function () {
        if (o.useDisplay) {
          el.setDisplayed(false);
        } else {
          el.hide();
        }

        el.clearOpacity();
        el.setPositioning(r.pos);
        st.width = r.width;
        st.height = r.height;

        el.afterFx(o);
      };

      this.fxanim({ opacity: { to: 0.3 } }, null, null, 0.1, null, function () {
        this.clearOpacity();
        (function () {
          this.fxanim(
            {
              height: { to: 1 },
              points: { by: [0, this.getHeight() * 0.5] },
            },
            o,
            'motion',
            0.3,
            'easeIn',
            after,
          );
        }).defer(100, this);
      });
    });
    return this;
  },

  highlight: function (color, o) {
    var el = this.getFxEl();
    o = o || {};

    el.queueFx(o, function () {
      color = color || 'ffff9c';
      var attr = o.attr || 'backgroundColor';

      this.clearOpacity();
      this.show();

      var origColor = this.getColor(attr);
      var restoreColor = this.dom.style[attr];
      var endColor = o.endColor || origColor || 'ffffff';

      var after = function () {
        el.dom.style[attr] = restoreColor;
        el.afterFx(o);
      };

      var a = {};
      a[attr] = { from: color, to: endColor };
      arguments.callee.anim = this.fxanim(a, o, 'color', 1, 'easeIn', after);
    });
    return this;
  },

  frame: function (color, count, o) {
    var el = this.getFxEl(),
      proxy,
      active;

    o = o || {};

    el.queueFx(o, function () {
      color = color || '#C3DAF9';
      if (color.length == 6) {
        color = '#' + color;
      }
      count = count || 1;
      this.show();

      var xy = this.getXY(),
        dom = this.dom,
        b = {
          x: xy[0],
          y: xy[1],
          0: xy[0],
          1: xy[1],
          width: dom.offsetWidth,
          height: dom.offsetHeight,
        },
        proxy,
        queue = function () {
          proxy = Ext.get(
            document.body || document.documentElement,
          ).createChild({
            style: {
              visbility: 'hidden',
              position: 'absolute',
              'z-index': 35000, // yee haw
              border: '0px solid ' + color,
            },
          });
          return proxy.queueFx({}, animFn);
        };

      arguments.callee.anim = {
        isAnimated: function () {
          return true;
        },
        stop: function () {
          count = 0;
          proxy.stopFx();
        },
      };

      function animFn() {
        var scale = Ext.isBorderBox ? 2 : 1;
        active = proxy.anim(
          {
            top: { from: b.y, to: b.y - 20 },
            left: { from: b.x, to: b.x - 20 },
            borderWidth: { from: 0, to: 10 },
            opacity: { from: 1, to: 0 },
            height: { from: b.height, to: b.height + 20 * scale },
            width: { from: b.width, to: b.width + 20 * scale },
          },
          {
            duration: o.duration || 1,
            callback: function () {
              proxy.remove();
              --count > 0 ? queue() : el.afterFx(o);
            },
          },
        );
        arguments.callee.anim = {
          isAnimated: function () {
            return true;
          },
          stop: function () {
            active.stop();
          },
        };
      }
      queue();
    });
    return this;
  },

  pause: function (seconds) {
    var el = this.getFxEl(),
      t;

    el.queueFx({}, function () {
      t = setTimeout(function () {
        el.afterFx({});
      }, seconds * 1000);
      arguments.callee.anim = {
        isAnimated: function () {
          return true;
        },
        stop: function () {
          clearTimeout(t);
          el.afterFx({});
        },
      };
    });
    return this;
  },

  fadeIn: function (o) {
    var el = this.getFxEl();
    o = o || {};
    el.queueFx(o, function () {
      this.setOpacity(0);
      this.fixDisplay();
      this.dom.style.visibility = 'visible';
      var to = o.endOpacity || 1;
      arguments.callee.anim = this.fxanim(
        { opacity: { to: to } },
        o,
        null,
        0.5,
        'easeOut',
        function () {
          if (to == 1) {
            this.clearOpacity();
          }
          el.afterFx(o);
        },
      );
    });
    return this;
  },

  fadeOut: function (o) {
    var el = this.getFxEl();
    o = o || {};
    el.queueFx(o, function () {
      var to = o.endOpacity || 0;
      arguments.callee.anim = this.fxanim(
        { opacity: { to: to } },
        o,
        null,
        0.5,
        'easeOut',
        function () {
          if (to === 0) {
            if (this.visibilityMode == Ext.Element.DISPLAY || o.useDisplay) {
              this.dom.style.display = 'none';
            } else {
              this.dom.style.visibility = 'hidden';
            }
            this.clearOpacity();
          }
          el.afterFx(o);
        },
      );
    });
    return this;
  },

  scale: function (w, h, o) {
    this.shift(
      Ext.apply({}, o, {
        width: w,
        height: h,
      }),
    );
    return this;
  },

  shift: function (o) {
    var el = this.getFxEl();
    o = o || {};
    el.queueFx(o, function () {
      var a = {},
        w = o.width,
        h = o.height,
        x = o.x,
        y = o.y,
        op = o.opacity;
      if (w !== undefined) {
        a.width = { to: this.adjustWidth(w) };
      }
      if (h !== undefined) {
        a.height = { to: this.adjustHeight(h) };
      }
      if (o.left !== undefined) {
        a.left = { to: o.left };
      }
      if (o.top !== undefined) {
        a.top = { to: o.top };
      }
      if (o.right !== undefined) {
        a.right = { to: o.right };
      }
      if (o.bottom !== undefined) {
        a.bottom = { to: o.bottom };
      }
      if (x !== undefined || y !== undefined) {
        a.points = {
          to: [
            x !== undefined ? x : this.getX(),
            y !== undefined ? y : this.getY(),
          ],
        };
      }
      if (op !== undefined) {
        a.opacity = { to: op };
      }
      if (o.xy !== undefined) {
        a.points = { to: o.xy };
      }
      arguments.callee.anim = this.fxanim(
        a,
        o,
        'motion',
        0.35,
        'easeOut',
        function () {
          el.afterFx(o);
        },
      );
    });
    return this;
  },

  ghost: function (anchor, o) {
    var el = this.getFxEl();
    o = o || {};

    el.queueFx(o, function () {
      anchor = anchor || 'b';

      // restore values after effect
      var r = this.getFxRestore();
      var w = this.getWidth(),
        h = this.getHeight();

      var st = this.dom.style;

      var after = function () {
        if (o.useDisplay) {
          el.setDisplayed(false);
        } else {
          el.hide();
        }

        el.clearOpacity();
        el.setPositioning(r.pos);
        st.width = r.width;
        st.height = r.height;

        el.afterFx(o);
      };

      var a = { opacity: { to: 0 }, points: {} },
        pt = a.points;
      switch (anchor.toLowerCase()) {
        case 't':
          pt.by = [0, -h];
          break;
        case 'l':
          pt.by = [-w, 0];
          break;
        case 'r':
          pt.by = [w, 0];
          break;
        case 'b':
          pt.by = [0, h];
          break;
        case 'tl':
          pt.by = [-w, -h];
          break;
        case 'bl':
          pt.by = [-w, h];
          break;
        case 'br':
          pt.by = [w, h];
          break;
        case 'tr':
          pt.by = [w, -h];
          break;
      }

      arguments.callee.anim = this.fxanim(
        a,
        o,
        'motion',
        0.5,
        'easeOut',
        after,
      );
    });
    return this;
  },

  syncFx: function () {
    this.fxDefaults = Ext.apply(this.fxDefaults || {}, {
      block: false,
      concurrent: true,
      stopFx: false,
    });
    return this;
  },

  sequenceFx: function () {
    this.fxDefaults = Ext.apply(this.fxDefaults || {}, {
      block: false,
      concurrent: false,
      stopFx: false,
    });
    return this;
  },

  nextFx: function () {
    var ef = this.fxQueue[0];
    if (ef) {
      ef.call(this);
    }
  },

  hasActiveFx: function () {
    return this.fxQueue && this.fxQueue[0];
  },

  stopFx: function () {
    if (this.hasActiveFx()) {
      var cur = this.fxQueue[0];
      if (cur && cur.anim && cur.anim.isAnimated()) {
        this.fxQueue = [cur]; // clear out others
        cur.anim.stop(true);
      }
    }
    return this;
  },

  beforeFx: function (o) {
    if (this.hasActiveFx() && !o.concurrent) {
      if (o.stopFx) {
        this.stopFx();
        return true;
      }
      return false;
    }
    return true;
  },

  hasFxBlock: function () {
    var q = this.fxQueue;
    return q && q[0] && q[0].block;
  },

  queueFx: function (o, fn) {
    if (!this.fxQueue) {
      this.fxQueue = [];
    }
    if (!this.hasFxBlock()) {
      Ext.applyIf(o, this.fxDefaults);
      if (!o.concurrent) {
        var run = this.beforeFx(o);
        fn.block = o.block;
        this.fxQueue.push(fn);
        if (run) {
          this.nextFx();
        }
      } else {
        fn.call(this);
      }
    }
    return this;
  },

  fxWrap: function (pos, o, vis) {
    var wrap;
    if (!o.wrap || !(wrap = Ext.get(o.wrap))) {
      var wrapXY;
      if (o.fixPosition) {
        wrapXY = this.getXY();
      }
      var div = document.createElement('div');
      div.style.visibility = vis;
      wrap = Ext.get(this.dom.parentNode.insertBefore(div, this.dom));
      wrap.setPositioning(pos);
      if (wrap.getStyle('position') == 'static') {
        wrap.position('relative');
      }
      this.clearPositioning('auto');
      wrap.clip();
      wrap.dom.appendChild(this.dom);
      if (wrapXY) {
        wrap.setXY(wrapXY);
      }
    }
    return wrap;
  },

  fxUnwrap: function (wrap, pos, o) {
    this.clearPositioning();
    this.setPositioning(pos);
    if (!o.wrap) {
      wrap.dom.parentNode.insertBefore(this.dom, wrap.dom);
      wrap.remove();
    }
  },

  getFxRestore: function () {
    var st = this.dom.style;
    return { pos: this.getPositioning(), width: st.width, height: st.height };
  },

  afterFx: function (o) {
    if (o.afterStyle) {
      this.applyStyles(o.afterStyle);
    }
    if (o.afterCls) {
      this.addClass(o.afterCls);
    }
    if (o.remove === true) {
      this.remove();
    }
    if (!o.concurrent) {
      this.fxQueue.shift();
    }
    Ext.callback(o.callback, o.scope, [this]);
    if (!o.concurrent) {
      this.nextFx();
    }
  },

  getFxEl: function () {
    // support for composite element fx
    return Ext.get(this.dom);
  },

  fxanim: function (args, opt, animType, defaultDur, defaultEase, cb) {
    animType = animType || 'run';
    opt = opt || {};
    var anim = Ext.lib.Anim[animType](
      this.dom,
      args,
      opt.duration || defaultDur || 0.35,
      opt.easing || defaultEase || 'easeOut',
      function () {
        Ext.callback(cb, this);
      },
      this,
    );
    opt.anim = anim;
    return anim;
  },
};

// backwords compat
Ext.Fx.resize = Ext.Fx.scale;

//When included, Ext.Fx is automatically applied to Element so that all basic
//effects are available directly via the Element API
Ext.apply(Ext.Element.prototype, Ext.Fx);

Ext.CompositeElement = function (els) {
  this.elements = [];
  this.addElements(els);
};
Ext.CompositeElement.prototype = {
  isComposite: true,
  addElements: function (els) {
    if (!els) return this;
    if (typeof els == 'string') {
      els = Ext.Element.selectorFunction(els);
    }
    var yels = this.elements;
    var index = yels.length - 1;
    for (var i = 0, len = els.length; i < len; i++) {
      yels[++index] = Ext.get(els[i]);
    }
    return this;
  },

  fill: function (els) {
    this.elements = [];
    this.add(els);
    return this;
  },

  filter: function (selector) {
    var els = [];
    this.each(function (el) {
      if (el.is(selector)) {
        els[els.length] = el.dom;
      }
    });
    this.fill(els);
    return this;
  },

  invoke: function (fn, args) {
    var els = this.elements;
    for (var i = 0, len = els.length; i < len; i++) {
      Ext.Element.prototype[fn].apply(els[i], args);
    }
    return this;
  },

  add: function (els) {
    if (typeof els == 'string') {
      this.addElements(Ext.Element.selectorFunction(els));
    } else if (els.length !== undefined) {
      this.addElements(els);
    } else {
      this.addElements([els]);
    }
    return this;
  },

  each: function (fn, scope) {
    var els = this.elements;
    for (var i = 0, len = els.length; i < len; i++) {
      if (fn.call(scope || els[i], els[i], this, i) === false) {
        break;
      }
    }
    return this;
  },

  item: function (index) {
    return this.elements[index] || null;
  },

  first: function () {
    return this.item(0);
  },

  last: function () {
    return this.item(this.elements.length - 1);
  },

  getCount: function () {
    return this.elements.length;
  },

  contains: function (el) {
    return this.indexOf(el) !== -1;
  },

  indexOf: function (el) {
    return this.elements.indexOf(Ext.get(el));
  },

  removeElement: function (el, removeDom) {
    if (Ext.isArray(el)) {
      for (var i = 0, len = el.length; i < len; i++) {
        this.removeElement(el[i]);
      }
      return this;
    }
    var index = typeof el == 'number' ? el : this.indexOf(el);
    if (index !== -1 && this.elements[index]) {
      if (removeDom) {
        var d = this.elements[index];
        if (d.dom) {
          d.remove();
        } else {
          Ext.removeNode(d);
        }
      }
      this.elements.splice(index, 1);
    }
    return this;
  },

  replaceElement: function (el, replacement, domReplace) {
    var index = typeof el == 'number' ? el : this.indexOf(el);
    if (index !== -1) {
      if (domReplace) {
        this.elements[index].replaceWith(replacement);
      } else {
        this.elements.splice(index, 1, Ext.get(replacement));
      }
    }
    return this;
  },

  clear: function () {
    this.elements = [];
  },
};
(function () {
  Ext.CompositeElement.createCall = function (proto, fnName) {
    if (!proto[fnName]) {
      proto[fnName] = function () {
        return this.invoke(fnName, arguments);
      };
    }
  };
  for (var fnName in Ext.Element.prototype) {
    if (typeof Ext.Element.prototype[fnName] == 'function') {
      Ext.CompositeElement.createCall(Ext.CompositeElement.prototype, fnName);
    }
  }
})();

Ext.CompositeElementLite = function (els) {
  Ext.CompositeElementLite.superclass.constructor.call(this, els);
  this.el = new Ext.Element.Flyweight();
};
Ext.extend(Ext.CompositeElementLite, Ext.CompositeElement, {
  addElements: function (els) {
    if (els) {
      if (Ext.isArray(els)) {
        this.elements = this.elements.concat(els);
      } else {
        var yels = this.elements;
        var index = yels.length - 1;
        for (var i = 0, len = els.length; i < len; i++) {
          yels[++index] = els[i];
        }
      }
    }
    return this;
  },
  invoke: function (fn, args) {
    var els = this.elements;
    var el = this.el;
    for (var i = 0, len = els.length; i < len; i++) {
      el.dom = els[i];
      Ext.Element.prototype[fn].apply(el, args);
    }
    return this;
  },

  item: function (index) {
    if (!this.elements[index]) {
      return null;
    }
    this.el.dom = this.elements[index];
    return this.el;
  },

  // fixes scope with flyweight
  addListener: function (eventName, handler, scope, opt) {
    var els = this.elements;
    for (var i = 0, len = els.length; i < len; i++) {
      Ext.EventManager.on(els[i], eventName, handler, scope || els[i], opt);
    }
    return this;
  },

  each: function (fn, scope) {
    var els = this.elements;
    var el = this.el;
    for (var i = 0, len = els.length; i < len; i++) {
      el.dom = els[i];
      if (fn.call(scope || el, el, this, i) === false) {
        break;
      }
    }
    return this;
  },

  indexOf: function (el) {
    return this.elements.indexOf(Ext.getDom(el));
  },

  replaceElement: function (el, replacement, domReplace) {
    var index = typeof el == 'number' ? el : this.indexOf(el);
    if (index !== -1) {
      replacement = Ext.getDom(replacement);
      if (domReplace) {
        var d = this.elements[index];
        d.parentNode.insertBefore(replacement, d);
        Ext.removeNode(d);
      }
      this.elements.splice(index, 1, replacement);
    }
    return this;
  },
});
Ext.CompositeElementLite.prototype.on =
  Ext.CompositeElementLite.prototype.addListener;
if (Ext.DomQuery) {
  Ext.Element.selectorFunction = Ext.DomQuery.select;
}

Ext.Element.select = function (selector, unique, root) {
  var els;
  if (typeof selector == 'string') {
    els = Ext.Element.selectorFunction(selector, root);
  } else if (selector.length !== undefined) {
    els = selector;
  } else {
    throw 'Invalid selector';
  }
  if (unique === true) {
    return new Ext.CompositeElement(els);
  } else {
    return new Ext.CompositeElementLite(els);
  }
};

Ext.select = Ext.Element.select;

Ext.data.Connection = function (config) {
  Ext.apply(this, config);
  this.addEvents(
    'beforerequest',

    'requestcomplete',

    'requestexception',
  );
  Ext.data.Connection.superclass.constructor.call(this);
};

Ext.extend(Ext.data.Connection, Ext.util.Observable, {
  timeout: 30000,

  autoAbort: false,

  disableCaching: true,

  disableCachingParam: '_dc',

  request: function (o) {
    if (this.fireEvent('beforerequest', this, o) !== false) {
      var p = o.params;

      if (typeof p == 'function') {
        p = p.call(o.scope || window, o);
      }
      if (typeof p == 'object') {
        p = Ext.urlEncode(p);
      }
      if (this.extraParams) {
        var extras = Ext.urlEncode(this.extraParams);
        p = p ? p + '&' + extras : extras;
      }

      var url = o.url || this.url;
      if (typeof url == 'function') {
        url = url.call(o.scope || window, o);
      }

      if (o.form) {
        var form = Ext.getDom(o.form);
        url = url || form.action;

        var enctype = form.getAttribute('enctype');
        if (
          o.isUpload ||
          (enctype && enctype.toLowerCase() == 'multipart/form-data')
        ) {
          return this.doFormUpload(o, p, url);
        }
        var f = Ext.lib.Ajax.serializeForm(form);
        p = p ? p + '&' + f : f;
      }

      var hs = o.headers;
      if (this.defaultHeaders) {
        hs = Ext.apply(hs || {}, this.defaultHeaders);
        if (!o.headers) {
          o.headers = hs;
        }
      }

      var cb = {
        success: this.handleResponse,
        failure: this.handleFailure,
        scope: this,
        argument: { options: o },
        timeout: o.timeout || this.timeout,
      };

      var method =
        o.method ||
        this.method ||
        (p || o.xmlData || o.jsonData ? 'POST' : 'GET');

      if (
        (method == 'GET' &&
          this.disableCaching &&
          o.disableCaching !== false) ||
        o.disableCaching === true
      ) {
        var dcp = o.disableCachingParam || this.disableCachingParam;
        url +=
          (url.indexOf('?') != -1 ? '&' : '?') +
          dcp +
          '=' +
          new Date().getTime();
      }

      if (typeof o.autoAbort == 'boolean') {
        // options gets top priority
        if (o.autoAbort) {
          this.abort();
        }
      } else if (this.autoAbort !== false) {
        this.abort();
      }
      if ((method == 'GET' || o.xmlData || o.jsonData) && p) {
        url += (url.indexOf('?') != -1 ? '&' : '?') + p;
        p = '';
      }
      this.transId = Ext.lib.Ajax.request(method, url, cb, p, o);
      return this.transId;
    } else {
      Ext.callback(o.callback, o.scope, [o, null, null]);
      return null;
    }
  },

  isLoading: function (transId) {
    if (transId) {
      return Ext.lib.Ajax.isCallInProgress(transId);
    } else {
      return this.transId ? true : false;
    }
  },

  abort: function (transId) {
    if (transId || this.isLoading()) {
      Ext.lib.Ajax.abort(transId || this.transId);
    }
  },

  // private
  handleResponse: function (response) {
    this.transId = false;
    var options = response.argument.options;
    response.argument = options ? options.argument : null;
    this.fireEvent('requestcomplete', this, response, options);
    Ext.callback(options.success, options.scope, [response, options]);
    Ext.callback(options.callback, options.scope, [options, true, response]);
  },

  // private
  handleFailure: function (response, e) {
    this.transId = false;
    var options = response.argument.options;
    response.argument = options ? options.argument : null;
    this.fireEvent('requestexception', this, response, options, e);
    Ext.callback(options.failure, options.scope, [response, options]);
    Ext.callback(options.callback, options.scope, [options, false, response]);
  },

  // private
  doFormUpload: function (o, ps, url) {
    var id = Ext.id();
    var frame = document.createElement('iframe');
    frame.id = id;
    frame.name = id;
    frame.className = 'x-hidden';
    if (Ext.isIE) {
      frame.src = Ext.SSL_SECURE_URL;
    }
    document.body.appendChild(frame);

    if (Ext.isIE) {
      document.frames[id].name = id;
    }

    var form = Ext.getDom(o.form),
      buf = {
        target: form.target,
        method: form.method,
        encoding: form.encoding,
        enctype: form.enctype,
        action: form.action,
      };
    form.target = id;
    form.method = 'POST';
    form.enctype = form.encoding = 'multipart/form-data';
    if (url) {
      form.action = url;
    }

    var hiddens, hd;
    if (ps) {
      // add dynamic params
      hiddens = [];
      ps = Ext.urlDecode(ps, false);
      for (var k in ps) {
        if (ps.hasOwnProperty(k)) {
          hd = document.createElement('input');
          hd.type = 'hidden';
          hd.name = k;
          hd.value = ps[k];
          form.appendChild(hd);
          hiddens.push(hd);
        }
      }
    }

    function cb() {
      var r = {
        // bogus response object
        responseText: '',
        responseXML: null,
      };

      r.argument = o ? o.argument : null;

      try {
        //
        var doc;
        if (Ext.isIE) {
          doc = frame.contentWindow.document;
        } else {
          doc = frame.contentDocument || window.frames[id].document;
        }
        if (doc && doc.body) {
          r.responseText = doc.body.innerHTML;
        }
        if (doc && doc.XMLDocument) {
          r.responseXML = doc.XMLDocument;
        } else {
          r.responseXML = doc;
        }
      } catch (e) {
        // ignore
      }

      Ext.EventManager.removeListener(frame, 'load', cb, this);

      this.fireEvent('requestcomplete', this, r, o);

      Ext.callback(o.success, o.scope, [r, o]);
      Ext.callback(o.callback, o.scope, [o, true, r]);

      setTimeout(function () {
        Ext.removeNode(frame);
      }, 100);
    }

    Ext.EventManager.on(frame, 'load', cb, this);
    form.submit();

    form.target = buf.target;
    form.method = buf.method;
    form.enctype = buf.enctype;
    form.encoding = buf.encoding;
    form.action = buf.action;

    if (hiddens) {
      // remove dynamic params
      for (var i = 0, len = hiddens.length; i < len; i++) {
        Ext.removeNode(hiddens[i]);
      }
    }
  },
});

Ext.Ajax = new Ext.data.Connection({
  autoAbort: false,

  serializeForm: function (form) {
    return Ext.lib.Ajax.serializeForm(form);
  },
});

Ext.Updater = Ext.extend(Ext.util.Observable, {
  constructor: function (el, forceNew) {
    el = Ext.get(el);
    if (!forceNew && el.updateManager) {
      return el.updateManager;
    }

    this.el = el;

    this.defaultUrl = null;

    this.addEvents(
      'beforeupdate',

      'update',

      'failure',
    );
    var d = Ext.Updater.defaults;

    this.sslBlankUrl = d.sslBlankUrl;

    this.disableCaching = d.disableCaching;

    this.indicatorText = d.indicatorText;

    this.showLoadIndicator = d.showLoadIndicator;

    this.timeout = d.timeout;

    this.loadScripts = d.loadScripts;

    this.transaction = null;

    this.refreshDelegate = this.refresh.createDelegate(this);

    this.updateDelegate = this.update.createDelegate(this);

    this.formUpdateDelegate = this.formUpdate.createDelegate(this);

    if (!this.renderer) {
      this.renderer = this.getDefaultRenderer();
    }
    Ext.Updater.superclass.constructor.call(this);
  },

  getDefaultRenderer: function () {
    return new Ext.Updater.BasicRenderer();
  },

  getEl: function () {
    return this.el;
  },

  update: function (url, params, callback, discardUrl) {
    if (this.fireEvent('beforeupdate', this.el, url, params) !== false) {
      var cfg, callerScope;
      if (typeof url == 'object') {
        // must be config object
        cfg = url;
        url = cfg.url;
        params = params || cfg.params;
        callback = callback || cfg.callback;
        discardUrl = discardUrl || cfg.discardUrl;
        callerScope = cfg.scope;
        if (typeof cfg.nocache != 'undefined') {
          this.disableCaching = cfg.nocache;
        }
        if (typeof cfg.text != 'undefined') {
          this.indicatorText =
            '<div class="loading-indicator">' + cfg.text + '</div>';
        }
        if (typeof cfg.scripts != 'undefined') {
          this.loadScripts = cfg.scripts;
        }
        if (typeof cfg.timeout != 'undefined') {
          this.timeout = cfg.timeout;
        }
      }
      this.showLoading();

      if (!discardUrl) {
        this.defaultUrl = url;
      }
      if (typeof url == 'function') {
        url = url.call(this);
      }

      var o = Ext.apply(
        {},
        {
          url: url,
          params:
            typeof params == 'function' && callerScope
              ? params.createDelegate(callerScope)
              : params,
          success: this.processSuccess,
          failure: this.processFailure,
          scope: this,
          callback: undefined,
          timeout: this.timeout * 1000,
          disableCaching: this.disableCaching,
          argument: {
            options: cfg,
            url: url,
            form: null,
            callback: callback,
            scope: callerScope || window,
            params: params,
          },
        },
        cfg,
      );

      this.transaction = Ext.Ajax.request(o);
    }
  },

  formUpdate: function (form, url, reset, callback) {
    if (this.fireEvent('beforeupdate', this.el, form, url) !== false) {
      if (typeof url == 'function') {
        url = url.call(this);
      }
      form = Ext.getDom(form);
      this.transaction = Ext.Ajax.request({
        form: form,
        url: url,
        success: this.processSuccess,
        failure: this.processFailure,
        scope: this,
        timeout: this.timeout * 1000,
        argument: {
          url: url,
          form: form,
          callback: callback,
          reset: reset,
        },
      });
      this.showLoading.defer(1, this);
    }
  },

  refresh: function (callback) {
    if (this.defaultUrl == null) {
      return;
    }
    this.update(this.defaultUrl, null, callback, true);
  },

  startAutoRefresh: function (interval, url, params, callback, refreshNow) {
    if (refreshNow) {
      this.update(url || this.defaultUrl, params, callback, true);
    }
    if (this.autoRefreshProcId) {
      clearInterval(this.autoRefreshProcId);
    }
    this.autoRefreshProcId = setInterval(
      this.update.createDelegate(this, [
        url || this.defaultUrl,
        params,
        callback,
        true,
      ]),
      interval * 1000,
    );
  },

  stopAutoRefresh: function () {
    if (this.autoRefreshProcId) {
      clearInterval(this.autoRefreshProcId);
      delete this.autoRefreshProcId;
    }
  },

  isAutoRefreshing: function () {
    return this.autoRefreshProcId ? true : false;
  },

  showLoading: function () {
    if (this.showLoadIndicator) {
      this.el.update(this.indicatorText);
    }
  },

  // private
  processSuccess: function (response) {
    this.transaction = null;
    if (response.argument.form && response.argument.reset) {
      try {
        // put in try/catch since some older FF releases had problems with this
        response.argument.form.reset();
      } catch (e) {}
    }
    if (this.loadScripts) {
      this.renderer.render(
        this.el,
        response,
        this,
        this.updateComplete.createDelegate(this, [response]),
      );
    } else {
      this.renderer.render(this.el, response, this);
      this.updateComplete(response);
    }
  },

  // private
  updateComplete: function (response) {
    this.fireEvent('update', this.el, response);
    if (typeof response.argument.callback == 'function') {
      response.argument.callback.call(
        response.argument.scope,
        this.el,
        true,
        response,
        response.argument.options,
      );
    }
  },

  // private
  processFailure: function (response) {
    this.transaction = null;
    this.fireEvent('failure', this.el, response);
    if (typeof response.argument.callback == 'function') {
      response.argument.callback.call(
        response.argument.scope,
        this.el,
        false,
        response,
        response.argument.options,
      );
    }
  },

  setRenderer: function (renderer) {
    this.renderer = renderer;
  },

  getRenderer: function () {
    return this.renderer;
  },

  setDefaultUrl: function (defaultUrl) {
    this.defaultUrl = defaultUrl;
  },

  abort: function () {
    if (this.transaction) {
      Ext.Ajax.abort(this.transaction);
    }
  },

  isUpdating: function () {
    if (this.transaction) {
      return Ext.Ajax.isLoading(this.transaction);
    }
    return false;
  },
});

Ext.Updater.defaults = {
  timeout: 30,

  loadScripts: false,

  sslBlankUrl: Ext.SSL_SECURE_URL || 'javascript:false',

  disableCaching: false,

  showLoadIndicator: true,

  indicatorText: '<div class="loading-indicator">Loading...</div>',
};

Ext.Updater.updateElement = function (el, url, params, options) {
  var um = Ext.get(el).getUpdater();
  Ext.apply(um, options);
  um.update(url, params, options ? options.callback : null);
};

Ext.Updater.BasicRenderer = function () {};

Ext.Updater.BasicRenderer.prototype = {
  render: function (el, response, updateManager, callback) {
    el.update(response.responseText, updateManager.loadScripts, callback);
  },
};

Ext.UpdateManager = Ext.Updater;

Ext.util.DelayedTask = function (fn, scope, args) {
  var id = null;

  var call = function () {
    id = null;
    fn.apply(scope, args || []);
  };

  this.delay = function (delay, newFn, newScope, newArgs) {
    if (id) {
      this.cancel();
    }
    fn = newFn || fn;
    scope = newScope || scope;
    args = newArgs || args;
    if (!id) {
      id = setTimeout(call, delay);
    }
  };

  this.cancel = function () {
    if (id) {
      clearTimeout(id);
      id = null;
    }
  };
};
/*
 * Ext JS Library 2.3.0
 * Copyright(c) 2006-2009, Ext JS, LLC.
 * licensing@extjs.com
 *
 * http://extjs.com/license
 */

/*
 * These classes are derivatives of the similarly named classes in the YUI Library.
 * The original license:
 * Copyright (c) 2006, Yahoo! Inc. All rights reserved.
 * Code licensed under the BSD License:
 * http://developer.yahoo.net/yui/license.txt
 */

(function () {
  var Event = Ext.EventManager;
  var Dom = Ext.lib.Dom;

  /**
   * @class Ext.dd.DragDrop
   * Defines the interface and base operation of items that that can be
   * dragged or can be drop targets.  It was designed to be extended, overriding
   * the event handlers for startDrag, onDrag, onDragOver and onDragOut.
   * Up to three html elements can be associated with a DragDrop instance:
   * <ul>
   * <li>linked element: the element that is passed into the constructor.
   * This is the element which defines the boundaries for interaction with
   * other DragDrop objects.</li>
   * <li>handle element(s): The drag operation only occurs if the element that
   * was clicked matches a handle element.  By default this is the linked
   * element, but there are times that you will want only a portion of the
   * linked element to initiate the drag operation, and the setHandleElId()
   * method provides a way to define this.</li>
   * <li>drag element: this represents the element that would be moved along
   * with the cursor during a drag operation.  By default, this is the linked
   * element itself as in {@link Ext.dd.DD}.  setDragElId() lets you define
   * a separate element that would be moved, as in {@link Ext.dd.DDProxy}.
   * </li>
   * </ul>
   * This class should not be instantiated until the onload event to ensure that
   * the associated elements are available.
   * The following would define a DragDrop obj that would interact with any
   * other DragDrop obj in the "group1" group:
   * <pre>
   *  dd = new Ext.dd.DragDrop("div1", "group1");
   * </pre>
   * Since none of the event handlers have been implemented, nothing would
   * actually happen if you were to run the code above.  Normally you would
   * override this class or one of the default implementations, but you can
   * also override the methods you want on an instance of the class...
   * <pre>
   *  dd.onDragDrop = function(e, id) {
   *  &nbsp;&nbsp;alert("dd was dropped on " + id);
   *  }
   * </pre>
   * @constructor
   * @param {String} id of the element that is linked to this instance
   * @param {String} sGroup the group of related DragDrop objects
   * @param {object} config an object containing configurable attributes
   *                Valid properties for DragDrop:
   *                    padding, isTarget, maintainOffset, primaryButtonOnly
   */
  Ext.dd.DragDrop = function (id, sGroup, config) {
    if (id) {
      this.init(id, sGroup, config);
    }
  };

  Ext.dd.DragDrop.prototype = {
    /**
     * The id of the element associated with this object.  This is what we
     * refer to as the "linked element" because the size and position of
     * this element is used to determine when the drag and drop objects have
     * interacted.
     * @property id
     * @type String
     */
    id: null,

    /**
     * Configuration attributes passed into the constructor
     * @property config
     * @type object
     */
    config: null,

    /**
     * The id of the element that will be dragged.  By default this is same
     * as the linked element , but could be changed to another element. Ex:
     * Ext.dd.DDProxy
     * @property dragElId
     * @type String
     * @private
     */
    dragElId: null,

    /**
     * The ID of the element that initiates the drag operation.  By default
     * this is the linked element, but could be changed to be a child of this
     * element.  This lets us do things like only starting the drag when the
     * header element within the linked html element is clicked.
     * @property handleElId
     * @type String
     * @private
     */
    handleElId: null,

    /**
     * An object who's property names identify HTML tags to be considered invalid as drag handles.
     * A non-null property value identifies the tag as invalid. Defaults to the 
     * following value which prevents drag operations from being initiated by &lt;a> elements:<pre><code>
{
    A: "A"
}</code></pre>
     * @property invalidHandleTypes
     * @type Object
     */
    invalidHandleTypes: null,

    /**
     * An object who's property names identify the IDs of elements to be considered invalid as drag handles.
     * A non-null property value identifies the ID as invalid. For example, to prevent
     * dragging from being initiated on element ID "foo", use:<pre><code>
{
    foo: true
}</code></pre>
     * @property invalidHandleIds
     * @type Object
     */
    invalidHandleIds: null,

    /**
     * An Array of CSS class names for elements to be considered in valid as drag handles.
     * @property invalidHandleClasses
     * @type Array
     */
    invalidHandleClasses: null,

    /**
     * The linked element's absolute X position at the time the drag was
     * started
     * @property startPageX
     * @type int
     * @private
     */
    startPageX: 0,

    /**
     * The linked element's absolute X position at the time the drag was
     * started
     * @property startPageY
     * @type int
     * @private
     */
    startPageY: 0,

    /**
     * The group defines a logical collection of DragDrop objects that are
     * related.  Instances only get events when interacting with other
     * DragDrop object in the same group.  This lets us define multiple
     * groups using a single DragDrop subclass if we want.
     * @property groups
     * @type object An object in the format {'group1':true, 'group2':true}
     */
    groups: null,

    /**
     * Individual drag/drop instances can be locked.  This will prevent
     * onmousedown start drag.
     * @property locked
     * @type boolean
     * @private
     */
    locked: false,

    /**
     * Lock this instance
     * @method lock
     */
    lock: function () {
      this.locked = true;
    },

    /**
     * When set to true, other DD objects in cooperating DDGroups do not receive
     * notification events when this DD object is dragged over them. Defaults to false.
     * @property moveOnly
     * @type boolean
     */
    moveOnly: false,

    /**
     * Unlock this instace
     * @method unlock
     */
    unlock: function () {
      this.locked = false;
    },

    /**
     * By default, all instances can be a drop target.  This can be disabled by
     * setting isTarget to false.
     * @property isTarget
     * @type boolean
     */
    isTarget: true,

    /**
     * The padding configured for this drag and drop object for calculating
     * the drop zone intersection with this object.
     * @property padding
     * @type int[] An array containing the 4 padding values: [top, right, bottom, left]
     */
    padding: null,

    /**
     * Cached reference to the linked element
     * @property _domRef
     * @private
     */
    _domRef: null,

    /**
     * Internal typeof flag
     * @property __ygDragDrop
     * @private
     */
    __ygDragDrop: true,

    /**
     * Set to true when horizontal contraints are applied
     * @property constrainX
     * @type boolean
     * @private
     */
    constrainX: false,

    /**
     * Set to true when vertical contraints are applied
     * @property constrainY
     * @type boolean
     * @private
     */
    constrainY: false,

    /**
     * The left constraint
     * @property minX
     * @type int
     * @private
     */
    minX: 0,

    /**
     * The right constraint
     * @property maxX
     * @type int
     * @private
     */
    maxX: 0,

    /**
     * The up constraint
     * @property minY
     * @type int
     * @type int
     * @private
     */
    minY: 0,

    /**
     * The down constraint
     * @property maxY
     * @type int
     * @private
     */
    maxY: 0,

    /**
     * Maintain offsets when we resetconstraints.  Set to true when you want
     * the position of the element relative to its parent to stay the same
     * when the page changes
     *
     * @property maintainOffset
     * @type boolean
     */
    maintainOffset: false,

    /**
     * Array of pixel locations the element will snap to if we specified a
     * horizontal graduation/interval.  This array is generated automatically
     * when you define a tick interval.
     * @property xTicks
     * @type int[]
     */
    xTicks: null,

    /**
     * Array of pixel locations the element will snap to if we specified a
     * vertical graduation/interval.  This array is generated automatically
     * when you define a tick interval.
     * @property yTicks
     * @type int[]
     */
    yTicks: null,

    /**
     * By default the drag and drop instance will only respond to the primary
     * button click (left button for a right-handed mouse).  Set to true to
     * allow drag and drop to start with any mouse click that is propogated
     * by the browser
     * @property primaryButtonOnly
     * @type boolean
     */
    primaryButtonOnly: true,

    /**
     * The availabe property is false until the linked dom element is accessible.
     * @property available
     * @type boolean
     */
    available: false,

    /**
     * By default, drags can only be initiated if the mousedown occurs in the
     * region the linked element is.  This is done in part to work around a
     * bug in some browsers that mis-report the mousedown if the previous
     * mouseup happened outside of the window.  This property is set to true
     * if outer handles are defined.
     *
     * @property hasOuterHandles
     * @type boolean
     * @default false
     */
    hasOuterHandles: false,

    /**
     * Code that executes immediately before the startDrag event
     * @method b4StartDrag
     * @private
     */
    b4StartDrag: function (x, y) {},

    /**
     * Abstract method called after a drag/drop object is clicked
     * and the drag or mousedown time thresholds have beeen met.
     * @method startDrag
     * @param {int} X click location
     * @param {int} Y click location
     */
    startDrag: function (x, y) {
      /* override this */
    },

    /**
     * Code that executes immediately before the onDrag event
     * @method b4Drag
     * @private
     */
    b4Drag: function (e) {},

    /**
     * Abstract method called during the onMouseMove event while dragging an
     * object.
     * @method onDrag
     * @param {Event} e the mousemove event
     */
    onDrag: function (e) {
      /* override this */
    },

    /**
     * Abstract method called when this element fist begins hovering over
     * another DragDrop obj
     * @method onDragEnter
     * @param {Event} e the mousemove event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this is hovering over.  In INTERSECT mode, an array of one or more
     * dragdrop items being hovered over.
     */
    onDragEnter: function (e, id) {
      /* override this */
    },

    /**
     * Code that executes immediately before the onDragOver event
     * @method b4DragOver
     * @private
     */
    b4DragOver: function (e) {},

    /**
     * Abstract method called when this element is hovering over another
     * DragDrop obj
     * @method onDragOver
     * @param {Event} e the mousemove event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this is hovering over.  In INTERSECT mode, an array of dd items
     * being hovered over.
     */
    onDragOver: function (e, id) {
      /* override this */
    },

    /**
     * Code that executes immediately before the onDragOut event
     * @method b4DragOut
     * @private
     */
    b4DragOut: function (e) {},

    /**
     * Abstract method called when we are no longer hovering over an element
     * @method onDragOut
     * @param {Event} e the mousemove event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this was hovering over.  In INTERSECT mode, an array of dd items
     * that the mouse is no longer over.
     */
    onDragOut: function (e, id) {
      /* override this */
    },

    /**
     * Code that executes immediately before the onDragDrop event
     * @method b4DragDrop
     * @private
     */
    b4DragDrop: function (e) {},

    /**
     * Abstract method called when this item is dropped on another DragDrop
     * obj
     * @method onDragDrop
     * @param {Event} e the mouseup event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this was dropped on.  In INTERSECT mode, an array of dd items this
     * was dropped on.
     */
    onDragDrop: function (e, id) {
      /* override this */
    },

    /**
     * Abstract method called when this item is dropped on an area with no
     * drop target
     * @method onInvalidDrop
     * @param {Event} e the mouseup event
     */
    onInvalidDrop: function (e) {
      /* override this */
    },

    /**
     * Code that executes immediately before the endDrag event
     * @method b4EndDrag
     * @private
     */
    b4EndDrag: function (e) {},

    /**
     * Fired when we are done dragging the object
     * @method endDrag
     * @param {Event} e the mouseup event
     */
    endDrag: function (e) {
      /* override this */
    },

    /**
     * Code executed immediately before the onMouseDown event
     * @method b4MouseDown
     * @param {Event} e the mousedown event
     * @private
     */
    b4MouseDown: function (e) {},

    /**
     * Event handler that fires when a drag/drop obj gets a mousedown
     * @method onMouseDown
     * @param {Event} e the mousedown event
     */
    onMouseDown: function (e) {
      /* override this */
    },

    /**
     * Event handler that fires when a drag/drop obj gets a mouseup
     * @method onMouseUp
     * @param {Event} e the mouseup event
     */
    onMouseUp: function (e) {
      /* override this */
    },

    /**
     * Override the onAvailable method to do what is needed after the initial
     * position was determined.
     * @method onAvailable
     */
    onAvailable: function () {},

    /**
     * Provides default constraint padding to "constrainTo" elements (defaults to {left: 0, right:0, top:0, bottom:0}).
     * @type Object
     */
    defaultPadding: { left: 0, right: 0, top: 0, bottom: 0 },

    /**
     * Initializes the drag drop object's constraints to restrict movement to a certain element.
 *
 * Usage:
 <pre><code>
 var dd = new Ext.dd.DDProxy("dragDiv1", "proxytest",
                { dragElId: "existingProxyDiv" });
 dd.startDrag = function(){
     this.constrainTo("parent-id");
 };
 </code></pre>
 * Or you can initalize it using the {@link Ext.Element} object:
 <pre><code>
 Ext.get("dragDiv1").initDDProxy("proxytest", {dragElId: "existingProxyDiv"}, {
     startDrag : function(){
         this.constrainTo("parent-id");
     }
 });
 </code></pre>
     * @param {Mixed} constrainTo The element to constrain to.
     * @param {Object/Number} pad (optional) Pad provides a way to specify "padding" of the constraints,
     * and can be either a number for symmetrical padding (4 would be equal to {left:4, right:4, top:4, bottom:4}) or
     * an object containing the sides to pad. For example: {right:10, bottom:10}
     * @param {Boolean} inContent (optional) Constrain the draggable in the content box of the element (inside padding and borders)
     */
    constrainTo: function (constrainTo, pad, inContent) {
      if (typeof pad == 'number') {
        pad = { left: pad, right: pad, top: pad, bottom: pad };
      }
      pad = pad || this.defaultPadding;
      var b = Ext.get(this.getEl()).getBox();
      var ce = Ext.get(constrainTo);
      var s = ce.getScroll();
      var c,
        cd = ce.dom;
      if (cd == document.body) {
        c = {
          x: s.left,
          y: s.top,
          width: Ext.lib.Dom.getViewWidth(),
          height: Ext.lib.Dom.getViewHeight(),
        };
      } else {
        var xy = ce.getXY();
        c = {
          x: xy[0] + s.left,
          y: xy[1] + s.top,
          width: cd.clientWidth,
          height: cd.clientHeight,
        };
      }

      var topSpace = b.y - c.y;
      var leftSpace = b.x - c.x;

      this.resetConstraints();
      this.setXConstraint(
        leftSpace - (pad.left || 0), // left
        c.width - leftSpace - b.width - (pad.right || 0), //right
        this.xTickSize,
      );
      this.setYConstraint(
        topSpace - (pad.top || 0), //top
        c.height - topSpace - b.height - (pad.bottom || 0), //bottom
        this.yTickSize,
      );
    },

    /**
     * Returns a reference to the linked element
     * @method getEl
     * @return {HTMLElement} the html element
     */
    getEl: function () {
      if (!this._domRef) {
        this._domRef = Ext.getDom(this.id);
      }

      return this._domRef;
    },

    /**
     * Returns a reference to the actual element to drag.  By default this is
     * the same as the html element, but it can be assigned to another
     * element. An example of this can be found in Ext.dd.DDProxy
     * @method getDragEl
     * @return {HTMLElement} the html element
     */
    getDragEl: function () {
      return Ext.getDom(this.dragElId);
    },

    /**
     * Sets up the DragDrop object.  Must be called in the constructor of any
     * Ext.dd.DragDrop subclass
     * @method init
     * @param id the id of the linked element
     * @param {String} sGroup the group of related items
     * @param {object} config configuration attributes
     */
    init: function (id, sGroup, config) {
      this.initTarget(id, sGroup, config);
      Event.on(this.id, 'mousedown', this.handleMouseDown, this);
      // Event.on(this.id, "selectstart", Event.preventDefault);
    },

    /**
     * Initializes Targeting functionality only... the object does not
     * get a mousedown handler.
     * @method initTarget
     * @param id the id of the linked element
     * @param {String} sGroup the group of related items
     * @param {object} config configuration attributes
     */
    initTarget: function (id, sGroup, config) {
      // configuration attributes
      this.config = config || {};

      // create a local reference to the drag and drop manager
      this.DDM = Ext.dd.DDM;
      // initialize the groups array
      this.groups = {};

      // assume that we have an element reference instead of an id if the
      // parameter is not a string
      if (typeof id !== 'string') {
        id = Ext.id(id);
      }

      // set the id
      this.id = id;

      // add to an interaction group
      this.addToGroup(sGroup ? sGroup : 'default');

      // We don't want to register this as the handle with the manager
      // so we just set the id rather than calling the setter.
      this.handleElId = id;

      // the linked element is the element that gets dragged by default
      this.setDragElId(id);

      // by default, clicked anchors will not start drag operations.
      this.invalidHandleTypes = { A: 'A' };
      this.invalidHandleIds = {};
      this.invalidHandleClasses = [];

      this.applyConfig();

      this.handleOnAvailable();
    },

    /**
     * Applies the configuration parameters that were passed into the constructor.
     * This is supposed to happen at each level through the inheritance chain.  So
     * a DDProxy implentation will execute apply config on DDProxy, DD, and
     * DragDrop in order to get all of the parameters that are available in
     * each object.
     * @method applyConfig
     */
    applyConfig: function () {
      // configurable properties:
      //    padding, isTarget, maintainOffset, primaryButtonOnly
      this.padding = this.config.padding || [0, 0, 0, 0];
      this.isTarget = this.config.isTarget !== false;
      this.maintainOffset = this.config.maintainOffset;
      this.primaryButtonOnly = this.config.primaryButtonOnly !== false;
    },

    /**
     * Executed when the linked element is available
     * @method handleOnAvailable
     * @private
     */
    handleOnAvailable: function () {
      this.available = true;
      this.resetConstraints();
      this.onAvailable();
    },

    /**
     * Configures the padding for the target zone in px.  Effectively expands
     * (or reduces) the virtual object size for targeting calculations.
     * Supports css-style shorthand; if only one parameter is passed, all sides
     * will have that padding, and if only two are passed, the top and bottom
     * will have the first param, the left and right the second.
     * @method setPadding
     * @param {int} iTop    Top pad
     * @param {int} iRight  Right pad
     * @param {int} iBot    Bot pad
     * @param {int} iLeft   Left pad
     */
    setPadding: function (iTop, iRight, iBot, iLeft) {
      // this.padding = [iLeft, iRight, iTop, iBot];
      if (!iRight && 0 !== iRight) {
        this.padding = [iTop, iTop, iTop, iTop];
      } else if (!iBot && 0 !== iBot) {
        this.padding = [iTop, iRight, iTop, iRight];
      } else {
        this.padding = [iTop, iRight, iBot, iLeft];
      }
    },

    /**
     * Stores the initial placement of the linked element.
     * @method setInitPosition
     * @param {int} diffX   the X offset, default 0
     * @param {int} diffY   the Y offset, default 0
     */
    setInitPosition: function (diffX, diffY) {
      var el = this.getEl();

      if (!this.DDM.verifyEl(el)) {
        return;
      }

      var dx = diffX || 0;
      var dy = diffY || 0;

      var p = Dom.getXY(el);

      this.initPageX = p[0] - dx;
      this.initPageY = p[1] - dy;

      this.lastPageX = p[0];
      this.lastPageY = p[1];

      this.setStartPosition(p);
    },

    /**
     * Sets the start position of the element.  This is set when the obj
     * is initialized, the reset when a drag is started.
     * @method setStartPosition
     * @param pos current position (from previous lookup)
     * @private
     */
    setStartPosition: function (pos) {
      var p = pos || Dom.getXY(this.getEl());
      this.deltaSetXY = null;

      this.startPageX = p[0];
      this.startPageY = p[1];
    },

    /**
     * Add this instance to a group of related drag/drop objects.  All
     * instances belong to at least one group, and can belong to as many
     * groups as needed.
     * @method addToGroup
     * @param sGroup {string} the name of the group
     */
    addToGroup: function (sGroup) {
      this.groups[sGroup] = true;
      this.DDM.regDragDrop(this, sGroup);
    },

    /**
     * Remove's this instance from the supplied interaction group
     * @method removeFromGroup
     * @param {string}  sGroup  The group to drop
     */
    removeFromGroup: function (sGroup) {
      if (this.groups[sGroup]) {
        delete this.groups[sGroup];
      }

      this.DDM.removeDDFromGroup(this, sGroup);
    },

    /**
     * Allows you to specify that an element other than the linked element
     * will be moved with the cursor during a drag
     * @method setDragElId
     * @param id {string} the id of the element that will be used to initiate the drag
     */
    setDragElId: function (id) {
      this.dragElId = id;
    },

    /**
     * Allows you to specify a child of the linked element that should be
     * used to initiate the drag operation.  An example of this would be if
     * you have a content div with text and links.  Clicking anywhere in the
     * content area would normally start the drag operation.  Use this method
     * to specify that an element inside of the content div is the element
     * that starts the drag operation.
     * @method setHandleElId
     * @param id {string} the id of the element that will be used to
     * initiate the drag.
     */
    setHandleElId: function (id) {
      if (typeof id !== 'string') {
        id = Ext.id(id);
      }
      this.handleElId = id;
      this.DDM.regHandle(this.id, id);
    },

    /**
     * Allows you to set an element outside of the linked element as a drag
     * handle
     * @method setOuterHandleElId
     * @param id the id of the element that will be used to initiate the drag
     */
    setOuterHandleElId: function (id) {
      if (typeof id !== 'string') {
        id = Ext.id(id);
      }
      Event.on(id, 'mousedown', this.handleMouseDown, this);
      this.setHandleElId(id);

      this.hasOuterHandles = true;
    },

    /**
     * Remove all drag and drop hooks for this element
     * @method unreg
     */
    unreg: function () {
      Event.un(this.id, 'mousedown', this.handleMouseDown);
      this._domRef = null;
      this.DDM._remove(this);
    },

    destroy: function () {
      this.unreg();
    },

    /**
     * Returns true if this instance is locked, or the drag drop mgr is locked
     * (meaning that all drag/drop is disabled on the page.)
     * @method isLocked
     * @return {boolean} true if this obj or all drag/drop is locked, else
     * false
     */
    isLocked: function () {
      return this.DDM.isLocked() || this.locked;
    },

    /**
     * Fired when this object is clicked
     * @method handleMouseDown
     * @param {Event} e
     * @param {Ext.dd.DragDrop} oDD the clicked dd object (this dd obj)
     * @private
     */
    handleMouseDown: function (e, oDD) {
      if (this.primaryButtonOnly && e.button != 0) {
        return;
      }

      if (this.isLocked()) {
        return;
      }

      this.DDM.refreshCache(this.groups);

      var pt = new Ext.lib.Point(
        Ext.lib.Event.getPageX(e),
        Ext.lib.Event.getPageY(e),
      );
      if (!this.hasOuterHandles && !this.DDM.isOverTarget(pt, this)) {
      } else {
        if (this.clickValidator(e)) {
          // set the initial element position
          this.setStartPosition();

          this.b4MouseDown(e);
          this.onMouseDown(e);

          this.DDM.handleMouseDown(e, this);

          this.DDM.stopEvent(e);
        } else {
        }
      }
    },

    clickValidator: function (e) {
      var target = e.getTarget();
      return (
        this.isValidHandleChild(target) &&
        (this.id == this.handleElId ||
          this.DDM.handleWasClicked(target, this.id))
      );
    },

    /**
     * Allows you to specify a tag name that should not start a drag operation
     * when clicked.  This is designed to facilitate embedding links within a
     * drag handle that do something other than start the drag.
     * @method addInvalidHandleType
     * @param {string} tagName the type of element to exclude
     */
    addInvalidHandleType: function (tagName) {
      var type = tagName.toUpperCase();
      this.invalidHandleTypes[type] = type;
    },

    /**
     * Lets you to specify an element id for a child of a drag handle
     * that should not initiate a drag
     * @method addInvalidHandleId
     * @param {string} id the element id of the element you wish to ignore
     */
    addInvalidHandleId: function (id) {
      if (typeof id !== 'string') {
        id = Ext.id(id);
      }
      this.invalidHandleIds[id] = id;
    },

    /**
     * Lets you specify a css class of elements that will not initiate a drag
     * @method addInvalidHandleClass
     * @param {string} cssClass the class of the elements you wish to ignore
     */
    addInvalidHandleClass: function (cssClass) {
      this.invalidHandleClasses.push(cssClass);
    },

    /**
     * Unsets an excluded tag name set by addInvalidHandleType
     * @method removeInvalidHandleType
     * @param {string} tagName the type of element to unexclude
     */
    removeInvalidHandleType: function (tagName) {
      var type = tagName.toUpperCase();
      // this.invalidHandleTypes[type] = null;
      delete this.invalidHandleTypes[type];
    },

    /**
     * Unsets an invalid handle id
     * @method removeInvalidHandleId
     * @param {string} id the id of the element to re-enable
     */
    removeInvalidHandleId: function (id) {
      if (typeof id !== 'string') {
        id = Ext.id(id);
      }
      delete this.invalidHandleIds[id];
    },

    /**
     * Unsets an invalid css class
     * @method removeInvalidHandleClass
     * @param {string} cssClass the class of the element(s) you wish to
     * re-enable
     */
    removeInvalidHandleClass: function (cssClass) {
      for (var i = 0, len = this.invalidHandleClasses.length; i < len; ++i) {
        if (this.invalidHandleClasses[i] == cssClass) {
          delete this.invalidHandleClasses[i];
        }
      }
    },

    /**
     * Checks the tag exclusion list to see if this click should be ignored
     * @method isValidHandleChild
     * @param {HTMLElement} node the HTMLElement to evaluate
     * @return {boolean} true if this is a valid tag type, false if not
     */
    isValidHandleChild: function (node) {
      var valid = true;
      // var n = (node.nodeName == "#text") ? node.parentNode : node;
      var nodeName;
      try {
        nodeName = node.nodeName.toUpperCase();
      } catch (e) {
        nodeName = node.nodeName;
      }
      valid = valid && !this.invalidHandleTypes[nodeName];
      valid = valid && !this.invalidHandleIds[node.id];

      for (
        var i = 0, len = this.invalidHandleClasses.length;
        valid && i < len;
        ++i
      ) {
        valid = !Ext.fly(node).hasClass(this.invalidHandleClasses[i]);
      }

      return valid;
    },

    /**
     * Create the array of horizontal tick marks if an interval was specified
     * in setXConstraint().
     * @method setXTicks
     * @private
     */
    setXTicks: function (iStartX, iTickSize) {
      this.xTicks = [];
      this.xTickSize = iTickSize;

      var tickMap = {};

      for (var i = this.initPageX; i >= this.minX; i = i - iTickSize) {
        if (!tickMap[i]) {
          this.xTicks[this.xTicks.length] = i;
          tickMap[i] = true;
        }
      }

      for (i = this.initPageX; i <= this.maxX; i = i + iTickSize) {
        if (!tickMap[i]) {
          this.xTicks[this.xTicks.length] = i;
          tickMap[i] = true;
        }
      }

      this.xTicks.sort(this.DDM.numericSort);
    },

    /**
     * Create the array of vertical tick marks if an interval was specified in
     * setYConstraint().
     * @method setYTicks
     * @private
     */
    setYTicks: function (iStartY, iTickSize) {
      this.yTicks = [];
      this.yTickSize = iTickSize;

      var tickMap = {};

      for (var i = this.initPageY; i >= this.minY; i = i - iTickSize) {
        if (!tickMap[i]) {
          this.yTicks[this.yTicks.length] = i;
          tickMap[i] = true;
        }
      }

      for (i = this.initPageY; i <= this.maxY; i = i + iTickSize) {
        if (!tickMap[i]) {
          this.yTicks[this.yTicks.length] = i;
          tickMap[i] = true;
        }
      }

      this.yTicks.sort(this.DDM.numericSort);
    },

    /**
     * By default, the element can be dragged any place on the screen.  Use
     * this method to limit the horizontal travel of the element.  Pass in
     * 0,0 for the parameters if you want to lock the drag to the y axis.
     * @method setXConstraint
     * @param {int} iLeft the number of pixels the element can move to the left
     * @param {int} iRight the number of pixels the element can move to the
     * right
     * @param {int} iTickSize optional parameter for specifying that the
     * element
     * should move iTickSize pixels at a time.
     */
    setXConstraint: function (iLeft, iRight, iTickSize) {
      this.leftConstraint = iLeft;
      this.rightConstraint = iRight;

      this.minX = this.initPageX - iLeft;
      this.maxX = this.initPageX + iRight;
      if (iTickSize) {
        this.setXTicks(this.initPageX, iTickSize);
      }

      this.constrainX = true;
    },

    /**
     * Clears any constraints applied to this instance.  Also clears ticks
     * since they can't exist independent of a constraint at this time.
     * @method clearConstraints
     */
    clearConstraints: function () {
      this.constrainX = false;
      this.constrainY = false;
      this.clearTicks();
    },

    /**
     * Clears any tick interval defined for this instance
     * @method clearTicks
     */
    clearTicks: function () {
      this.xTicks = null;
      this.yTicks = null;
      this.xTickSize = 0;
      this.yTickSize = 0;
    },

    /**
     * By default, the element can be dragged any place on the screen.  Set
     * this to limit the vertical travel of the element.  Pass in 0,0 for the
     * parameters if you want to lock the drag to the x axis.
     * @method setYConstraint
     * @param {int} iUp the number of pixels the element can move up
     * @param {int} iDown the number of pixels the element can move down
     * @param {int} iTickSize optional parameter for specifying that the
     * element should move iTickSize pixels at a time.
     */
    setYConstraint: function (iUp, iDown, iTickSize) {
      this.topConstraint = iUp;
      this.bottomConstraint = iDown;

      this.minY = this.initPageY - iUp;
      this.maxY = this.initPageY + iDown;
      if (iTickSize) {
        this.setYTicks(this.initPageY, iTickSize);
      }

      this.constrainY = true;
    },

    /**
     * resetConstraints must be called if you manually reposition a dd element.
     * @method resetConstraints
     * @param {boolean} maintainOffset
     */
    resetConstraints: function () {
      // Maintain offsets if necessary
      if (this.initPageX || this.initPageX === 0) {
        // figure out how much this thing has moved
        var dx = this.maintainOffset ? this.lastPageX - this.initPageX : 0;
        var dy = this.maintainOffset ? this.lastPageY - this.initPageY : 0;

        this.setInitPosition(dx, dy);

        // This is the first time we have detected the element's position
      } else {
        this.setInitPosition();
      }

      if (this.constrainX) {
        this.setXConstraint(
          this.leftConstraint,
          this.rightConstraint,
          this.xTickSize,
        );
      }

      if (this.constrainY) {
        this.setYConstraint(
          this.topConstraint,
          this.bottomConstraint,
          this.yTickSize,
        );
      }
    },

    /**
     * Normally the drag element is moved pixel by pixel, but we can specify
     * that it move a number of pixels at a time.  This method resolves the
     * location when we have it set up like this.
     * @method getTick
     * @param {int} val where we want to place the object
     * @param {int[]} tickArray sorted array of valid points
     * @return {int} the closest tick
     * @private
     */
    getTick: function (val, tickArray) {
      if (!tickArray) {
        // If tick interval is not defined, it is effectively 1 pixel,
        // so we return the value passed to us.
        return val;
      } else if (tickArray[0] >= val) {
        // The value is lower than the first tick, so we return the first
        // tick.
        return tickArray[0];
      } else {
        for (var i = 0, len = tickArray.length; i < len; ++i) {
          var next = i + 1;
          if (tickArray[next] && tickArray[next] >= val) {
            var diff1 = val - tickArray[i];
            var diff2 = tickArray[next] - val;
            return diff2 > diff1 ? tickArray[i] : tickArray[next];
          }
        }

        // The value is larger than the last tick, so we return the last
        // tick.
        return tickArray[tickArray.length - 1];
      }
    },

    /**
     * toString method
     * @method toString
     * @return {string} string representation of the dd obj
     */
    toString: function () {
      return 'DragDrop ' + this.id;
    },
  };
})();
/**
 * The drag and drop utility provides a framework for building drag and drop
 * applications.  In addition to enabling drag and drop for specific elements,
 * the drag and drop elements are tracked by the manager class, and the
 * interactions between the various elements are tracked during the drag and
 * the implementing code is notified about these important moments.
 */

// Only load the library once.  Rewriting the manager class would orphan
// existing drag and drop instances.
if (!Ext.dd.DragDropMgr) {
  /**
   * @class Ext.dd.DragDropMgr
   * DragDropMgr is a singleton that tracks the element interaction for
   * all DragDrop items in the window.  Generally, you will not call
   * this class directly, but it does have helper methods that could
   * be useful in your DragDrop implementations.
   * @singleton
   */
  Ext.dd.DragDropMgr = (function () {
    var Event = Ext.EventManager;

    return {
      /**
       * Two dimensional Array of registered DragDrop objects.  The first
       * dimension is the DragDrop item group, the second the DragDrop
       * object.
       * @property ids
       * @type {string: string}
       * @private
       * @static
       */
      ids: {},

      /**
       * Array of element ids defined as drag handles.  Used to determine
       * if the element that generated the mousedown event is actually the
       * handle and not the html element itself.
       * @property handleIds
       * @type {string: string}
       * @private
       * @static
       */
      handleIds: {},

      /**
       * the DragDrop object that is currently being dragged
       * @property dragCurrent
       * @type DragDrop
       * @private
       * @static
       **/
      dragCurrent: null,

      /**
       * the DragDrop object(s) that are being hovered over
       * @property dragOvers
       * @type Array
       * @private
       * @static
       */
      dragOvers: {},

      /**
       * the X distance between the cursor and the object being dragged
       * @property deltaX
       * @type int
       * @private
       * @static
       */
      deltaX: 0,

      /**
       * the Y distance between the cursor and the object being dragged
       * @property deltaY
       * @type int
       * @private
       * @static
       */
      deltaY: 0,

      /**
       * Flag to determine if we should prevent the default behavior of the
       * events we define. By default this is true, but this can be set to
       * false if you need the default behavior (not recommended)
       * @property preventDefault
       * @type boolean
       * @static
       */
      preventDefault: true,

      /**
       * Flag to determine if we should stop the propagation of the events
       * we generate. This is true by default but you may want to set it to
       * false if the html element contains other features that require the
       * mouse click.
       * @property stopPropagation
       * @type boolean
       * @static
       */
      stopPropagation: true,

      /**
       * Internal flag that is set to true when drag and drop has been
       * intialized
       * @property initialized
       * @private
       * @static
       */
      initialized: false,

      /**
       * All drag and drop can be disabled.
       * @property locked
       * @private
       * @static
       */
      locked: false,

      /**
       * Called the first time an element is registered.
       * @method init
       * @private
       * @static
       */
      init: function () {
        this.initialized = true;
      },

      /**
       * In point mode, drag and drop interaction is defined by the
       * location of the cursor during the drag/drop
       * @property POINT
       * @type int
       * @static
       */
      POINT: 0,

      /**
       * In intersect mode, drag and drop interaction is defined by the
       * overlap of two or more drag and drop objects.
       * @property INTERSECT
       * @type int
       * @static
       */
      INTERSECT: 1,

      /**
       * The current drag and drop mode.  Default: POINT
       * @property mode
       * @type int
       * @static
       */
      mode: 0,

      /**
       * Runs method on all drag and drop objects
       * @method _execOnAll
       * @private
       * @static
       */
      _execOnAll: function (sMethod, args) {
        for (var i in this.ids) {
          for (var j in this.ids[i]) {
            var oDD = this.ids[i][j];
            if (!this.isTypeOfDD(oDD)) {
              continue;
            }
            oDD[sMethod].apply(oDD, args);
          }
        }
      },

      /**
       * Drag and drop initialization.  Sets up the global event handlers
       * @method _onLoad
       * @private
       * @static
       */
      _onLoad: function () {
        this.init();

        Event.on(document, 'mouseup', this.handleMouseUp, this, true);
        Event.on(document, 'mousemove', this.handleMouseMove, this, true);
        Event.on(window, 'unload', this._onUnload, this, true);
        Event.on(window, 'resize', this._onResize, this, true);
        // Event.on(window,   "mouseout",    this._test);
      },

      /**
       * Reset constraints on all drag and drop objs
       * @method _onResize
       * @private
       * @static
       */
      _onResize: function (e) {
        this._execOnAll('resetConstraints', []);
      },

      /**
       * Lock all drag and drop functionality
       * @method lock
       * @static
       */
      lock: function () {
        this.locked = true;
      },

      /**
       * Unlock all drag and drop functionality
       * @method unlock
       * @static
       */
      unlock: function () {
        this.locked = false;
      },

      /**
       * Is drag and drop locked?
       * @method isLocked
       * @return {boolean} True if drag and drop is locked, false otherwise.
       * @static
       */
      isLocked: function () {
        return this.locked;
      },

      /**
       * Location cache that is set for all drag drop objects when a drag is
       * initiated, cleared when the drag is finished.
       * @property locationCache
       * @private
       * @static
       */
      locationCache: {},

      /**
       * Set useCache to false if you want to force object the lookup of each
       * drag and drop linked element constantly during a drag.
       * @property useCache
       * @type boolean
       * @static
       */
      useCache: true,

      /**
       * The number of pixels that the mouse needs to move after the
       * mousedown before the drag is initiated.  Default=3;
       * @property clickPixelThresh
       * @type int
       * @static
       */
      clickPixelThresh: 3,

      /**
       * The number of milliseconds after the mousedown event to initiate the
       * drag if we don't get a mouseup event. Default=1000
       * @property clickTimeThresh
       * @type int
       * @static
       */
      clickTimeThresh: 350,

      /**
       * Flag that indicates that either the drag pixel threshold or the
       * mousdown time threshold has been met
       * @property dragThreshMet
       * @type boolean
       * @private
       * @static
       */
      dragThreshMet: false,

      /**
       * Timeout used for the click time threshold
       * @property clickTimeout
       * @type Object
       * @private
       * @static
       */
      clickTimeout: null,

      /**
       * The X position of the mousedown event stored for later use when a
       * drag threshold is met.
       * @property startX
       * @type int
       * @private
       * @static
       */
      startX: 0,

      /**
       * The Y position of the mousedown event stored for later use when a
       * drag threshold is met.
       * @property startY
       * @type int
       * @private
       * @static
       */
      startY: 0,

      /**
       * Each DragDrop instance must be registered with the DragDropMgr.
       * This is executed in DragDrop.init()
       * @method regDragDrop
       * @param {DragDrop} oDD the DragDrop object to register
       * @param {String} sGroup the name of the group this element belongs to
       * @static
       */
      regDragDrop: function (oDD, sGroup) {
        if (!this.initialized) {
          this.init();
        }

        if (!this.ids[sGroup]) {
          this.ids[sGroup] = {};
        }
        this.ids[sGroup][oDD.id] = oDD;
      },

      /**
       * Removes the supplied dd instance from the supplied group. Executed
       * by DragDrop.removeFromGroup, so don't call this function directly.
       * @method removeDDFromGroup
       * @private
       * @static
       */
      removeDDFromGroup: function (oDD, sGroup) {
        if (!this.ids[sGroup]) {
          this.ids[sGroup] = {};
        }

        var obj = this.ids[sGroup];
        if (obj && obj[oDD.id]) {
          delete obj[oDD.id];
        }
      },

      /**
       * Unregisters a drag and drop item.  This is executed in
       * DragDrop.unreg, use that method instead of calling this directly.
       * @method _remove
       * @private
       * @static
       */
      _remove: function (oDD) {
        for (var g in oDD.groups) {
          if (g && this.ids[g] && this.ids[g][oDD.id]) {
            delete this.ids[g][oDD.id];
          }
        }
        delete this.handleIds[oDD.id];
      },

      /**
       * Each DragDrop handle element must be registered.  This is done
       * automatically when executing DragDrop.setHandleElId()
       * @method regHandle
       * @param {String} sDDId the DragDrop id this element is a handle for
       * @param {String} sHandleId the id of the element that is the drag
       * handle
       * @static
       */
      regHandle: function (sDDId, sHandleId) {
        if (!this.handleIds[sDDId]) {
          this.handleIds[sDDId] = {};
        }
        this.handleIds[sDDId][sHandleId] = sHandleId;
      },

      /**
       * Utility function to determine if a given element has been
       * registered as a drag drop item.
       * @method isDragDrop
       * @param {String} id the element id to check
       * @return {boolean} true if this element is a DragDrop item,
       * false otherwise
       * @static
       */
      isDragDrop: function (id) {
        return this.getDDById(id) ? true : false;
      },

      /**
       * Returns the drag and drop instances that are in all groups the
       * passed in instance belongs to.
       * @method getRelated
       * @param {DragDrop} p_oDD the obj to get related data for
       * @param {boolean} bTargetsOnly if true, only return targetable objs
       * @return {DragDrop[]} the related instances
       * @static
       */
      getRelated: function (p_oDD, bTargetsOnly) {
        var oDDs = [];
        for (var i in p_oDD.groups) {
          for (var j in this.ids[i]) {
            var dd = this.ids[i][j];
            if (!this.isTypeOfDD(dd)) {
              continue;
            }
            if (!bTargetsOnly || dd.isTarget) {
              oDDs[oDDs.length] = dd;
            }
          }
        }

        return oDDs;
      },

      /**
       * Returns true if the specified dd target is a legal target for
       * the specifice drag obj
       * @method isLegalTarget
       * @param {DragDrop} the drag obj
       * @param {DragDrop} the target
       * @return {boolean} true if the target is a legal target for the
       * dd obj
       * @static
       */
      isLegalTarget: function (oDD, oTargetDD) {
        var targets = this.getRelated(oDD, true);
        for (var i = 0, len = targets.length; i < len; ++i) {
          if (targets[i].id == oTargetDD.id) {
            return true;
          }
        }

        return false;
      },

      /**
       * My goal is to be able to transparently determine if an object is
       * typeof DragDrop, and the exact subclass of DragDrop.  typeof
       * returns "object", oDD.constructor.toString() always returns
       * "DragDrop" and not the name of the subclass.  So for now it just
       * evaluates a well-known variable in DragDrop.
       * @method isTypeOfDD
       * @param {Object} the object to evaluate
       * @return {boolean} true if typeof oDD = DragDrop
       * @static
       */
      isTypeOfDD: function (oDD) {
        return oDD && oDD.__ygDragDrop;
      },

      /**
       * Utility function to determine if a given element has been
       * registered as a drag drop handle for the given Drag Drop object.
       * @method isHandle
       * @param {String} id the element id to check
       * @return {boolean} true if this element is a DragDrop handle, false
       * otherwise
       * @static
       */
      isHandle: function (sDDId, sHandleId) {
        return this.handleIds[sDDId] && this.handleIds[sDDId][sHandleId];
      },

      /**
       * Returns the DragDrop instance for a given id
       * @method getDDById
       * @param {String} id the id of the DragDrop object
       * @return {DragDrop} the drag drop object, null if it is not found
       * @static
       */
      getDDById: function (id) {
        for (var i in this.ids) {
          if (this.ids[i][id]) {
            return this.ids[i][id];
          }
        }
        return null;
      },

      /**
       * Fired after a registered DragDrop object gets the mousedown event.
       * Sets up the events required to track the object being dragged
       * @method handleMouseDown
       * @param {Event} e the event
       * @param oDD the DragDrop object being dragged
       * @private
       * @static
       */
      handleMouseDown: function (e, oDD) {
        if (Ext.QuickTips) {
          Ext.QuickTips.disable();
        }
        if (this.dragCurrent) {
          // the original browser mouseup wasn't handled (e.g. outside FF browser window)
          // so clean up first to avoid breaking the next drag
          this.handleMouseUp(e);
        }

        this.currentTarget = e.getTarget();
        this.dragCurrent = oDD;

        var el = oDD.getEl();

        // track start position
        this.startX = e.getPageX();
        this.startY = e.getPageY();

        this.deltaX = this.startX - el.offsetLeft;
        this.deltaY = this.startY - el.offsetTop;

        this.dragThreshMet = false;

        this.clickTimeout = setTimeout(function () {
          var DDM = Ext.dd.DDM;
          DDM.startDrag(DDM.startX, DDM.startY);
        }, this.clickTimeThresh);
      },

      /**
       * Fired when either the drag pixel threshol or the mousedown hold
       * time threshold has been met.
       * @method startDrag
       * @param x {int} the X position of the original mousedown
       * @param y {int} the Y position of the original mousedown
       * @static
       */
      startDrag: function (x, y) {
        clearTimeout(this.clickTimeout);
        if (this.dragCurrent) {
          this.dragCurrent.b4StartDrag(x, y);
          this.dragCurrent.startDrag(x, y);
        }
        this.dragThreshMet = true;
      },

      /**
       * Internal function to handle the mouseup event.  Will be invoked
       * from the context of the document.
       * @method handleMouseUp
       * @param {Event} e the event
       * @private
       * @static
       */
      handleMouseUp: function (e) {
        if (Ext.QuickTips) {
          Ext.QuickTips.enable();
        }
        if (!this.dragCurrent) {
          return;
        }

        clearTimeout(this.clickTimeout);

        if (this.dragThreshMet) {
          this.fireEvents(e, true);
        } else {
        }

        this.stopDrag(e);

        this.stopEvent(e);
      },

      /**
       * Utility to stop event propagation and event default, if these
       * features are turned on.
       * @method stopEvent
       * @param {Event} e the event as returned by this.getEvent()
       * @static
       */
      stopEvent: function (e) {
        if (this.stopPropagation) {
          e.stopPropagation();
        }

        if (this.preventDefault) {
          e.preventDefault();
        }
      },

      /**
       * Internal function to clean up event handlers after the drag
       * operation is complete
       * @method stopDrag
       * @param {Event} e the event
       * @private
       * @static
       */
      stopDrag: function (e) {
        // Fire the drag end event for the item that was dragged
        if (this.dragCurrent) {
          if (this.dragThreshMet) {
            this.dragCurrent.b4EndDrag(e);
            this.dragCurrent.endDrag(e);
          }

          this.dragCurrent.onMouseUp(e);
        }

        this.dragCurrent = null;
        this.dragOvers = {};
      },

      /**
       * Internal function to handle the mousemove event.  Will be invoked
       * from the context of the html element.
       *
       * @TODO figure out what we can do about mouse events lost when the
       * user drags objects beyond the window boundary.  Currently we can
       * detect this in internet explorer by verifying that the mouse is
       * down during the mousemove event.  Firefox doesn't give us the
       * button state on the mousemove event.
       * @method handleMouseMove
       * @param {Event} e the event
       * @private
       * @static
       */
      handleMouseMove: function (e) {
        if (!this.dragCurrent) {
          return true;
        }

        // var button = e.which || e.button;

        // check for IE mouseup outside of page boundary
        if (Ext.isIE && e.button !== 0 && e.button !== 1 && e.button !== 2) {
          this.stopEvent(e);
          return this.handleMouseUp(e);
        }

        if (!this.dragThreshMet) {
          var diffX = Math.abs(this.startX - e.getPageX());
          var diffY = Math.abs(this.startY - e.getPageY());
          if (diffX > this.clickPixelThresh || diffY > this.clickPixelThresh) {
            this.startDrag(this.startX, this.startY);
          }
        }

        if (this.dragThreshMet) {
          this.dragCurrent.b4Drag(e);
          this.dragCurrent.onDrag(e);
          if (!this.dragCurrent.moveOnly) {
            this.fireEvents(e, false);
          }
        }

        this.stopEvent(e);

        return true;
      },

      /**
       * Iterates over all of the DragDrop elements to find ones we are
       * hovering over or dropping on
       * @method fireEvents
       * @param {Event} e the event
       * @param {boolean} isDrop is this a drop op or a mouseover op?
       * @private
       * @static
       */
      fireEvents: function (e, isDrop) {
        var dc = this.dragCurrent;

        // If the user did the mouse up outside of the window, we could
        // get here even though we have ended the drag.
        if (!dc || dc.isLocked()) {
          return;
        }

        var pt = e.getPoint();

        // cache the previous dragOver array
        var oldOvers = [];

        var outEvts = [];
        var overEvts = [];
        var dropEvts = [];
        var enterEvts = [];

        // Check to see if the object(s) we were hovering over is no longer
        // being hovered over so we can fire the onDragOut event
        for (var i in this.dragOvers) {
          var ddo = this.dragOvers[i];

          if (!this.isTypeOfDD(ddo)) {
            continue;
          }

          if (!this.isOverTarget(pt, ddo, this.mode)) {
            outEvts.push(ddo);
          }

          oldOvers[i] = true;
          delete this.dragOvers[i];
        }

        for (var sGroup in dc.groups) {
          if ('string' != typeof sGroup) {
            continue;
          }

          for (i in this.ids[sGroup]) {
            var oDD = this.ids[sGroup][i];
            if (!this.isTypeOfDD(oDD)) {
              continue;
            }

            if (oDD.isTarget && !oDD.isLocked() && oDD != dc) {
              if (this.isOverTarget(pt, oDD, this.mode)) {
                // look for drop interactions
                if (isDrop) {
                  dropEvts.push(oDD);
                  // look for drag enter and drag over interactions
                } else {
                  // initial drag over: dragEnter fires
                  if (!oldOvers[oDD.id]) {
                    enterEvts.push(oDD);
                    // subsequent drag overs: dragOver fires
                  } else {
                    overEvts.push(oDD);
                  }

                  this.dragOvers[oDD.id] = oDD;
                }
              }
            }
          }
        }

        if (this.mode) {
          if (outEvts.length) {
            dc.b4DragOut(e, outEvts);
            dc.onDragOut(e, outEvts);
          }

          if (enterEvts.length) {
            dc.onDragEnter(e, enterEvts);
          }

          if (overEvts.length) {
            dc.b4DragOver(e, overEvts);
            dc.onDragOver(e, overEvts);
          }

          if (dropEvts.length) {
            dc.b4DragDrop(e, dropEvts);
            dc.onDragDrop(e, dropEvts);
          }
        } else {
          // fire dragout events
          var len = 0;
          for (i = 0, len = outEvts.length; i < len; ++i) {
            dc.b4DragOut(e, outEvts[i].id);
            dc.onDragOut(e, outEvts[i].id);
          }

          // fire enter events
          for (i = 0, len = enterEvts.length; i < len; ++i) {
            // dc.b4DragEnter(e, oDD.id);
            dc.onDragEnter(e, enterEvts[i].id);
          }

          // fire over events
          for (i = 0, len = overEvts.length; i < len; ++i) {
            dc.b4DragOver(e, overEvts[i].id);
            dc.onDragOver(e, overEvts[i].id);
          }

          // fire drop events
          for (i = 0, len = dropEvts.length; i < len; ++i) {
            dc.b4DragDrop(e, dropEvts[i].id);
            dc.onDragDrop(e, dropEvts[i].id);
          }
        }

        // notify about a drop that did not find a target
        if (isDrop && !dropEvts.length) {
          dc.onInvalidDrop(e);
        }
      },

      /**
       * Helper function for getting the best match from the list of drag
       * and drop objects returned by the drag and drop events when we are
       * in INTERSECT mode.  It returns either the first object that the
       * cursor is over, or the object that has the greatest overlap with
       * the dragged element.
       * @method getBestMatch
       * @param  {DragDrop[]} dds The array of drag and drop objects
       * targeted
       * @return {DragDrop}       The best single match
       * @static
       */
      getBestMatch: function (dds) {
        var winner = null;
        // Return null if the input is not what we expect
        //if (!dds || !dds.length || dds.length == 0) {
        // winner = null;
        // If there is only one item, it wins
        //} else if (dds.length == 1) {

        var len = dds.length;

        if (len == 1) {
          winner = dds[0];
        } else {
          // Loop through the targeted items
          for (var i = 0; i < len; ++i) {
            var dd = dds[i];
            // If the cursor is over the object, it wins.  If the
            // cursor is over multiple matches, the first one we come
            // to wins.
            if (dd.cursorIsOver) {
              winner = dd;
              break;
              // Otherwise the object with the most overlap wins
            } else {
              if (!winner || winner.overlap.getArea() < dd.overlap.getArea()) {
                winner = dd;
              }
            }
          }
        }

        return winner;
      },

      /**
       * Refreshes the cache of the top-left and bottom-right points of the
       * drag and drop objects in the specified group(s).  This is in the
       * format that is stored in the drag and drop instance, so typical
       * usage is:
       * <code>
       * Ext.dd.DragDropMgr.refreshCache(ddinstance.groups);
       * </code>
       * Alternatively:
       * <code>
       * Ext.dd.DragDropMgr.refreshCache({group1:true, group2:true});
       * </code>
       * @TODO this really should be an indexed array.  Alternatively this
       * method could accept both.
       * @method refreshCache
       * @param {Object} groups an associative array of groups to refresh
       * @static
       */
      refreshCache: function (groups) {
        for (var sGroup in groups) {
          if ('string' != typeof sGroup) {
            continue;
          }
          for (var i in this.ids[sGroup]) {
            var oDD = this.ids[sGroup][i];

            if (this.isTypeOfDD(oDD)) {
              // if (this.isTypeOfDD(oDD) && oDD.isTarget) {
              var loc = this.getLocation(oDD);
              if (loc) {
                this.locationCache[oDD.id] = loc;
              } else {
                delete this.locationCache[oDD.id];
                // this will unregister the drag and drop object if
                // the element is not in a usable state
                // oDD.unreg();
              }
            }
          }
        }
      },

      /**
       * This checks to make sure an element exists and is in the DOM.  The
       * main purpose is to handle cases where innerHTML is used to remove
       * drag and drop objects from the DOM.  IE provides an 'unspecified
       * error' when trying to access the offsetParent of such an element
       * @method verifyEl
       * @param {HTMLElement} el the element to check
       * @return {boolean} true if the element looks usable
       * @static
       */
      verifyEl: function (el) {
        if (el) {
          var parent;
          if (Ext.isIE) {
            try {
              parent = el.offsetParent;
            } catch (e) {}
          } else {
            parent = el.offsetParent;
          }
          if (parent) {
            return true;
          }
        }

        return false;
      },

      /**
       * Returns a Region object containing the drag and drop element's position
       * and size, including the padding configured for it
       * @method getLocation
       * @param {DragDrop} oDD the drag and drop object to get the
       *                       location for
       * @return {Ext.lib.Region} a Region object representing the total area
       *                             the element occupies, including any padding
       *                             the instance is configured for.
       * @static
       */
      getLocation: function (oDD) {
        if (!this.isTypeOfDD(oDD)) {
          return null;
        }

        var el = oDD.getEl(),
          pos,
          x1,
          x2,
          y1,
          y2,
          t,
          r,
          b,
          l;

        try {
          pos = Ext.lib.Dom.getXY(el);
        } catch (e) {}

        if (!pos) {
          return null;
        }

        x1 = pos[0];
        x2 = x1 + el.offsetWidth;
        y1 = pos[1];
        y2 = y1 + el.offsetHeight;

        t = y1 - oDD.padding[0];
        r = x2 + oDD.padding[1];
        b = y2 + oDD.padding[2];
        l = x1 - oDD.padding[3];

        return new Ext.lib.Region(t, r, b, l);
      },

      /**
       * Checks the cursor location to see if it over the target
       * @method isOverTarget
       * @param {Ext.lib.Point} pt The point to evaluate
       * @param {DragDrop} oTarget the DragDrop object we are inspecting
       * @return {boolean} true if the mouse is over the target
       * @private
       * @static
       */
      isOverTarget: function (pt, oTarget, intersect) {
        // use cache if available
        var loc = this.locationCache[oTarget.id];
        if (!loc || !this.useCache) {
          loc = this.getLocation(oTarget);
          this.locationCache[oTarget.id] = loc;
        }

        if (!loc) {
          return false;
        }

        oTarget.cursorIsOver = loc.contains(pt);

        // DragDrop is using this as a sanity check for the initial mousedown
        // in this case we are done.  In POINT mode, if the drag obj has no
        // contraints, we are also done. Otherwise we need to evaluate the
        // location of the target as related to the actual location of the
        // dragged element.
        var dc = this.dragCurrent;
        if (
          !dc ||
          !dc.getTargetCoord ||
          (!intersect && !dc.constrainX && !dc.constrainY)
        ) {
          return oTarget.cursorIsOver;
        }

        oTarget.overlap = null;

        // Get the current location of the drag element, this is the
        // location of the mouse event less the delta that represents
        // where the original mousedown happened on the element.  We
        // need to consider constraints and ticks as well.
        var pos = dc.getTargetCoord(pt.x, pt.y);

        var el = dc.getDragEl();
        var curRegion = new Ext.lib.Region(
          pos.y,
          pos.x + el.offsetWidth,
          pos.y + el.offsetHeight,
          pos.x,
        );

        var overlap = curRegion.intersect(loc);

        if (overlap) {
          oTarget.overlap = overlap;
          return intersect ? true : oTarget.cursorIsOver;
        } else {
          return false;
        }
      },

      /**
       * unload event handler
       * @method _onUnload
       * @private
       * @static
       */
      _onUnload: function (e, me) {
        Ext.dd.DragDropMgr.unregAll();
      },

      /**
       * Cleans up the drag and drop events and objects.
       * @method unregAll
       * @private
       * @static
       */
      unregAll: function () {
        if (this.dragCurrent) {
          this.stopDrag();
          this.dragCurrent = null;
        }

        this._execOnAll('unreg', []);

        for (var i in this.elementCache) {
          delete this.elementCache[i];
        }

        this.elementCache = {};
        this.ids = {};
      },

      /**
       * A cache of DOM elements
       * @property elementCache
       * @private
       * @static
       */
      elementCache: {},

      /**
       * Get the wrapper for the DOM element specified
       * @method getElWrapper
       * @param {String} id the id of the element to get
       * @return {Ext.dd.DDM.ElementWrapper} the wrapped element
       * @private
       * @deprecated This wrapper isn't that useful
       * @static
       */
      getElWrapper: function (id) {
        var oWrapper = this.elementCache[id];
        if (!oWrapper || !oWrapper.el) {
          oWrapper = this.elementCache[id] = new this.ElementWrapper(
            Ext.getDom(id),
          );
        }
        return oWrapper;
      },

      /**
       * Returns the actual DOM element
       * @method getElement
       * @param {String} id the id of the elment to get
       * @return {Object} The element
       * @deprecated use Ext.lib.Ext.getDom instead
       * @static
       */
      getElement: function (id) {
        return Ext.getDom(id);
      },

      /**
       * Returns the style property for the DOM element (i.e.,
       * document.getElById(id).style)
       * @method getCss
       * @param {String} id the id of the elment to get
       * @return {Object} The style property of the element
       * @deprecated use Ext.lib.Dom instead
       * @static
       */
      getCss: function (id) {
        var el = Ext.getDom(id);
        return el ? el.style : null;
      },

      /**
       * Inner class for cached elements
       * @class DragDropMgr.ElementWrapper
       * @for DragDropMgr
       * @private
       * @deprecated
       */
      ElementWrapper: function (el) {
        /**
         * The element
         * @property el
         */
        this.el = el || null;
        /**
         * The element id
         * @property id
         */
        this.id = this.el && el.id;
        /**
         * A reference to the style property
         * @property css
         */
        this.css = this.el && el.style;
      },

      /**
       * Returns the X position of an html element
       * @method getPosX
       * @param el the element for which to get the position
       * @return {int} the X coordinate
       * @for DragDropMgr
       * @deprecated use Ext.lib.Dom.getX instead
       * @static
       */
      getPosX: function (el) {
        return Ext.lib.Dom.getX(el);
      },

      /**
       * Returns the Y position of an html element
       * @method getPosY
       * @param el the element for which to get the position
       * @return {int} the Y coordinate
       * @deprecated use Ext.lib.Dom.getY instead
       * @static
       */
      getPosY: function (el) {
        return Ext.lib.Dom.getY(el);
      },

      /**
       * Swap two nodes.  In IE, we use the native method, for others we
       * emulate the IE behavior
       * @method swapNode
       * @param n1 the first node to swap
       * @param n2 the other node to swap
       * @static
       */
      swapNode: function (n1, n2) {
        if (n1.swapNode) {
          n1.swapNode(n2);
        } else {
          var p = n2.parentNode;
          var s = n2.nextSibling;

          if (s == n1) {
            p.insertBefore(n1, n2);
          } else if (n2 == n1.nextSibling) {
            p.insertBefore(n2, n1);
          } else {
            n1.parentNode.replaceChild(n2, n1);
            p.insertBefore(n1, s);
          }
        }
      },

      /**
       * Returns the current scroll position
       * @method getScroll
       * @private
       * @static
       */
      getScroll: function () {
        var t,
          l,
          dde = document.documentElement,
          db = document.body;
        if (dde && (dde.scrollTop || dde.scrollLeft)) {
          t = dde.scrollTop;
          l = dde.scrollLeft;
        } else if (db) {
          t = db.scrollTop;
          l = db.scrollLeft;
        } else {
        }
        return { top: t, left: l };
      },

      /**
       * Returns the specified element style property
       * @method getStyle
       * @param {HTMLElement} el          the element
       * @param {string}      styleProp   the style property
       * @return {string} The value of the style property
       * @deprecated use Ext.lib.Dom.getStyle
       * @static
       */
      getStyle: function (el, styleProp) {
        return Ext.fly(el).getStyle(styleProp);
      },

      /**
       * Gets the scrollTop
       * @method getScrollTop
       * @return {int} the document's scrollTop
       * @static
       */
      getScrollTop: function () {
        return this.getScroll().top;
      },

      /**
       * Gets the scrollLeft
       * @method getScrollLeft
       * @return {int} the document's scrollTop
       * @static
       */
      getScrollLeft: function () {
        return this.getScroll().left;
      },

      /**
       * Sets the x/y position of an element to the location of the
       * target element.
       * @method moveToEl
       * @param {HTMLElement} moveEl      The element to move
       * @param {HTMLElement} targetEl    The position reference element
       * @static
       */
      moveToEl: function (moveEl, targetEl) {
        var aCoord = Ext.lib.Dom.getXY(targetEl);
        Ext.lib.Dom.setXY(moveEl, aCoord);
      },

      /**
       * Numeric array sort function
       * @method numericSort
       * @static
       */
      numericSort: function (a, b) {
        return a - b;
      },

      /**
       * Internal counter
       * @property _timeoutCount
       * @private
       * @static
       */
      _timeoutCount: 0,

      /**
       * Trying to make the load order less important.  Without this we get
       * an error if this file is loaded before the Event Utility.
       * @method _addListeners
       * @private
       * @static
       */
      _addListeners: function () {
        var DDM = Ext.dd.DDM;
        if (Ext.lib.Event && document) {
          DDM._onLoad();
        } else {
          if (DDM._timeoutCount > 2000) {
          } else {
            setTimeout(DDM._addListeners, 10);
            if (document && document.body) {
              DDM._timeoutCount += 1;
            }
          }
        }
      },

      /**
       * Recursively searches the immediate parent and all child nodes for
       * the handle element in order to determine wheter or not it was
       * clicked.
       * @method handleWasClicked
       * @param node the html element to inspect
       * @static
       */
      handleWasClicked: function (node, id) {
        if (this.isHandle(id, node.id)) {
          return true;
        } else {
          // check to see if this is a text node child of the one we want
          var p = node.parentNode;

          while (p) {
            if (this.isHandle(id, p.id)) {
              return true;
            } else {
              p = p.parentNode;
            }
          }
        }

        return false;
      },
    };
  })();

  // shorter alias, save a few bytes
  Ext.dd.DDM = Ext.dd.DragDropMgr;
  Ext.dd.DDM._addListeners();
}

/**
 * @class Ext.dd.DD
 * A DragDrop implementation where the linked element follows the
 * mouse cursor during a drag.
 * @extends Ext.dd.DragDrop
 * @constructor
 * @param {String} id the id of the linked element
 * @param {String} sGroup the group of related DragDrop items
 * @param {object} config an object containing configurable attributes
 *                Valid properties for DD:
 *                    scroll
 */
Ext.dd.DD = function (id, sGroup, config) {
  if (id) {
    this.init(id, sGroup, config);
  }
};

Ext.extend(Ext.dd.DD, Ext.dd.DragDrop, {
  /**
   * When set to true, the utility automatically tries to scroll the browser
   * window when a drag and drop element is dragged near the viewport boundary.
   * Defaults to true.
   * @property scroll
   * @type boolean
   */
  scroll: true,

  /**
   * Sets the pointer offset to the distance between the linked element's top
   * left corner and the location the element was clicked
   * @method autoOffset
   * @param {int} iPageX the X coordinate of the click
   * @param {int} iPageY the Y coordinate of the click
   */
  autoOffset: function (iPageX, iPageY) {
    var x = iPageX - this.startPageX;
    var y = iPageY - this.startPageY;
    this.setDelta(x, y);
  },

  /**
   * Sets the pointer offset.  You can call this directly to force the
   * offset to be in a particular location (e.g., pass in 0,0 to set it
   * to the center of the object)
   * @method setDelta
   * @param {int} iDeltaX the distance from the left
   * @param {int} iDeltaY the distance from the top
   */
  setDelta: function (iDeltaX, iDeltaY) {
    this.deltaX = iDeltaX;
    this.deltaY = iDeltaY;
  },

  /**
   * Sets the drag element to the location of the mousedown or click event,
   * maintaining the cursor location relative to the location on the element
   * that was clicked.  Override this if you want to place the element in a
   * location other than where the cursor is.
   * @method setDragElPos
   * @param {int} iPageX the X coordinate of the mousedown or drag event
   * @param {int} iPageY the Y coordinate of the mousedown or drag event
   */
  setDragElPos: function (iPageX, iPageY) {
    // the first time we do this, we are going to check to make sure
    // the element has css positioning

    var el = this.getDragEl();
    this.alignElWithMouse(el, iPageX, iPageY);
  },

  /**
   * Sets the element to the location of the mousedown or click event,
   * maintaining the cursor location relative to the location on the element
   * that was clicked.  Override this if you want to place the element in a
   * location other than where the cursor is.
   * @method alignElWithMouse
   * @param {HTMLElement} el the element to move
   * @param {int} iPageX the X coordinate of the mousedown or drag event
   * @param {int} iPageY the Y coordinate of the mousedown or drag event
   */
  alignElWithMouse: function (el, iPageX, iPageY) {
    var oCoord = this.getTargetCoord(iPageX, iPageY);
    var fly = el.dom ? el : Ext.fly(el, '_dd');
    if (!this.deltaSetXY) {
      var aCoord = [oCoord.x, oCoord.y];
      fly.setXY(aCoord);
      var newLeft = fly.getLeft(true);
      var newTop = fly.getTop(true);
      this.deltaSetXY = [newLeft - oCoord.x, newTop - oCoord.y];
    } else {
      fly.setLeftTop(
        oCoord.x + this.deltaSetXY[0],
        oCoord.y + this.deltaSetXY[1],
      );
    }

    this.cachePosition(oCoord.x, oCoord.y);
    this.autoScroll(oCoord.x, oCoord.y, el.offsetHeight, el.offsetWidth);
    return oCoord;
  },

  /**
   * Saves the most recent position so that we can reset the constraints and
   * tick marks on-demand.  We need to know this so that we can calculate the
   * number of pixels the element is offset from its original position.
   * @method cachePosition
   * @param iPageX the current x position (optional, this just makes it so we
   * don't have to look it up again)
   * @param iPageY the current y position (optional, this just makes it so we
   * don't have to look it up again)
   */
  cachePosition: function (iPageX, iPageY) {
    if (iPageX) {
      this.lastPageX = iPageX;
      this.lastPageY = iPageY;
    } else {
      var aCoord = Ext.lib.Dom.getXY(this.getEl());
      this.lastPageX = aCoord[0];
      this.lastPageY = aCoord[1];
    }
  },

  /**
   * Auto-scroll the window if the dragged object has been moved beyond the
   * visible window boundary.
   * @method autoScroll
   * @param {int} x the drag element's x position
   * @param {int} y the drag element's y position
   * @param {int} h the height of the drag element
   * @param {int} w the width of the drag element
   * @private
   */
  autoScroll: function (x, y, h, w) {
    if (this.scroll) {
      // The client height
      var clientH = Ext.lib.Dom.getViewHeight();

      // The client width
      var clientW = Ext.lib.Dom.getViewWidth();

      // The amt scrolled down
      var st = this.DDM.getScrollTop();

      // The amt scrolled right
      var sl = this.DDM.getScrollLeft();

      // Location of the bottom of the element
      var bot = h + y;

      // Location of the right of the element
      var right = w + x;

      // The distance from the cursor to the bottom of the visible area,
      // adjusted so that we don't scroll if the cursor is beyond the
      // element drag constraints
      var toBot = clientH + st - y - this.deltaY;

      // The distance from the cursor to the right of the visible area
      var toRight = clientW + sl - x - this.deltaX;

      // How close to the edge the cursor must be before we scroll
      // var thresh = (document.all) ? 100 : 40;
      var thresh = 40;

      // How many pixels to scroll per autoscroll op.  This helps to reduce
      // clunky scrolling. IE is more sensitive about this ... it needs this
      // value to be higher.
      var scrAmt = document.all ? 80 : 30;

      // Scroll down if we are near the bottom of the visible page and the
      // obj extends below the crease
      if (bot > clientH && toBot < thresh) {
        window.scrollTo(sl, st + scrAmt);
      }

      // Scroll up if the window is scrolled down and the top of the object
      // goes above the top border
      if (y < st && st > 0 && y - st < thresh) {
        window.scrollTo(sl, st - scrAmt);
      }

      // Scroll right if the obj is beyond the right border and the cursor is
      // near the border.
      if (right > clientW && toRight < thresh) {
        window.scrollTo(sl + scrAmt, st);
      }

      // Scroll left if the window has been scrolled to the right and the obj
      // extends past the left border
      if (x < sl && sl > 0 && x - sl < thresh) {
        window.scrollTo(sl - scrAmt, st);
      }
    }
  },

  /**
   * Finds the location the element should be placed if we want to move
   * it to where the mouse location less the click offset would place us.
   * @method getTargetCoord
   * @param {int} iPageX the X coordinate of the click
   * @param {int} iPageY the Y coordinate of the click
   * @return an object that contains the coordinates (Object.x and Object.y)
   * @private
   */
  getTargetCoord: function (iPageX, iPageY) {
    var x = iPageX - this.deltaX;
    var y = iPageY - this.deltaY;

    if (this.constrainX) {
      if (x < this.minX) {
        x = this.minX;
      }
      if (x > this.maxX) {
        x = this.maxX;
      }
    }

    if (this.constrainY) {
      if (y < this.minY) {
        y = this.minY;
      }
      if (y > this.maxY) {
        y = this.maxY;
      }
    }

    x = this.getTick(x, this.xTicks);
    y = this.getTick(y, this.yTicks);

    return { x: x, y: y };
  },

  /**
   * Sets up config options specific to this class. Overrides
   * Ext.dd.DragDrop, but all versions of this method through the
   * inheritance chain are called
   */
  applyConfig: function () {
    Ext.dd.DD.superclass.applyConfig.call(this);
    this.scroll = this.config.scroll !== false;
  },

  /**
   * Event that fires prior to the onMouseDown event.  Overrides
   * Ext.dd.DragDrop.
   */
  b4MouseDown: function (e) {
    // this.resetConstraints();
    this.autoOffset(e.getPageX(), e.getPageY());
  },

  /**
   * Event that fires prior to the onDrag event.  Overrides
   * Ext.dd.DragDrop.
   */
  b4Drag: function (e) {
    this.setDragElPos(e.getPageX(), e.getPageY());
  },

  toString: function () {
    return 'DD ' + this.id;
  },

  //////////////////////////////////////////////////////////////////////////
  // Debugging ygDragDrop events that can be overridden
  //////////////////////////////////////////////////////////////////////////
  /*
    startDrag: function(x, y) {
    },

    onDrag: function(e) {
    },

    onDragEnter: function(e, id) {
    },

    onDragOver: function(e, id) {
    },

    onDragOut: function(e, id) {
    },

    onDragDrop: function(e, id) {
    },

    endDrag: function(e) {
    }

    */
});
/**
 * @class Ext.dd.DDProxy
 * A DragDrop implementation that inserts an empty, bordered div into
 * the document that follows the cursor during drag operations.  At the time of
 * the click, the frame div is resized to the dimensions of the linked html
 * element, and moved to the exact location of the linked element.
 *
 * References to the "frame" element refer to the single proxy element that
 * was created to be dragged in place of all DDProxy elements on the
 * page.
 *
 * @extends Ext.dd.DD
 * @constructor
 * @param {String} id the id of the linked html element
 * @param {String} sGroup the group of related DragDrop objects
 * @param {object} config an object containing configurable attributes
 *                Valid properties for DDProxy in addition to those in DragDrop:
 *                   resizeFrame, centerFrame, dragElId
 */
Ext.dd.DDProxy = function (id, sGroup, config) {
  if (id) {
    this.init(id, sGroup, config);
    this.initFrame();
  }
};

/**
 * The default drag frame div id
 * @property Ext.dd.DDProxy.dragElId
 * @type String
 * @static
 */
Ext.dd.DDProxy.dragElId = 'ygddfdiv';

Ext.extend(Ext.dd.DDProxy, Ext.dd.DD, {
  /**
   * By default we resize the drag frame to be the same size as the element
   * we want to drag (this is to get the frame effect).  We can turn it off
   * if we want a different behavior.
   * @property resizeFrame
   * @type boolean
   */
  resizeFrame: true,

  /**
   * By default the frame is positioned exactly where the drag element is, so
   * we use the cursor offset provided by Ext.dd.DD.  Another option that works only if
   * you do not have constraints on the obj is to have the drag frame centered
   * around the cursor.  Set centerFrame to true for this effect.
   * @property centerFrame
   * @type boolean
   */
  centerFrame: false,

  /**
   * Creates the proxy element if it does not yet exist
   * @method createFrame
   */
  createFrame: function () {
    var self = this;
    var body = document.body;

    if (!body || !body.firstChild) {
      setTimeout(function () {
        self.createFrame();
      }, 50);
      return;
    }

    var div = this.getDragEl();

    if (!div) {
      div = document.createElement('div');
      div.id = this.dragElId;
      var s = div.style;

      s.position = 'absolute';
      s.visibility = 'hidden';
      s.cursor = 'move';
      s.border = '2px solid #aaa';
      s.zIndex = 999;

      // appendChild can blow up IE if invoked prior to the window load event
      // while rendering a table.  It is possible there are other scenarios
      // that would cause this to happen as well.
      body.insertBefore(div, body.firstChild);
    }
  },

  /**
   * Initialization for the drag frame element.  Must be called in the
   * constructor of all subclasses
   * @method initFrame
   */
  initFrame: function () {
    this.createFrame();
  },

  applyConfig: function () {
    Ext.dd.DDProxy.superclass.applyConfig.call(this);

    this.resizeFrame = this.config.resizeFrame !== false;
    this.centerFrame = this.config.centerFrame;
    this.setDragElId(this.config.dragElId || Ext.dd.DDProxy.dragElId);
  },

  /**
   * Resizes the drag frame to the dimensions of the clicked object, positions
   * it over the object, and finally displays it
   * @method showFrame
   * @param {int} iPageX X click position
   * @param {int} iPageY Y click position
   * @private
   */
  showFrame: function (iPageX, iPageY) {
    var el = this.getEl();
    var dragEl = this.getDragEl();
    var s = dragEl.style;

    this._resizeProxy();

    if (this.centerFrame) {
      this.setDelta(
        Math.round(parseInt(s.width, 10) / 2),
        Math.round(parseInt(s.height, 10) / 2),
      );
    }

    this.setDragElPos(iPageX, iPageY);

    Ext.fly(dragEl).show();
  },

  /**
   * The proxy is automatically resized to the dimensions of the linked
   * element when a drag is initiated, unless resizeFrame is set to false
   * @method _resizeProxy
   * @private
   */
  _resizeProxy: function () {
    if (this.resizeFrame) {
      var el = this.getEl();
      Ext.fly(this.getDragEl()).setSize(el.offsetWidth, el.offsetHeight);
    }
  },

  // overrides Ext.dd.DragDrop
  b4MouseDown: function (e) {
    var x = e.getPageX();
    var y = e.getPageY();
    this.autoOffset(x, y);
    this.setDragElPos(x, y);
  },

  // overrides Ext.dd.DragDrop
  b4StartDrag: function (x, y) {
    // show the drag frame
    this.showFrame(x, y);
  },

  // overrides Ext.dd.DragDrop
  b4EndDrag: function (e) {
    Ext.fly(this.getDragEl()).hide();
  },

  // overrides Ext.dd.DragDrop
  // By default we try to move the element to the last location of the frame.
  // This is so that the default behavior mirrors that of Ext.dd.DD.
  endDrag: function (e) {
    var lel = this.getEl();
    var del = this.getDragEl();

    // Show the drag frame briefly so we can get its position
    del.style.visibility = '';

    this.beforeMove();
    // Hide the linked element before the move to get around a Safari
    // rendering bug.
    lel.style.visibility = 'hidden';
    Ext.dd.DDM.moveToEl(lel, del);
    del.style.visibility = 'hidden';
    lel.style.visibility = '';

    this.afterDrag();
  },

  beforeMove: function () {},

  afterDrag: function () {},

  toString: function () {
    return 'DDProxy ' + this.id;
  },
});
/**
 * @class Ext.dd.DDTarget
 * A DragDrop implementation that does not move, but can be a drop
 * target.  You would get the same result by simply omitting implementation
 * for the event callbacks, but this way we reduce the processing cost of the
 * event listener and the callbacks.
 * @extends Ext.dd.DragDrop
 * @constructor
 * @param {String} id the id of the element that is a drop target
 * @param {String} sGroup the group of related DragDrop objects
 * @param {object} config an object containing configurable attributes
 *                 Valid properties for DDTarget in addition to those in
 *                 DragDrop:
 *                    none
 */
Ext.dd.DDTarget = function (id, sGroup, config) {
  if (id) {
    this.initTarget(id, sGroup, config);
  }
};

// Ext.dd.DDTarget.prototype = new Ext.dd.DragDrop();
Ext.extend(Ext.dd.DDTarget, Ext.dd.DragDrop, {
  toString: function () {
    return 'DDTarget ' + this.id;
  },
});
/*
 * Ext JS Library 2.3.0
 * Copyright(c) 2006-2009, Ext JS, LLC.
 * licensing@extjs.com
 *
 * http://extjs.com/license
 */

/**
 * @class Ext.Resizable
 * @extends Ext.util.Observable
 * <p>Applies drag handles to an element to make it resizable. The drag handles are inserted into the element 
 * and positioned absolute. Some elements, such as a textarea or image, don't support this. To overcome that, you can wrap
 * the textarea in a div and set "resizeChild" to true (or to the id of the element), <b>or</b> set wrap:true in your config and
 * the element will be wrapped for you automatically.</p>
 * <p>Here is the list of valid resize handles:</p>
 * <pre>
Value   Description
------  -------------------
 'n'     north
 's'     south
 'e'     east
 'w'     west
 'nw'    northwest
 'sw'    southwest
 'se'    southeast
 'ne'    northeast
 'all'   all
</pre>
 * <p>Here's an example showing the creation of a typical Resizable:</p>
 * <pre><code>
var resizer = new Ext.Resizable("element-id", {
    handles: 'all',
    minWidth: 200,
    minHeight: 100,
    maxWidth: 500,
    maxHeight: 400,
    pinned: true
});
resizer.on("resize", myHandler);
</code></pre>
 * <p>To hide a particular handle, set its display to none in CSS, or through script:<br>
 * resizer.east.setDisplayed(false);</p>
 * @cfg {Boolean/String/Element} resizeChild True to resize the first child, or id/element to resize (defaults to false)
 * @cfg {Array/String} adjustments String "auto" or an array [width, height] with values to be <b>added</b> to the
 * resize operation's new size (defaults to [0, 0])
 * @cfg {Number} minWidth The minimum width for the element (defaults to 5)
 * @cfg {Number} minHeight The minimum height for the element (defaults to 5)
 * @cfg {Number} maxWidth The maximum width for the element (defaults to 10000)
 * @cfg {Number} maxHeight The maximum height for the element (defaults to 10000)
 * @cfg {Boolean} enabled False to disable resizing (defaults to true)
 * @cfg {Boolean} wrap True to wrap an element with a div if needed (required for textareas and images, defaults to false)
 * @cfg {Number} width The width of the element in pixels (defaults to null)
 * @cfg {Number} height The height of the element in pixels (defaults to null)
 * @cfg {Boolean} animate True to animate the resize (not compatible with dynamic sizing, defaults to false)
 * @cfg {Number} duration Animation duration if animate = true (defaults to .35)
 * @cfg {Boolean} dynamic True to resize the element while dragging instead of using a proxy (defaults to false)
 * @cfg {String} handles String consisting of the resize handles to display (defaults to undefined)
 * @cfg {Boolean} multiDirectional <b>Deprecated</b>.  The old style of adding multi-direction resize handles, deprecated
 * in favor of the handles config option (defaults to false)
 * @cfg {Boolean} disableTrackOver True to disable mouse tracking. This is only applied at config time. (defaults to false)
 * @cfg {String} easing Animation easing if animate = true (defaults to 'easingOutStrong')
 * @cfg {Number} widthIncrement The increment to snap the width resize in pixels (dynamic must be true, defaults to 0)
 * @cfg {Number} heightIncrement The increment to snap the height resize in pixels (dynamic must be true, defaults to 0)
 * @cfg {Boolean} pinned True to ensure that the resize handles are always visible, false to display them only when the
 * user mouses over the resizable borders. This is only applied at config time. (defaults to false)
 * @cfg {Boolean} preserveRatio True to preserve the original ratio between height and width during resize (defaults to false)
 * @cfg {Boolean} transparent True for transparent handles. This is only applied at config time. (defaults to false)
 * @cfg {Number} minX The minimum allowed page X for the element (only used for west resizing, defaults to 0)
 * @cfg {Number} minY The minimum allowed page Y for the element (only used for north resizing, defaults to 0)
 * @cfg {Boolean} draggable Convenience to initialize drag drop (defaults to false)
 * @constructor
 * Create a new resizable component
 * @param {Mixed} el The id or element to resize
 * @param {Object} config configuration options
  */
Ext.Resizable = function (el, config) {
  this.el = Ext.get(el);

  if (config && config.wrap) {
    config.resizeChild = this.el;
    this.el = this.el.wrap(
      typeof config.wrap == 'object' ? config.wrap : { cls: 'xresizable-wrap' },
    );
    this.el.id = this.el.dom.id = config.resizeChild.id + '-rzwrap';
    this.el.setStyle('overflow', 'hidden');
    this.el.setPositioning(config.resizeChild.getPositioning());
    config.resizeChild.clearPositioning();
    if (!config.width || !config.height) {
      var csize = config.resizeChild.getSize();
      this.el.setSize(csize.width, csize.height);
    }
    if (config.pinned && !config.adjustments) {
      config.adjustments = 'auto';
    }
  }

  /**
   * The proxy Element that is resized in place of the real Element during the resize operation.
   * This may be queried using {@link Ext.Element#getBox} to provide the new area to resize to.
   * Read only.
   * @type Ext.Element.
   * @property proxy
   */
  this.proxy = this.el.createProxy(
    { tag: 'div', cls: 'x-resizable-proxy', id: this.el.id + '-rzproxy' },
    Ext.getBody(),
  );
  this.proxy.unselectable();
  this.proxy.enableDisplayMode('block');

  Ext.apply(this, config);

  if (this.pinned) {
    this.disableTrackOver = true;
    this.el.addClass('x-resizable-pinned');
  }
  // if the element isn't positioned, make it relative
  var position = this.el.getStyle('position');
  if (position != 'absolute' && position != 'fixed') {
    this.el.setStyle('position', 'relative');
  }
  if (!this.handles) {
    // no handles passed, must be legacy style
    this.handles = 's,e,se';
    if (this.multiDirectional) {
      this.handles += ',n,w';
    }
  }
  if (this.handles == 'all') {
    this.handles = 'n s e w ne nw se sw';
  }
  var hs = this.handles.split(/\s*?[,;]\s*?| /);
  var ps = Ext.Resizable.positions;
  for (var i = 0, len = hs.length; i < len; i++) {
    if (hs[i] && ps[hs[i]]) {
      var pos = ps[hs[i]];
      this[pos] = new Ext.Resizable.Handle(
        this,
        pos,
        this.disableTrackOver,
        this.transparent,
      );
    }
  }
  // legacy
  this.corner = this.southeast;

  if (this.handles.indexOf('n') != -1 || this.handles.indexOf('w') != -1) {
    this.updateBox = true;
  }

  this.activeHandle = null;

  if (this.resizeChild) {
    if (typeof this.resizeChild == 'boolean') {
      this.resizeChild = Ext.get(this.el.dom.firstChild, true);
    } else {
      this.resizeChild = Ext.get(this.resizeChild, true);
    }
  }

  if (this.adjustments == 'auto') {
    var rc = this.resizeChild;
    var hw = this.west,
      he = this.east,
      hn = this.north,
      hs = this.south;
    if (rc && (hw || hn)) {
      rc.position('relative');
      rc.setLeft(hw ? hw.el.getWidth() : 0);
      rc.setTop(hn ? hn.el.getHeight() : 0);
    }
    this.adjustments = [
      (he ? -he.el.getWidth() : 0) + (hw ? -hw.el.getWidth() : 0),
      (hn ? -hn.el.getHeight() : 0) + (hs ? -hs.el.getHeight() : 0) - 1,
    ];
  }

  if (this.draggable) {
    this.dd = this.dynamic
      ? this.el.initDD(null)
      : this.el.initDDProxy(null, { dragElId: this.proxy.id });
    this.dd.setHandleElId(this.resizeChild ? this.resizeChild.id : this.el.id);
  }

  // public events
  this.addEvents('beforeresize', 'resize');

  if (this.width !== null && this.height !== null) {
    this.resizeTo(this.width, this.height);
  } else {
    this.updateChildSize();
  }
  if (Ext.isIE) {
    this.el.dom.style.zoom = 1;
  }
  Ext.Resizable.superclass.constructor.call(this);
};

Ext.extend(Ext.Resizable, Ext.util.Observable, {
  resizeChild: false,
  adjustments: [0, 0],
  minWidth: 5,
  minHeight: 5,
  maxWidth: 10000,
  maxHeight: 10000,
  enabled: true,
  animate: false,
  duration: 0.35,
  dynamic: false,
  handles: false,
  multiDirectional: false,
  disableTrackOver: false,
  easing: 'easeOutStrong',
  widthIncrement: 0,
  heightIncrement: 0,
  pinned: false,
  width: null,
  height: null,
  preserveRatio: false,
  transparent: false,
  minX: 0,
  minY: 0,
  draggable: false,

  /**
   * @cfg {Mixed} constrainTo Constrain the resize to a particular element
   */
  /**
   * @cfg {Ext.lib.Region} resizeRegion Constrain the resize to a particular region
   */

  /**
   * @event beforeresize
   * Fired before resize is allowed. Set enabled to false to cancel resize.
   * @param {Ext.Resizable} this
   * @param {Ext.EventObject} e The mousedown event
   */
  /**
   * @event resize
   * Fired after a resize.
   * @param {Ext.Resizable} this
   * @param {Number} width The new width
   * @param {Number} height The new height
   * @param {Ext.EventObject} e The mouseup event
   */

  /**
   * Perform a manual resize
   * @param {Number} width
   * @param {Number} height
   */
  resizeTo: function (width, height) {
    this.el.setSize(width, height);
    this.updateChildSize();
    this.fireEvent('resize', this, width, height, null);
  },

  // private
  startSizing: function (e, handle) {
    this.fireEvent('beforeresize', this, e);
    if (this.enabled) {
      // 2nd enabled check in case disabled before beforeresize handler

      if (!this.overlay) {
        this.overlay = this.el.createProxy(
          { tag: 'div', cls: 'x-resizable-overlay', html: '&#160;' },
          Ext.getBody(),
        );
        this.overlay.unselectable();
        this.overlay.enableDisplayMode('block');
        this.overlay.on('mousemove', this.onMouseMove, this);
        this.overlay.on('mouseup', this.onMouseUp, this);
      }
      this.overlay.setStyle('cursor', handle.el.getStyle('cursor'));

      this.resizing = true;
      this.startBox = this.el.getBox();
      this.startPoint = e.getXY();
      this.offsets = [
        this.startBox.x + this.startBox.width - this.startPoint[0],
        this.startBox.y + this.startBox.height - this.startPoint[1],
      ];

      this.overlay.setSize(
        Ext.lib.Dom.getViewWidth(true),
        Ext.lib.Dom.getViewHeight(true),
      );
      this.overlay.show();

      if (this.constrainTo) {
        var ct = Ext.get(this.constrainTo);
        this.resizeRegion = ct
          .getRegion()
          .adjust(
            ct.getFrameWidth('t'),
            ct.getFrameWidth('l'),
            -ct.getFrameWidth('b'),
            -ct.getFrameWidth('r'),
          );
      }

      this.proxy.setStyle('visibility', 'hidden'); // workaround display none
      this.proxy.show();
      this.proxy.setBox(this.startBox);
      if (!this.dynamic) {
        this.proxy.setStyle('visibility', 'visible');
      }
    }
  },

  // private
  onMouseDown: function (handle, e) {
    if (this.enabled) {
      e.stopEvent();
      this.activeHandle = handle;
      this.startSizing(e, handle);
    }
  },

  // private
  onMouseUp: function (e) {
    this.activeHandle = null;
    var size = this.resizeElement();
    this.resizing = false;
    this.handleOut();
    this.overlay.hide();
    this.proxy.hide();
    this.fireEvent('resize', this, size.width, size.height, e);
  },

  // private
  updateChildSize: function () {
    if (this.resizeChild) {
      var el = this.el;
      var child = this.resizeChild;
      var adj = this.adjustments;
      if (el.dom.offsetWidth) {
        var b = el.getSize(true);
        child.setSize(b.width + adj[0], b.height + adj[1]);
      }
      // Second call here for IE
      // The first call enables instant resizing and
      // the second call corrects scroll bars if they
      // exist
      if (Ext.isIE) {
        setTimeout(function () {
          if (el.dom.offsetWidth) {
            var b = el.getSize(true);
            child.setSize(b.width + adj[0], b.height + adj[1]);
          }
        }, 10);
      }
    }
  },

  // private
  snap: function (value, inc, min) {
    if (!inc || !value) return value;
    var newValue = value;
    var m = value % inc;
    if (m > 0) {
      if (m > inc / 2) {
        newValue = value + (inc - m);
      } else {
        newValue = value - m;
      }
    }
    return Math.max(min, newValue);
  },

  /**
     * <p>Performs resizing of the associated Element. This method is called internally by this
     * class, and should not be called by user code.</p>
     * <p>If a Resizable is being used to resize an Element which encapsulates a more complex UI
     * component such as a Panel, this method may be overridden by specifying an implementation
     * as a config option to provide appropriate behaviour at the end of the resize operation on
     * mouseup, for example resizing the Panel, and relaying the Panel's content.</p>
     * <p>The new area to be resized to is available by examining the state of the {@link #proxy}
     * Element. Example:
<pre><code>
new Ext.Panel({
    title: 'Resize me',
    x: 100,
    y: 100,
    renderTo: Ext.getBody(),
    floating: true,
    frame: true,
    width: 400,
    height: 200,
    listeners: {
        render: function(p) {
            new Ext.Resizable(p.getEl(), {
                handles: 'all',
                pinned: true,
                transparent: true,
                resizeElement: function() {
                    var box = this.proxy.getBox();
                    p.updateBox(box);
                    if (p.layout) {
                        p.doLayout();
                    }
                    return box;
                }
           });
       }
    }
}).show();
</code></pre>
     */
  resizeElement: function () {
    var box = this.proxy.getBox();
    if (this.updateBox) {
      this.el.setBox(
        box,
        false,
        this.animate,
        this.duration,
        null,
        this.easing,
      );
    } else {
      this.el.setSize(
        box.width,
        box.height,
        this.animate,
        this.duration,
        null,
        this.easing,
      );
    }
    this.updateChildSize();
    if (!this.dynamic) {
      this.proxy.hide();
    }
    return box;
  },

  // private
  constrain: function (v, diff, m, mx) {
    if (v - diff < m) {
      diff = v - m;
    } else if (v - diff > mx) {
      diff = v - mx;
    }
    return diff;
  },

  // private
  onMouseMove: function (e) {
    if (this.enabled && this.activeHandle) {
      try {
        // try catch so if something goes wrong the user doesn't get hung

        if (this.resizeRegion && !this.resizeRegion.contains(e.getPoint())) {
          return;
        }

        //var curXY = this.startPoint;
        var curSize = this.curSize || this.startBox;
        var x = this.startBox.x,
          y = this.startBox.y;
        var ox = x,
          oy = y;
        var w = curSize.width,
          h = curSize.height;
        var ow = w,
          oh = h;
        var mw = this.minWidth,
          mh = this.minHeight;
        var mxw = this.maxWidth,
          mxh = this.maxHeight;
        var wi = this.widthIncrement;
        var hi = this.heightIncrement;

        var eventXY = e.getXY();
        var diffX = -(this.startPoint[0] - Math.max(this.minX, eventXY[0]));
        var diffY = -(this.startPoint[1] - Math.max(this.minY, eventXY[1]));

        var pos = this.activeHandle.position;

        switch (pos) {
          case 'east':
            w += diffX;
            w = Math.min(Math.max(mw, w), mxw);
            break;
          case 'south':
            h += diffY;
            h = Math.min(Math.max(mh, h), mxh);
            break;
          case 'southeast':
            w += diffX;
            h += diffY;
            w = Math.min(Math.max(mw, w), mxw);
            h = Math.min(Math.max(mh, h), mxh);
            break;
          case 'north':
            diffY = this.constrain(h, diffY, mh, mxh);
            y += diffY;
            h -= diffY;
            break;
          case 'west':
            diffX = this.constrain(w, diffX, mw, mxw);
            x += diffX;
            w -= diffX;
            break;
          case 'northeast':
            w += diffX;
            w = Math.min(Math.max(mw, w), mxw);
            diffY = this.constrain(h, diffY, mh, mxh);
            y += diffY;
            h -= diffY;
            break;
          case 'northwest':
            diffX = this.constrain(w, diffX, mw, mxw);
            diffY = this.constrain(h, diffY, mh, mxh);
            y += diffY;
            h -= diffY;
            x += diffX;
            w -= diffX;
            break;
          case 'southwest':
            diffX = this.constrain(w, diffX, mw, mxw);
            h += diffY;
            h = Math.min(Math.max(mh, h), mxh);
            x += diffX;
            w -= diffX;
            break;
        }

        var sw = this.snap(w, wi, mw);
        var sh = this.snap(h, hi, mh);
        if (sw != w || sh != h) {
          switch (pos) {
            case 'northeast':
              y -= sh - h;
              break;
            case 'north':
              y -= sh - h;
              break;
            case 'southwest':
              x -= sw - w;
              break;
            case 'west':
              x -= sw - w;
              break;
            case 'northwest':
              x -= sw - w;
              y -= sh - h;
              break;
          }
          w = sw;
          h = sh;
        }

        if (this.preserveRatio) {
          switch (pos) {
            case 'southeast':
            case 'east':
              h = oh * (w / ow);
              h = Math.min(Math.max(mh, h), mxh);
              w = ow * (h / oh);
              break;
            case 'south':
              w = ow * (h / oh);
              w = Math.min(Math.max(mw, w), mxw);
              h = oh * (w / ow);
              break;
            case 'northeast':
              w = ow * (h / oh);
              w = Math.min(Math.max(mw, w), mxw);
              h = oh * (w / ow);
              break;
            case 'north':
              var tw = w;
              w = ow * (h / oh);
              w = Math.min(Math.max(mw, w), mxw);
              h = oh * (w / ow);
              x += (tw - w) / 2;
              break;
            case 'southwest':
              h = oh * (w / ow);
              h = Math.min(Math.max(mh, h), mxh);
              var tw = w;
              w = ow * (h / oh);
              x += tw - w;
              break;
            case 'west':
              var th = h;
              h = oh * (w / ow);
              h = Math.min(Math.max(mh, h), mxh);
              y += (th - h) / 2;
              var tw = w;
              w = ow * (h / oh);
              x += tw - w;
              break;
            case 'northwest':
              var tw = w;
              var th = h;
              h = oh * (w / ow);
              h = Math.min(Math.max(mh, h), mxh);
              w = ow * (h / oh);
              y += th - h;
              x += tw - w;
              break;
          }
        }
        this.proxy.setBounds(x, y, w, h);
        if (this.dynamic) {
          this.resizeElement();
        }
      } catch (e) {}
    }
  },

  // private
  handleOver: function () {
    if (this.enabled) {
      this.el.addClass('x-resizable-over');
    }
  },

  // private
  handleOut: function () {
    if (!this.resizing) {
      this.el.removeClass('x-resizable-over');
    }
  },

  /**
   * Returns the element this component is bound to.
   * @return {Ext.Element}
   */
  getEl: function () {
    return this.el;
  },

  /**
   * Returns the resizeChild element (or null).
   * @return {Ext.Element}
   */
  getResizeChild: function () {
    return this.resizeChild;
  },

  /**
   * Destroys this resizable. If the element was wrapped and
   * removeEl is not true then the element remains.
   * @param {Boolean} removeEl (optional) true to remove the element from the DOM
   */
  destroy: function (removeEl) {
    Ext.destroy(this.dd, this.overlay, this.proxy);
    this.overlay = null;
    this.proxy = null;

    var ps = Ext.Resizable.positions;
    for (var k in ps) {
      if (typeof ps[k] != 'function' && this[ps[k]]) {
        this[ps[k]].destroy();
      }
    }
    if (removeEl) {
      this.el.update('');
      Ext.destroy(this.el);
      this.el = null;
    }
    this.purgeListeners();
  },

  syncHandleHeight: function () {
    var h = this.el.getHeight(true);
    if (this.west) {
      this.west.el.setHeight(h);
    }
    if (this.east) {
      this.east.el.setHeight(h);
    }
  },
});

// private
// hash to map config positions to true positions
Ext.Resizable.positions = {
  n: 'north',
  s: 'south',
  e: 'east',
  w: 'west',
  se: 'southeast',
  sw: 'southwest',
  nw: 'northwest',
  ne: 'northeast',
};

// private
Ext.Resizable.Handle = function (rz, pos, disableTrackOver, transparent) {
  if (!this.tpl) {
    // only initialize the template if resizable is used
    var tpl = Ext.DomHelper.createTemplate({
      tag: 'div',
      cls: 'x-resizable-handle x-resizable-handle-{0}',
    });
    tpl.compile();
    Ext.Resizable.Handle.prototype.tpl = tpl;
  }
  this.position = pos;
  this.rz = rz;
  this.el = this.tpl.append(rz.el.dom, [this.position], true);
  this.el.unselectable();
  if (transparent) {
    this.el.setOpacity(0);
  }
  this.el.on('mousedown', this.onMouseDown, this);
  if (!disableTrackOver) {
    this.el.on('mouseover', this.onMouseOver, this);
    this.el.on('mouseout', this.onMouseOut, this);
  }
};

// private
Ext.Resizable.Handle.prototype = {
  // private
  afterResize: function (rz) {
    // do nothing
  },
  // private
  onMouseDown: function (e) {
    this.rz.onMouseDown(this, e);
  },
  // private
  onMouseOver: function (e) {
    this.rz.handleOver(this, e);
  },
  // private
  onMouseOut: function (e) {
    this.rz.handleOut(this, e);
  },
  // private
  destroy: function () {
    Ext.destroy(this.el);
    this.el = null;
  },
};
/*
 * Ext JS Library 2.3.0
 * Copyright(c) 2006-2009, Ext JS, LLC.
 * licensing@extjs.com
 *
 * http://extjs.com/license
 */

/**
 * @class Ext.Shadow
 * Simple class that can provide a shadow effect for any element.  Note that the element MUST be absolutely positioned,
 * and the shadow does not provide any shimming.  This should be used only in simple cases -- for more advanced
 * functionality that can also provide the same shadow effect, see the {@link Ext.Layer} class.
 * @constructor
 * Create a new Shadow
 * @param {Object} config The config object
 */
Ext.Shadow = function (config) {
  Ext.apply(this, config);
  if (typeof this.mode != 'string') {
    this.mode = this.defaultMode;
  }
  var o = this.offset,
    a = { h: 0 };
  var rad = Math.floor(this.offset / 2);
  switch (
    this.mode.toLowerCase() // all this hideous nonsense calculates the various offsets for shadows
  ) {
    case 'drop':
      a.w = 0;
      a.l = a.t = o;
      a.t -= 1;
      if (Ext.isIE) {
        a.l -= this.offset + rad;
        a.t -= this.offset + rad;
        a.w -= rad;
        a.h -= rad;
        a.t += 1;
      }
      break;
    case 'sides':
      a.w = o * 2;
      a.l = -o;
      a.t = o - 1;
      if (Ext.isIE) {
        a.l -= this.offset - rad;
        a.t -= this.offset + rad;
        a.l += 1;
        a.w -= (this.offset - rad) * 2;
        a.w -= rad + 1;
        a.h -= 1;
      }
      break;
    case 'frame':
      a.w = a.h = o * 2;
      a.l = a.t = -o;
      a.t += 1;
      a.h -= 2;
      if (Ext.isIE) {
        a.l -= this.offset - rad;
        a.t -= this.offset - rad;
        a.l += 1;
        a.w -= this.offset + rad + 1;
        a.h -= this.offset + rad;
        a.h += 1;
      }
      break;
  }

  this.adjusts = a;
};

Ext.Shadow.prototype = {
  /**
   * @cfg {String} mode
   * The shadow display mode.  Supports the following options:<br />
   * sides: Shadow displays on both sides and bottom only<br />
   * frame: Shadow displays equally on all four sides<br />
   * drop: Traditional bottom-right drop shadow (default)
   */
  /**
   * @cfg {String} offset
   * The number of pixels to offset the shadow from the element (defaults to 4)
   */
  offset: 4,

  // private
  defaultMode: 'drop',

  /**
   * Displays the shadow under the target element
   * @param {Mixed} targetEl The id or element under which the shadow should display
   */
  show: function (target) {
    target = Ext.get(target);
    if (!this.el) {
      this.el = Ext.Shadow.Pool.pull();
      if (this.el.dom.nextSibling != target.dom) {
        this.el.insertBefore(target);
      }
    }
    this.el.setStyle(
      'z-index',
      this.zIndex || parseInt(target.getStyle('z-index'), 10) - 1,
    );
    if (Ext.isIE) {
      this.el.dom.style.filter =
        'progid:DXImageTransform.Microsoft.alpha(opacity=50) progid:DXImageTransform.Microsoft.Blur(pixelradius=' +
        this.offset +
        ')';
    }
    this.realign(
      target.getLeft(true),
      target.getTop(true),
      target.getWidth(),
      target.getHeight(),
    );
    this.el.dom.style.display = 'block';
  },

  /**
   * Returns true if the shadow is visible, else false
   */
  isVisible: function () {
    return this.el ? true : false;
  },

  /**
   * Direct alignment when values are already available. Show must be called at least once before
   * calling this method to ensure it is initialized.
   * @param {Number} left The target element left position
   * @param {Number} top The target element top position
   * @param {Number} width The target element width
   * @param {Number} height The target element height
   */
  realign: function (l, t, w, h) {
    if (!this.el) {
      return;
    }
    var a = this.adjusts,
      d = this.el.dom,
      s = d.style;
    var iea = 0;
    s.left = l + a.l + 'px';
    s.top = t + a.t + 'px';
    var sw = w + a.w,
      sh = h + a.h,
      sws = sw + 'px',
      shs = sh + 'px';
    if (s.width != sws || s.height != shs) {
      s.width = sws;
      s.height = shs;
      if (!Ext.isIE) {
        var cn = d.childNodes;
        var sww = Math.max(0, sw - 12) + 'px';
        cn[0].childNodes[1].style.width = sww;
        cn[1].childNodes[1].style.width = sww;
        cn[2].childNodes[1].style.width = sww;
        cn[1].style.height = Math.max(0, sh - 12) + 'px';
      }
    }
  },

  /**
   * Hides this shadow
   */
  hide: function () {
    if (this.el) {
      this.el.dom.style.display = 'none';
      Ext.Shadow.Pool.push(this.el);
      delete this.el;
    }
  },

  /**
   * Adjust the z-index of this shadow
   * @param {Number} zindex The new z-index
   */
  setZIndex: function (z) {
    this.zIndex = z;
    if (this.el) {
      this.el.setStyle('z-index', z);
    }
  },
};

// Private utility class that manages the internal Shadow cache
Ext.Shadow.Pool = (function () {
  var p = [];
  var markup = Ext.isIE
    ? '<div class="x-ie-shadow"></div>'
    : '<div class="x-shadow"><div class="xst"><div class="xstl"></div><div class="xstc"></div><div class="xstr"></div></div><div class="xsc"><div class="xsml"></div><div class="xsmc"></div><div class="xsmr"></div></div><div class="xsb"><div class="xsbl"></div><div class="xsbc"></div><div class="xsbr"></div></div></div>';
  return {
    pull: function () {
      var sh = p.shift();
      if (!sh) {
        sh = Ext.get(
          Ext.DomHelper.insertHtml(
            'beforeBegin',
            document.body.firstChild,
            markup,
          ),
        );
        sh.autoBoxAdjust = false;
      }
      return sh;
    },

    push: function (sh) {
      p.push(sh);
    },
  };
})();
/*
 * Ext JS Library 2.3.0
 * Copyright(c) 2006-2009, Ext JS, LLC.
 * licensing@extjs.com
 *
 * http://extjs.com/license
 */

/**
 * @class Ext.util.TextMetrics
 * Provides precise pixel measurements for blocks of text so that you can determine exactly how high and
 * wide, in pixels, a given block of text will be.
 * @singleton
 */
Ext.util.TextMetrics = (function () {
  var shared;
  return {
    /**
     * Measures the size of the specified text
     * @param {String/HTMLElement} el The element, dom node or id from which to copy existing CSS styles
     * that can affect the size of the rendered text
     * @param {String} text The text to measure
     * @param {Number} fixedWidth (optional) If the text will be multiline, you have to set a fixed width
     * in order to accurately measure the text height
     * @return {Object} An object containing the text's size {width: (width), height: (height)}
     */
    measure: function (el, text, fixedWidth) {
      if (!shared) {
        shared = Ext.util.TextMetrics.Instance(el, fixedWidth);
      }
      shared.bind(el);
      shared.setFixedWidth(fixedWidth || 'auto');
      return shared.getSize(text);
    },

    /**
     * Return a unique TextMetrics instance that can be bound directly to an element and reused.  This reduces
     * the overhead of multiple calls to initialize the style properties on each measurement.
     * @param {String/HTMLElement} el The element, dom node or id that the instance will be bound to
     * @param {Number} fixedWidth (optional) If the text will be multiline, you have to set a fixed width
     * in order to accurately measure the text height
     * @return {Ext.util.TextMetrics.Instance} instance The new instance
     */
    createInstance: function (el, fixedWidth) {
      return Ext.util.TextMetrics.Instance(el, fixedWidth);
    },
  };
})();

Ext.util.TextMetrics.Instance = function (bindTo, fixedWidth) {
  var ml = new Ext.Element(document.createElement('div'));
  document.body.appendChild(ml.dom);
  ml.position('absolute');
  ml.setLeftTop(-1000, -1000);
  ml.hide();

  if (fixedWidth) {
    ml.setWidth(fixedWidth);
  }

  var instance = {
    /**
     * Returns the size of the specified text based on the internal element's style and width properties
     * @param {String} text The text to measure
     * @return {Object} An object containing the text's size {width: (width), height: (height)}
     */
    getSize: function (text) {
      ml.update(text);
      var s = ml.getSize();
      ml.update('');
      return s;
    },

    /**
     * Binds this TextMetrics instance to an element from which to copy existing CSS styles
     * that can affect the size of the rendered text
     * @param {String/HTMLElement} el The element, dom node or id
     */
    bind: function (el) {
      ml.setStyle(
        Ext.fly(el).getStyles(
          'font-size',
          'font-style',
          'font-weight',
          'font-family',
          'line-height',
          'text-transform',
          'letter-spacing',
        ),
      );
    },

    /**
     * Sets a fixed width on the internal measurement element.  If the text will be multiline, you have
     * to set a fixed width in order to accurately measure the text height.
     * @param {Number} width The width to set on the element
     */
    setFixedWidth: function (width) {
      ml.setWidth(width);
    },

    /**
     * Returns the measured width of the specified text
     * @param {String} text The text to measure
     * @return {Number} width The width in pixels
     */
    getWidth: function (text) {
      ml.dom.style.width = 'auto';
      return this.getSize(text).width;
    },

    /**
     * Returns the measured height of the specified text.  For multiline text, be sure to call
     * {@link #setFixedWidth} if necessary.
     * @param {String} text The text to measure
     * @return {Number} height The height in pixels
     */
    getHeight: function (text) {
      return this.getSize(text).height;
    },
  };

  instance.bind(bindTo);

  return instance;
};

// backwards compat
Ext.Element.measureText = Ext.util.TextMetrics.measure;
